<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="EncapsulatePublicFieldInspection" xml:space="preserve">
    <value>Das öffentliche Feld '{0}' bricht die Kapselung</value>
  </data>
  <data name="MoveFieldCloserToUsageInspection" xml:space="preserve">
    <value>Veringere die den Geltungsbereich der Modulvariable '{0}'.</value>
  </data>
  <data name="MultipleFolderAnnotationsInspection" xml:space="preserve">
    <value>'{0}' hat mehr als eine '@Folder'-Annotation</value>
  </data>
  <data name="ProcedureCanBeWrittenAsFunctionInspection" xml:space="preserve">
    <value>Prozedur '{0}' kann als Funktion geschrieben werden.</value>
    <comment>{0} Procedure name</comment>
  </data>
  <data name="IdentifierNameInspection" xml:space="preserve">
    <value>Übelege die Umbenennung {0} '{1}'</value>
  </data>
  <data name="WriteOnlyPropertyInspection" xml:space="preserve">
    <value>Eigenschaft '{0}' hat keinen Getter.</value>
    <comment>{0} Property name</comment>
  </data>
  <data name="SelfAssignedDeclarationInspection" xml:space="preserve">
    <value>Objekt-Referenz '{0}' ist sebstzugewiesen.</value>
  </data>
  <data name="FunctionReturnValueNotUsedInspection" xml:space="preserve">
    <value>Der Rückgabewert der Funktion '{0}' wird nicht verwendet.</value>
  </data>
  <data name="AssignedByValParameterInspection" xml:space="preserve">
    <value>Der Parameter '{0}' wird als byVal übergeben und bekommt ienen Wert zugesiesen.</value>
  </data>
  <data name="IdentifierNotUsedInspection" xml:space="preserve">
    <value>{0} '{1}' wird nicht genutzt</value>
  </data>
  <data name="ImplicitPublicMemberInspection" xml:space="preserve">
    <value>Methode '{0}' ist implizit 'Public'</value>
  </data>
  <data name="ImplicitVariantDeclarationInspection" xml:space="preserve">
    <value>{0} '{1}' ist implizit 'Variant'</value>
  </data>
  <data name="ImplicitVariantReturnTypeInspection" xml:space="preserve">
    <value>Der Rückgabewert der Methode '{0}' ist implizit 'Variant'.</value>
  </data>
  <data name="MultilineParameterInspection" xml:space="preserve">
    <value>Der Parameter '{0}' wird über mehrere Zeilen angegeben</value>
  </data>
  <data name="NonReturningFunctionInspection" xml:space="preserve">
    <value>Der Rückgabewert der Methode '{0}' wird nicht zugewiesen</value>
  </data>
  <data name="ObsoleteGlobalInspection" xml:space="preserve">
    <value>{0} '{1}' verwendet die veraltete 'Global' Zugriffsdeklaration</value>
  </data>
  <data name="ParameterCanBeByValInspection" xml:space="preserve">
    <value>Der Parameter '{0}' kann als Wert übergeben werden</value>
  </data>
  <data name="ParameterNotUsedInspection" xml:space="preserve">
    <value>Der Parameter '{0}' wird nicht verwendet.</value>
  </data>
  <data name="ProcedureShouldBeFunctionInspection" xml:space="preserve">
    <value>Die Prozedur '{0}' kann als Funktion geschrieben werden.</value>
  </data>
  <data name="UnassignedVariableUsageInspection" xml:space="preserve">
    <value>Die Variable '{0}' wird verwendet ohne ihr einen Wert zuzuweisen</value>
  </data>
  <data name="OptionExplicitInspection" xml:space="preserve">
    <value>'Option Explicit' ist für '{0}' nicht angegeben.</value>
  </data>
  <data name="VariableNotAssignedInspection" xml:space="preserve">
    <value>Der Variable '{0}' wird kein Wert zugewiesen.</value>
  </data>
  <data name="EmptyStringLiteralInspection" xml:space="preserve">
    <value>vbNullString' sollte statt einem leeren String-Literal verwendet werden.</value>
  </data>
  <data name="ObjectVariableNotSetInspection" xml:space="preserve">
    <value>Objektvariable '{0}' wird ohne das 'Set'-Schlüsselwort zugewiesen</value>
  </data>
  <data name="VariableTypeNotDeclaredInspection" xml:space="preserve">
    <value>{0} '{1}' ist implizit 'Variant'</value>
  </data>
  <data name="ObsoleteCommentSyntaxInspection" xml:space="preserve">
    <value>Kommentar verwendet die obsolete 'REM'-Markierung</value>
  </data>
  <data name="DefaultProjectNameInspection" xml:space="preserve">
    <value>Projekt '{0}' hat den Standardnamen</value>
  </data>
  <data name="ObsoleteCallStatementInspection" xml:space="preserve">
    <value>Zuweisung verwendet obsolete 'Call'-Anweisung</value>
  </data>
  <data name="ObsoleteLetStatementInspection" xml:space="preserve">
    <value>Zuweisung verwendet obsolete 'Let'-Anweisung</value>
  </data>
  <data name="ImplicitActiveSheetReferenceInspection" xml:space="preserve">
    <value>Member '{0}' referenziert implizit auf 'ActiveSheet'</value>
  </data>
  <data name="ImplicitActiveWorkbookReferenceInspection" xml:space="preserve">
    <value>Member '{0}' referenziert implizit auf 'ActiveWorkbook'</value>
  </data>
  <data name="UntypedFunctionUsageInspection" xml:space="preserve">
    <value>Ersetze Funktion {0} mit der existierenden typisierten Funktion</value>
  </data>
  <data name="OptionBaseInspection" xml:space="preserve">
    <value>Komponente '{0}' verwendet 'Option Base 1'</value>
  </data>
  <data name="ObsoleteTypeHintInspection" xml:space="preserve">
    <value>{0}  von {1} '{2}' verwendet einen obsoleten Typenhinweis</value>
  </data>
  <data name="MultipleDeclarationsInspection" xml:space="preserve">
    <value>Instruktion enthält Mehrfachdeklaration</value>
  </data>
  <data name="MissingAnnotationArgumentInspection" xml:space="preserve">
    <value>Ausdruck '{0}' sollte einen Parameter enthalten, es wurde aber keiner angegeben.</value>
  </data>
  <data name="UndeclaredVariableInspection" xml:space="preserve">
    <value>Die lokale Variable '{0}' wurde nicht deklariert</value>
  </data>
  <data name="ModuleScopeDimKeywordInspection" xml:space="preserve">
    <value>Die Modulvariable '{0}' ist mit dem 'Dim'-Schlüsselwort deklariert.</value>
  </data>
  <data name="AggregateInspection" xml:space="preserve">
    <value>{0} ({1} Ergebnisse)</value>
  </data>
  <data name="ApplicationWorksheetFunctionInspection" xml:space="preserve">
    <value>Laufzeitgebundene Nutzung des Application.{0} Members.</value>
  </data>
  <data name="ImplicitDefaultMemberAssignmentInspection" xml:space="preserve">
    <value>Zuweisung zu '{0}' weist implizit den Standard-Member von Klasse  '{1}' zu</value>
  </data>
  <data name="HostSpecificExpressionInspection" xml:space="preserve">
    <value>Ausdruck '{0}' kann zur Kompilierzeit nicht validiert werden.</value>
  </data>
  <data name="MemberNotOnInterfaceInspection" xml:space="preserve">
    <value>Member '{0}' ist auf dem Interface für '{1}' nicht deklariert.</value>
  </data>
  <data name="OptionBaseZeroInspection" xml:space="preserve">
    <value>Komponente '{0}' verwendet 'Option Base 0'</value>
  </data>
  <data name="ImplicitByRefModifierInspection" xml:space="preserve">
    <value>Der Parameter '{0}' wird implizit als Referenz übergeben.</value>
  </data>
  <data name="LineLabelNotUsedInspection" xml:space="preserve">
    <value>Die Zeilenbezeichnung '{0}' wird nicht verwendet</value>
  </data>
  <data name="RedundantByRefModifierInspection" xml:space="preserve">
    <value>Der Parameter '{0}' hat eine redundante 'ByRef'-Markierung</value>
  </data>
  <data name="EmptyIfBlockInspection" xml:space="preserve">
    <value>'If'-Block enthält keine ausführbaren Anweisungen</value>
  </data>
  <data name="IllegalAnnotationInspection" xml:space="preserve">
    <value>Die Annotation '{0}' ist in diesem Kontext nicht erlaubt.</value>
  </data>
  <data name="RedundantOptionInspection" xml:space="preserve">
    <value>'{0}' hat keine Auswirkung.</value>
  </data>
  <data name="MissingAnnotationInspection" xml:space="preserve">
    <value>Modul oder Element '{0}' hat ein '{1}' Attribut, aber keine zugehörige Annotation.</value>
  </data>
  <data name="MissingAttributeInspection" xml:space="preserve">
    <value>Modul oder Element '{0}' hat eine '{1}' Annotation, aber das zugehörige Attribut fehlt.</value>
  </data>
  <data name="EmptyCaseBlockInspection" xml:space="preserve">
    <value>'Case'-Block enthält keine ausführbaren Anweisungen</value>
  </data>
  <data name="StopKeywordInspection" xml:space="preserve">
    <value>Das Schlüsselwort 'Stop' unterbricht die Ausführung</value>
  </data>
  <data name="ShadowedDeclarationInspection" xml:space="preserve">
    <value>{0} '{1}' überschattet {2} '{3}'</value>
  </data>
  <data name="ObsoleteErrorSyntaxInspection" xml:space="preserve">
    <value>Ein Laufzeitfehler wird mit der veralteten 'Error'-Anweisung ausgelöst</value>
  </data>
  <data name="EmptyForEachBlockInspection" xml:space="preserve">
    <value>'For Each…Next'-Schleife enthält keine ausführbaren Anweisungen</value>
  </data>
  <data name="EmptyElseBlockInspection" xml:space="preserve">
    <value>'Else'-Block enthält keine ausführbaren Anweisungen</value>
  </data>
  <data name="EmptyForLoopBlockInspection" xml:space="preserve">
    <value>'For…Next'-Schleife enthält keine ausführbaren Anweisungen.</value>
  </data>
  <data name="IntegerDataTypeInspection" xml:space="preserve">
    <value>{0} '{1}' ist als Integer deklariert</value>
  </data>
  <data name="EmptyWhileWendBlockInspection" xml:space="preserve">
    <value>'While…Wend'-Schleife enthält keine ausführbaren Anweisungen</value>
  </data>
  <data name="EmptyDoWhileBlockInspection" xml:space="preserve">
    <value>'Do…While'-Schleife enthält keine ausführbaren Anweisungen</value>
  </data>
  <data name="BooleanAssignedInIfElseInspection" xml:space="preserve">
    <value>Boolean Ausdruck '{0}' wurde in einer trivialen If/Else-Verzweigung zugewiesen</value>
  </data>
  <data name="EmptyModuleInspection" xml:space="preserve">
    <value>Modul/Klasse {0} ist leer.</value>
  </data>
  <data name="UnreachableCaseInspection" xml:space="preserve">
    <value>Die Case-Klausel '{0}' kann nicht erreicht werden</value>
  </data>
  <data name="UnreachableCaseInspection_CaseElse" xml:space="preserve">
    <value>Nicht erreichbares Case Else: Alle möglichen Werte sind durch vorangehende Klausel(n) abgedeckt.</value>
  </data>
  <data name="UnreachableCaseInspection_TypeMismatch" xml:space="preserve">
    <value>Inakzeptabler Typ: Die Case-Anweisung kann nicht als derselbe Typ wie die Select-Anweisung ausgewertet werden.</value>
  </data>
  <data name="UnreachableCaseInspection_Unreachable" xml:space="preserve">
    <value>Unerreichbar: Case-Klausel ist bereits von anderen Klausel(n) abgehandelt.</value>
  </data>
  <data name="UnhandledOnErrorResumeNextInspection" xml:space="preserve">
    <value>Fehler werden ignoriert aber nie wieder behandelt.</value>
  </data>
  <data name="DefTypeStatementInspection" xml:space="preserve">
    <value>Statt '{1}' explizit 'as {0}' verwenden</value>
  </data>
  <data name="StepOneIsRedundantInspection" xml:space="preserve">
    <value>1 ist der Standardwert für 'Step' in einer 'For-Next'-Schleife und daher redundant.</value>
  </data>
  <data name="StepIsNotSpecifiedInspection" xml:space="preserve">
    <value>Step ist nicht angegeben</value>
  </data>
  <data name="UndeclaredRedimVariableInspection" xml:space="preserve">
    <value>Die Variable '{0}' im Redim statement existiert nicht und wird implizit erstellt</value>
    <comment>{0} Variable name</comment>
  </data>
</root>