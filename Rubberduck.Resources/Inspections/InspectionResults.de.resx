<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="EncapsulatePublicFieldInspection" xml:space="preserve">
    <value>Das öffentliche Feld '{0}' bricht die Kapselung.</value>
  </data>
  <data name="MoveFieldCloserToUsageInspection" xml:space="preserve">
    <value>Veringere die den Geltungsbereich der Modulvariable '{0}'.</value>
  </data>
  <data name="ProcedureCanBeWrittenAsFunctionInspection" xml:space="preserve">
    <value>Prozedur '{0}' kann als Funktion geschrieben werden.</value>
    <comment>{0} Procedure name</comment>
  </data>
  <data name="IdentifierNameInspection" xml:space="preserve">
    <value>Ziehen Sie in Erwägung, {0} '{1}' umzubenennen.</value>
  </data>
  <data name="WriteOnlyPropertyInspection" xml:space="preserve">
    <value>Eigenschaft '{0}' hat keinen Getter.</value>
    <comment>{0} Property name</comment>
  </data>
  <data name="SelfAssignedDeclarationInspection" xml:space="preserve">
    <value>Objekt-Referenz '{0}' ist sebstzugewiesen.</value>
  </data>
  <data name="FunctionReturnValueAlwaysDiscardedInspection" xml:space="preserve">
    <value>Der Rückgabewert der Funktion '{0}' wird immer verworfen.</value>
  </data>
  <data name="AssignedByValParameterInspection" xml:space="preserve">
    <value>Der Parameter '{0}' wird als byVal übergeben und bekommt einen Wert zugewiesen.</value>
  </data>
  <data name="IdentifierNotUsedInspection" xml:space="preserve">
    <value>{0} '{1}' wird nicht genutzt.</value>
  </data>
  <data name="ImplicitPublicMemberInspection" xml:space="preserve">
    <value>Methode '{0}' ist implizit 'Public'.</value>
  </data>
  <data name="ImplicitVariantDeclarationInspection" xml:space="preserve">
    <value>{0} '{1}' ist implizit 'Variant'.</value>
  </data>
  <data name="ImplicitVariantReturnTypeInspection" xml:space="preserve">
    <value>Der Rückgabewert der Methode '{0}' ist implizit 'Variant'.</value>
  </data>
  <data name="MultilineParameterInspection" xml:space="preserve">
    <value>Der Parameter '{0}' wird über mehrere Zeilen angegeben.</value>
  </data>
  <data name="NonReturningFunctionInspection" xml:space="preserve">
    <value>Der Rückgabewert der Methode '{0}' wird nicht zugewiesen.</value>
  </data>
  <data name="ObsoleteGlobalInspection" xml:space="preserve">
    <value>{0} '{1}' verwendet die veraltete 'Global' Zugriffsdeklaration.</value>
  </data>
  <data name="ParameterCanBeByValInspection" xml:space="preserve">
    <value>Der Parameter '{0}' kann als Wert übergeben werden.</value>
  </data>
  <data name="ProcedureShouldBeFunctionInspection" xml:space="preserve">
    <value>Die Prozedur '{0}' kann als Funktion geschrieben werden.</value>
  </data>
  <data name="UnassignedVariableUsageInspection" xml:space="preserve">
    <value>Die Variable '{0}' wird verwendet ohne ihr einen Wert zuzuweisen.</value>
  </data>
  <data name="OptionExplicitInspection" xml:space="preserve">
    <value>'Option Explicit' ist für '{0}' nicht angegeben.</value>
  </data>
  <data name="VariableNotAssignedInspection" xml:space="preserve">
    <value>Der Variable '{0}' wird kein Wert zugewiesen.</value>
  </data>
  <data name="EmptyStringLiteralInspection" xml:space="preserve">
    <value>'vbNullString' sollte statt einem leeren String-Literal verwendet werden.</value>
  </data>
  <data name="ObjectVariableNotSetInspection" xml:space="preserve">
    <value>Objektvariable '{0}' wird ohne das 'Set'-Schlüsselwort zugewiesen.</value>
  </data>
  <data name="VariableTypeNotDeclaredInspection" xml:space="preserve">
    <value>{0} '{1}' ist implizit 'Variant'.</value>
  </data>
  <data name="ObsoleteCommentSyntaxInspection" xml:space="preserve">
    <value>Kommentar verwendet die obsolete 'REM'-Markierung.</value>
  </data>
  <data name="DefaultProjectNameInspection" xml:space="preserve">
    <value>Projekt '{0}' hat den Standardnamen.</value>
  </data>
  <data name="ObsoleteCallStatementInspection" xml:space="preserve">
    <value>Verwendung der veralteten 'Call'-Anweisung.</value>
  </data>
  <data name="ObsoleteLetStatementInspection" xml:space="preserve">
    <value>Verwendung der veralteten 'Let'-Anweisung.</value>
  </data>
  <data name="ImplicitActiveSheetReferenceInspection" xml:space="preserve">
    <value>Member '{0}' referenziert implizit auf 'ActiveSheet'.</value>
  </data>
  <data name="ImplicitActiveWorkbookReferenceInspection" xml:space="preserve">
    <value>Member '{0}' referenziert implizit auf 'ActiveWorkbook'.</value>
  </data>
  <data name="UntypedFunctionUsageInspection" xml:space="preserve">
    <value>Ersetze Funktion {0} mit der existierenden typisierten Funktion.</value>
  </data>
  <data name="OptionBaseInspection" xml:space="preserve">
    <value>Komponente '{0}' verwendet 'Option Base 1'.</value>
  </data>
  <data name="ObsoleteTypeHintInspection" xml:space="preserve">
    <value>{0}  von {1} '{2}' verwendet einen obsoleten Typenhinweis.</value>
  </data>
  <data name="MultipleDeclarationsInspection" xml:space="preserve">
    <value>Instruktion enthält Mehrfachdeklaration.</value>
  </data>
  <data name="MissingAnnotationArgumentInspection" xml:space="preserve">
    <value>Die Annotation '{0}' erwartet mehr Argumente.</value>
  </data>
  <data name="UndeclaredVariableInspection" xml:space="preserve">
    <value>Die lokale Variable '{0}' wurde nicht deklariert.</value>
  </data>
  <data name="ModuleScopeDimKeywordInspection" xml:space="preserve">
    <value>Die Modulvariable '{0}' ist mit dem 'Dim'-Schlüsselwort deklariert.</value>
  </data>
  <data name="AggregateInspection" xml:space="preserve">
    <value>{0} ({1} Ergebnisse)</value>
  </data>
  <data name="ApplicationWorksheetFunctionInspection" xml:space="preserve">
    <value>Laufzeitgebundene Nutzung des Application.{0} Members.</value>
  </data>
  <data name="HostSpecificExpressionInspection" xml:space="preserve">
    <value>Ausdruck '{0}' kann zur Kompilierzeit nicht validiert werden.</value>
  </data>
  <data name="MemberNotOnInterfaceInspection" xml:space="preserve">
    <value>Element '{0}' ist auf dem Interface für '{1}' nicht deklariert.</value>
  </data>
  <data name="OptionBaseZeroInspection" xml:space="preserve">
    <value>Komponente '{0}' verwendet 'Option Base 0'.</value>
  </data>
  <data name="ImplicitByRefModifierInspection" xml:space="preserve">
    <value>Der Parameter '{0}' wird implizit als Referenz übergeben.</value>
  </data>
  <data name="LineLabelNotUsedInspection" xml:space="preserve">
    <value>Die Zeilenbezeichnung '{0}' wird nicht verwendet.</value>
  </data>
  <data name="RedundantByRefModifierInspection" xml:space="preserve">
    <value>Der Parameter '{0}' hat eine redundante 'ByRef'-Markierung.</value>
  </data>
  <data name="EmptyIfBlockInspection" xml:space="preserve">
    <value>'If'-Block enthält keine ausführbaren Anweisungen.</value>
  </data>
  <data name="RedundantOptionInspection" xml:space="preserve">
    <value>'{0}' hat keine Auswirkung.</value>
  </data>
  <data name="MissingAttributeInspection" xml:space="preserve">
    <value>Modul oder Element '{0}' hat eine '{1}' Annotation, aber das zugehörige Attribut fehlt.</value>
  </data>
  <data name="EmptyCaseBlockInspection" xml:space="preserve">
    <value>'Case'-Block enthält keine ausführbaren Anweisungen.</value>
  </data>
  <data name="StopKeywordInspection" xml:space="preserve">
    <value>Das Schlüsselwort 'Stop' unterbricht die Ausführung.</value>
  </data>
  <data name="ShadowedDeclarationInspection" xml:space="preserve">
    <value>{0} '{1}' überschattet {2} '{3}'.</value>
  </data>
  <data name="ObsoleteErrorSyntaxInspection" xml:space="preserve">
    <value>Ein Laufzeitfehler wird mit der veralteten 'Error'-Anweisung ausgelöst.</value>
  </data>
  <data name="EmptyForEachBlockInspection" xml:space="preserve">
    <value>'For Each…Next'-Schleife enthält keine ausführbaren Anweisungen.</value>
  </data>
  <data name="EmptyElseBlockInspection" xml:space="preserve">
    <value>'Else'-Block enthält keine ausführbaren Anweisungen.</value>
  </data>
  <data name="EmptyForLoopBlockInspection" xml:space="preserve">
    <value>'For…Next'-Schleife enthält keine ausführbaren Anweisungen.</value>
  </data>
  <data name="IntegerDataTypeInspection" xml:space="preserve">
    <value>{0} '{1}' ist als Integer deklariert.</value>
  </data>
  <data name="EmptyWhileWendBlockInspection" xml:space="preserve">
    <value>'While…Wend'-Schleife enthält keine ausführbaren Anweisungen.</value>
  </data>
  <data name="EmptyDoWhileBlockInspection" xml:space="preserve">
    <value>'Do…While'-Schleife enthält keine ausführbaren Anweisungen.</value>
  </data>
  <data name="BooleanAssignedInIfElseInspection" xml:space="preserve">
    <value>Boolean Ausdruck '{0}' wurde in einer trivialen If/Else-Verzweigung zugewiesen</value>
  </data>
  <data name="EmptyModuleInspection" xml:space="preserve">
    <value>Modul/Klasse {0} ist leer.</value>
  </data>
  <data name="UnhandledOnErrorResumeNextInspection" xml:space="preserve">
    <value>Fehler werden ignoriert aber nie wieder behandelt.</value>
  </data>
  <data name="DefTypeStatementInspection" xml:space="preserve">
    <value>Statt '{1}' explizit 'As {0}' verwenden.</value>
  </data>
  <data name="StepOneIsRedundantInspection" xml:space="preserve">
    <value>1 ist der Standardwert für 'Step' in einer 'For-Next'-Schleife und daher redundant.</value>
  </data>
  <data name="StepIsNotSpecifiedInspection" xml:space="preserve">
    <value>Step ist nicht angegeben.</value>
  </data>
  <data name="SheetAccessedUsingStringInspection" xml:space="preserve">
    <value>Statisch erreichbares Tabellenblatt kann mit dem Code-Namen referenziert werden.</value>
  </data>
  <data name="ObsoleteMemberUsageInspection" xml:space="preserve">
    <value>Erwägen Sie, den Aufruf von '{0}' zu ersetzen. {1}</value>
  </data>
  <data name="ObsoleteCallingConventionInspection" xml:space="preserve">
    <value>'{0}' wurde mit der unter Windows nicht erlaubten 'CDecl'-Aufrufkonvention deklariert.</value>
  </data>
  <data name="DuplicatedAnnotationInspection" xml:space="preserve">
    <value>Annotation '{0}' wurde mehrfach spezifiziert.</value>
  </data>
  <data name="ModuleWithoutFolderInspection" xml:space="preserve">
    <value>Das Modul '{0}' hat keine '@Folder'-Annotation.</value>
  </data>
  <data name="OnLocalErrorInspection" xml:space="preserve">
    <value>'On Local Error'-Direktive erkannt.</value>
  </data>
  <data name="IsMissingOnInappropriateArgumentInspection" xml:space="preserve">
    <value>'IsMissing' wird mit dem übergebenen Argument immer 'False' zurückliefern.</value>
  </data>
  <data name="IsMissingWithNonArgumentParameterInspection" xml:space="preserve">
    <value>'IsMissing' wird ein Ausdruck übergeben, der kein Argument der umgebenden Prozedur ist.</value>
  </data>
  <data name="AssignmentNotUsedInspection" xml:space="preserve">
    <value>Eine Zuweisung wird sofort überschrieben oder nie gelesen.</value>
  </data>
  <data name="UnderscoreInPublicClassModuleMemberInspection" xml:space="preserve">
    <value>Der öffentliche Membername '{0}' enthält einen Unterstrich.</value>
  </data>
  <data name="ExcelMemberMayReturnNothingInspection" xml:space="preserve">
    <value>Das Ergebnis des Aufrufs von '{0}' wird nie auf 'Nothing' überprüft.</value>
  </data>
  <data name="ExcelUdfNameIsValidCellReferenceInspection" xml:space="preserve">
    <value>'{0}' wird von einem EXCEL-Zellverweis verdeckt.</value>
  </data>
  <data name="AttributeValueOutOfSyncInspection" xml:space="preserve">
    <value>Die Wert(e) des {0}-Attributs ({1}) passen nicht zur {2}-Annotation.</value>
  </data>
  <data name="MissingMemberAnnotationInspection" xml:space="preserve">
    <value>Element '{0}' hat ein '{1}' Attribut mit Wert(en) '{2}', aber keine zugehörige Annotation.</value>
  </data>
  <data name="MissingModuleAnnotationInspection" xml:space="preserve">
    <value>Modul '{0}' hat ein '{1}' Attribut mit Wert(en) '{2}', aber keine zugehörige Annotation.</value>
  </data>
  <data name="KeywordsUsedAsMemberInspection" xml:space="preserve">
    <value>Der Name des Elements '{0}' ist ein Schlüsselwort.</value>
  </data>
  <data name="LineContinuationBetweenKeywordsInspection" xml:space="preserve">
    <value>Zeilenfortsetzungszeichen an unerwarteten Orten.</value>
  </data>
  <data name="NonBreakingSpaceIdentifierInspection" xml:space="preserve">
    <value>Der Bezeichner '{0}' enthält ein geschütztes Leerzeichen.</value>
  </data>
  <data name="ThunderCode_Base" xml:space="preserve">
    <value>{0}
Andrew "ThunderFrame" Jackson wäre stolz! 
Sie sehen dies, da es nicht sein kann, dass dies ein echtes Programm ist. Sie versuchen lediglich Rubberducks Grenzen auszuloten, oder? ..ODER? 
In Memoriam, 1972-2018</value>
  </data>
  <data name="NegativeLineNumberInspection" xml:space="preserve">
    <value>Verwendung einer negativen Zeilennummer</value>
  </data>
  <data name="OnErrorGoToMinusOneInspection" xml:space="preserve">
    <value>Verwendung von 'On Error GoTo -1'</value>
  </data>
  <data name="ObsoleteWhileWendStatementInspection" xml:space="preserve">
    <value>'While...Wend'-Schleife kann als 'Do While...Loop'-Block formuliert werden.</value>
  </data>
  <data name="SetAssignmentWithIncompatibleObjectTypeInspection" xml:space="preserve">
    <value>Der Variablen '{0}' vom deklarierten Typ '{1}' wird eine Wert des inkompatiblen Typs '{2}' Set-zugewiesen.</value>
  </data>
  <data name="ArgumentWithIncompatibleObjectTypeInspection" xml:space="preserve">
    <value>Das Argument '{2}' vom Typ '{3}' wird für den Parameter '{0}' vom inkompatiblen Typ '{1}' übergeben.</value>
  </data>
  <data name="EmptyMethodInspection" xml:space="preserve">
    <value>{0} '{1}'  enthält keine ausführbaren Anweisungen.</value>
  </data>
  <data name="ImplementedInterfaceMemberInspection" xml:space="preserve">
    <value>Die Interface-Klasse '{2}' enthält eine Implementierung für die  {0} '{1}'.</value>
  </data>
  <data name="ValueRequiredInspection" xml:space="preserve">
    <value>An einer Stelle, die einen Wert verlangt, wird der Ausdruck '{0}' vom Objekttyp '{1}'  verwendet, der keinen passendes Standardelement hat.</value>
  </data>
  <data name="ProcedureRequiredInspection" xml:space="preserve">
    <value>An einer Stelle, die eine Prozedur erfordert, wird der Ausdruck '{0}' vom Objekttyp '{1}'  verwendet, der keinen passendes Standardelement hat.</value>
  </data>
  <data name="DefaultMemberRequiredInspection" xml:space="preserve">
    <value>Der Ausdruck '{0}' erfordert einen Standardelementzugriff, aber der Typ '{1}' hat kein passendes Standardelement.</value>
  </data>
  <data name="UseOfBangNotationInspection" xml:space="preserve">
    <value>Der Ausdruck '{0}' verwendet Ausrufezeichennotation.</value>
  </data>
  <data name="UseOfRecursiveBangNotationInspection" xml:space="preserve">
    <value>Der Ausdruck '{0}' verwendet rekursive Ausrufezeichennotation.</value>
  </data>
  <data name="UseOfUnboundBangNotationInspection" xml:space="preserve">
    <value>Der Ausdruck '{0}' verwendet nicht gebundene Ausrufezeichennotation.</value>
  </data>
  <data name="ObjectWhereProcedureIsRequiredInspection" xml:space="preserve">
    <value>Der Ausdruck '{0}' wird an einer Stelle verwendet, die nach einer Prozedur verlangt, was zu einem Aufruf des Standardelements '{1}' führt.</value>
  </data>
  <data name="ObjectWhereProcedureIsRequiredInspection_Unbound" xml:space="preserve">
    <value>Der Ausdruck '{0}' wird an einer Stelle verwendet, die nach einer Prozedur verlangt, was zu einem Aufruf eines Standardelements führt, welcher erst zur Laufzeit bestimmt werden kann.</value>
  </data>
  <data name="IndexedDefaultMemberAccessInspection" xml:space="preserve">
    <value>Der Ausdruck '{0}' enthält einen parametrisierten Zugriff auf das Standardelement '{1}'.</value>
  </data>
  <data name="IndexedRecursiveDefaultMemberAccessInspection" xml:space="preserve">
    <value>Der Ausdruck '{0}' enthält einen parametrisierten rekursiven Standardelementzugriff auf '{1}'.</value>
  </data>
  <data name="IndexedUnboundDefaultMemberAccessInspection" xml:space="preserve">
    <value>Der Ausdruck '{0}' enthält einen parametrisierten nicht gebundenen Standardelementzugriff.</value>
  </data>
  <data name="ImplicitDefaultMemberAccessInspection" xml:space="preserve">
    <value>Für den Ausdruck '{0}' kommt es zu einem impliziten Zugriff auf das Standardelement '{1}'.</value>
  </data>
  <data name="ImplicitRecursiveDefaultMemberAccessInspection" xml:space="preserve">
    <value>Für den Ausdruck '{0}' kommt es zu einem impliziten rekursiven Standardelementzugriff auf '{1}'.</value>
  </data>
  <data name="ImplicitUnboundDefaultMemberAccessInspection" xml:space="preserve">
    <value>Für den Ausdruck '{0}' kommt es zu einem impliziten nicht gebundenen Standardelementzugriff.</value>
  </data>
  <data name="SuspiciousLetAssignmentInspection" xml:space="preserve">
    <value>Es wird vom Standardmember des Resultats des Ausdrucks '{1}' dem des Resultats des Ausdrucks '{0}' zugewiesen.</value>
  </data>
  <data name="UnreachableCaseInspection" xml:space="preserve">
    <value>Der Case-Zweig '{0}' kann niemals erreicht werden.</value>
  </data>
  <data name="UnreachableCaseInspection_CaseElse" xml:space="preserve">
    <value>Der 'Case Else'-Zweig kann niemals erreicht werden.</value>
  </data>
  <data name="UnreachableCaseInspection_TypeMismatch" xml:space="preserve">
    <value>Der Case-Ausdruck wird einen Laufzeitfehler 13 (Typkonflikt) verursachen.</value>
  </data>
  <data name="UnreachableCaseInspection_Overflow" xml:space="preserve">
    <value>Der Case-Ausdruck wird den Laufzeitfehler 6 (Überlauf) verursachen.</value>
  </data>
  <data name="UnreachableCaseInspection_Unreachable" xml:space="preserve">
    <value>Der Case-Ausdruck kann niemals erreicht werden.</value>
  </data>
  <data name="UnreachableCaseInspection_InherentlyUnreachable" xml:space="preserve">
    <value>Bereichsbedingungen in Case-Ausdrücken müssen von der Form '[x] T [y]' sein, wobei [x] kleiner oder gleich [y] ist.</value>
  </data>
  <data name="FunctionReturnValueDiscardedInspection" xml:space="preserve">
    <value>Der Rückgabewert der Funktion '{0}' wird verworfen.</value>
  </data>
  <data name="ImplicitlyTypedConstInspection" xml:space="preserve">
    <value>Der Datentyp der Konstante '{0}' ist implizit bestimmt.</value>
  </data>
  <data name="SuperfluousAnnotationArgumentInspection" xml:space="preserve">
    <value>Die Annotation '{0}' erwartet weniger Argumente.</value>
  </data>
  <data name="ImplicitContainingWorkbookReferenceInspection" xml:space="preserve">
    <value>Element '{0}' referenziert implizit auf das umgebende Workbook-Modul.</value>
  </data>
  <data name="ImplicitContainingWorksheetReferenceInspection" xml:space="preserve">
    <value>Element '{0}' referenziert implizit auf das umgebende Worksheet-Modul.</value>
  </data>
  <data name="MisleadingByRefParameterInspection" xml:space="preserve">
    <value>Irreführender ByRef Modifizierer für den Parameter '{0}' ({1}) benutzt.</value>
  </data>
  <data name="InvalidAnnotationInspection" xml:space="preserve">
    <value>Die Annotation '{0}' ist in diesem Kontext nicht zulässig.</value>
  </data>
  <data name="UnrecognizedAnnotationInspection" xml:space="preserve">
    <value>'{0}' ist keine von Rubberduck unterstützte Annotation</value>
  </data>
  <data name="InvalidAnnotationInspection_NotInRequiredComponentType" xml:space="preserve">
    <value>Die Annotation '{0}' wurde in einer Komponente des Typs '{1}' verwendet, kann aber nur in Komponenten des Typs '{2}' verwendet werden.</value>
  </data>
  <data name="InvalidAnnotationInspection_IncompatibleComponentType" xml:space="preserve">
    <value>Die Annotation '{0}' kann nicht in einer Komponente des Typs '{1}' verwendet werden.</value>
  </data>
  <data name="ParameterNotUsedInspection" xml:space="preserve">
    <value>Parameter '{0}' wird nicht verwendet.</value>
  </data>
  <data name="IIfSideEffectInspection" xml:space="preserve">
    <value>'{0}' wird durch die 'IIf'-Funktion aufgerufen</value>
  </data>
  <data name="PublicControlFieldAccessInspection" xml:space="preserve">
    <value>Auf das Steuerelement '{0}.{1}' wird von außerhalb seines Eltern(Parent)-Formulars zugegriffen. </value>
  </data>
  <data name="ReadOnlyPropertyAssignmentInspection" xml:space="preserve">
    <value>Versuch, die "Nur Lesen"-Eigenschaft '{0}' zu verändern.</value>
  </data>
  <data name="PublicImplementationShouldBePrivateInspection" xml:space="preserve">
    <value>Element '{0}' sollte 'Private' sein.</value>
  </data>
  <data name="SuspiciousPredeclaredInstanceAccessInspection" xml:space="preserve">
    <value>Bezeichnung '{0}' in '{1}' verweist verdächtigerweise auf die Standardinstanz dieses Klassentyps. </value>
  </data>
  <data name="PublicEnumerationDeclaredInWorksheetInspection" xml:space="preserve">
    <value>Die öffentliche (Public) Enumeration '{0}' sollte in einem Standard- oder Klassenmodule erfolgen</value>
  </data>
</root>