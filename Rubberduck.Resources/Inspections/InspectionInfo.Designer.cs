//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Rubberduck.Resources.Inspections {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public class InspectionInfo {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal InspectionInfo() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Rubberduck.Resources.Inspections.InspectionInfo", typeof(InspectionInfo).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Excel Application object does not implement the WorksheetFunction interface directly. All calls made to WorksheetFunction members are handled as late bound and errors in the called member will be returned wrapped in a Variant of VbVarType.vbError. This makes errors un-trappable with error handlers and adds a performance penalty in comparison to early bound calls. Consider calling Application.WorksheetFunction explicitly. Note: If this call generated errors in the past, those errors were ignored. If appl [rest of string was truncated]&quot;;.
        /// </summary>
        public static string ApplicationWorksheetFunctionInspection {
            get {
                return ResourceManager.GetString("ApplicationWorksheetFunctionInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter is passed by value, but is assigned a new value/reference. Consider making a local copy instead if the caller isn&apos;t supposed to know the new value. If the caller should see the new value, the parameter should be passed ByRef instead, and you have a bug..
        /// </summary>
        public static string AssignedByValParameterInspection {
            get {
                return ResourceManager.GetString("AssignedByValParameterInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An assignment is immediately overridden by another assignment or is never referenced..
        /// </summary>
        public static string AssignmentNotUsedInspection {
            get {
                return ResourceManager.GetString("AssignmentNotUsedInspection", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to An assignment is immediately overridden by another assignment or is never referenced..
        /// </summary>
        public static string AttributeValueOutOfSyncInspection
        {
            get {
                return ResourceManager.GetString("AttributeValueOutOfSyncInspection", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to A member is assigned True/False in different branches of an if statement with no other statements in the conditional. Use the condition directly to the member instead..
        /// </summary>
        public static string BooleanAssignedInIfElseInspection {
            get {
                return ResourceManager.GetString("BooleanAssignedInIfElseInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rubberduck could not find any reference to constant. Consider removing the unused declaration..
        /// </summary>
        public static string ConstantNotUsedInspection {
            get {
                return ResourceManager.GetString("ConstantNotUsedInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider naming your VBA project..
        /// </summary>
        public static string DefaultProjectNameInspection {
            get {
                return ResourceManager.GetString("DefaultProjectNameInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Using the &apos;Def[Type]&apos; statement leads to specifying types by using a prefix. This style of naming is heavily discouraged and should be avoided..
        /// </summary>
        public static string DefTypeStatementInspection {
            get {
                return ResourceManager.GetString("DefTypeStatementInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An annotation is specified multiple times, but is intended to be specified only once..
        /// </summary>
        public static string DuplicatedAnnotationInspection {
            get {
                return ResourceManager.GetString("DuplicatedAnnotationInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An empty &apos;Case&apos; block without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn&apos;t need to be written..
        /// </summary>
        public static string EmptyCaseBlockInspection {
            get {
                return ResourceManager.GetString("EmptyCaseBlockInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An empty &apos;Do...While&apos; loop without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn&apos;t need to be written..
        /// </summary>
        public static string EmptyDoWhileBlockInspection {
            get {
                return ResourceManager.GetString("EmptyDoWhileBlockInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An empty &apos;Else&apos; loop without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn&apos;t need to be written..
        /// </summary>
        public static string EmptyElseBlockInspection {
            get {
                return ResourceManager.GetString("EmptyElseBlockInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An empty &apos;For Each...Next&apos; loop without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn&apos;t need to be written..
        /// </summary>
        public static string EmptyForEachBlockInspection {
            get {
                return ResourceManager.GetString("EmptyForEachBlockInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An empty &apos;For...Next&apos; loop without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn&apos;t need to be written..
        /// </summary>
        public static string EmptyForLoopBlockInspection {
            get {
                return ResourceManager.GetString("EmptyForLoopBlockInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An empty conditional branch without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn&apos;t need to be written..
        /// </summary>
        public static string EmptyIfBlockInspection {
            get {
                return ResourceManager.GetString("EmptyIfBlockInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Empty modules and classes either point to not yet implemented functionality or represent unnecessary baggage that can hurt the maintainability of a project..
        /// </summary>
        public static string EmptyModuleInspection {
            get {
                return ResourceManager.GetString("EmptyModuleInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The built-in constant &apos;vbNullString&apos; is a null string pointer taking up 0 bytes of memory, that unambiguously conveys the intent of an empty string..
        /// </summary>
        public static string EmptyStringLiteralInspection {
            get {
                return ResourceManager.GetString("EmptyStringLiteralInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An empty &apos;Loop&apos; block without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn&apos;t need to be written..
        /// </summary>
        public static string EmptyWhileWendBlockInspection {
            get {
                return ResourceManager.GetString("EmptyWhileWendBlockInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider exposing a property instead..
        /// </summary>
        public static string EncapsulatePublicFieldInspection {
            get {
                return ResourceManager.GetString("EncapsulatePublicFieldInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A procedure that returns an object may return &apos;Nothing&apos;. That will cause a runtime error 91 - &quot;Object variable or With block variable not set&quot; on subsequent member access. Perform an &apos;Is Nothing&apos; check after the &apos;Set&apos; assignment to guard against runtime errors..
        /// </summary>
        public static string ExcelMemberMayReturnNothingInspection {
            get {
                return ResourceManager.GetString("ExcelMemberMayReturnNothingInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Functions that are visible to Excel as User-Defined Functions will return a &apos;#REF&apos; error when used on a Worksheet if they match the name of a valid cell reference. If the function is intended to be used as a UDF, it must be renamed. If the function is not intended to be used as a UDF, it should be scoped as &apos;Private&apos; or moved out of a standard Module..
        /// </summary>
        public static string ExcelUdfNameIsValidCellReferenceInspection {
            get {
                return ResourceManager.GetString("ExcelUdfNameIsValidCellReferenceInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A member is written as a function, but used as a procedure. Unless the function is recursive, consider converting the &apos;Function&apos; into a &apos;Sub&apos;. If the function is recursive, none of its external callers are using the returned value..
        /// </summary>
        public static string FunctionReturnValueNotUsedInspection {
            get {
                return ResourceManager.GetString("FunctionReturnValueNotUsedInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bracketed expressions are evaluated by the host application at runtime, which means VBA can&apos;t validate the expression at compile-time. Consider using the host application&apos;s object model instead..
        /// </summary>
        public static string HostSpecificExpressionInspection {
            get {
                return ResourceManager.GetString("HostSpecificExpressionInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Hungarian notation makes code less readable, and is redundant when strongly typed variables and meaningful names are used..
        /// </summary>
        public static string HungarianNotationInspection {
            get {
                return ResourceManager.GetString("HungarianNotationInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An annotation meant to be specified at module level cannot be used to annotate members; annotations meant to be annotate members cannot be used at module level..
        /// </summary>
        public static string IllegalAnnotationInspection {
            get {
                return ResourceManager.GetString("IllegalAnnotationInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implicit references to the active sheet make the code frail and harder to debug. Consider making these references explicit when they&apos;re intended, and prefer working off object references. Ignore if the member call is referring to a type Rubberduck can&apos;t resolve..
        /// </summary>
        public static string ImplicitActiveSheetReferenceInspection {
            get {
                return ResourceManager.GetString("ImplicitActiveSheetReferenceInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implicit references to the active workbook make the code frail and harder to debug. Consider making these references explicit when they&apos;re intended, and prefer working off object references. Ignore if the member call is referring to a type Rubberduck can&apos;t resolve..
        /// </summary>
        public static string ImplicitActiveWorkbookReferenceInspection {
            get {
                return ResourceManager.GetString("ImplicitActiveWorkbookReferenceInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameters are passed by reference unless specified otherwise, which can be confusing and bug-prone. Prefer passing parameters by value, and specify ByRef explicitly when passing parameters by reference..
        /// </summary>
        public static string ImplicitByRefModifierInspection {
            get {
                return ResourceManager.GetString("ImplicitByRefModifierInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Such assignments look like they are assigning an object variable to a value type on the surface, but they are actually assigning that object&apos;s default member, implicitly. Consider referring to the default member explicitly, for improved readability..
        /// </summary>
        public static string ImplicitDefaultMemberAssignmentInspection {
            get {
                return ResourceManager.GetString("ImplicitDefaultMemberAssignmentInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Module members are public by default, which can be counter-intuitive. Consider specifying explicit access modifiers to avoid ambiguity..
        /// </summary>
        public static string ImplicitPublicMemberInspection {
            get {
                return ResourceManager.GetString("ImplicitPublicMemberInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Members with a return value implicitly return a &apos;Variant&apos; unless specified otherwise. Consider returning an explicit &apos;Variant&apos; when the return type isn&apos;t known, or specify it explicitly..
        /// </summary>
        public static string ImplicitVariantReturnTypeInspection {
            get {
                return ResourceManager.GetString("ImplicitVariantReturnTypeInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The maximum value of a 16-bit signed integer is 32,767 - using a 32-bit (Long) integer data type where possible can help prevent &apos;Overflow&apos; run-time errors, and is better handled by modern CPUs..
        /// </summary>
        public static string IntegerDataTypeInspection {
            get {
                return ResourceManager.GetString("IntegerDataTypeInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to IsMissing is only intended to be called on optional arguments, and will only return correct results if the type of the argument is &apos;Variant&apos; with no explicit default value. All other uses will return &apos;False&apos;..
        /// </summary>
        public static string IsMissingOnInappropriateArgumentInspection {
            get {
                return ResourceManager.GetString("IsMissingOnInappropriateArgumentInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to IsMissing is only intended to be called on arguments of the containing procedure, and almost all other usages will return &apos;False&apos;. Passing any other expression to the function is the equivalent to &apos;VarType({expression}) = vbError&apos;, and in rare circumstances can cause the host application to crash..
        /// </summary>
        public static string IsMissingWithNonArgumentParameterInspection {
            get {
                return ResourceManager.GetString("IsMissingWithNonArgumentParameterInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A line label that is never jumpted to (&apos;GoTo&apos;, &apos;Resume&apos;, ...), serves no purpose. Consider removing it..
        /// </summary>
        public static string LineLabelNotUsedInspection {
            get {
                return ResourceManager.GetString("LineLabelNotUsedInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A member access call is made against an extended interface that Rubberduck couldn&apos;t resolve, or the member couldn&apos;t be found. If VBA cannot resolve the type at run-time, error 438 will be raised. If an equivalent, non-extended interface that Rubberduck can resolve is available, consider using it instead..
        /// </summary>
        public static string MemberNotOnInterfaceInspection {
            get {
                return ResourceManager.GetString("MemberNotOnInterfaceInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An annotation parameter is missing or incorrectly specified. The correct syntax is : &apos;@Annotation([parameter])\nExample: &apos;@Folder(&quot;Parent.Child&quot;).
        /// </summary>
        public static string MissingAnnotationArgumentInspection {
            get {
                return ResourceManager.GetString("MissingAnnotationArgumentInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A Rubberduck annotation is specified for a module or member, but the corresponding attribute isn&apos;t present. Module attributes and annotations need to be synchronized..
        /// </summary>
        public static string MissingAttributeInspection {
            get {
                return ResourceManager.GetString("MissingAttributeInspection", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Module and member attributes are not displayed in the VBE. By adding an annotation, you make these attributes more explicit, and Rubberduck can keep annotations and attributes synchronized..
        /// </summary>
        public static string MissingMemberAnnotationInspection
        {
            get {
                return ResourceManager.GetString("MissingMemberAnnotationInspection", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Module and member attributes are not displayed in the VBE. By adding an annotation, you make these attributes more explicit, and Rubberduck can keep annotations and attributes synchronized..
        /// </summary>
        public static string MissingModuleAnnotationInspection
        {
            get {
                return ResourceManager.GetString("MissingModuleAnnotationInspection", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to The &apos;Public&apos; keyword can only be used at module level; its counterpart &apos;Private&apos; can also only be used at module level. &apos;Dim&apos; however, can be used to declare both procedure and module scope variables. For consistency, it would be preferable to reserve &apos;Dim&apos; for locals, and thus to use &apos;Private&apos; instead of &apos;Dim&apos; at module level..
        /// </summary>
        public static string ModuleScopeDimKeywordInspection {
            get {
                return ResourceManager.GetString("ModuleScopeDimKeywordInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Modules without the &apos;@Folder&apos; annotation cannot receive custom groupings in the Code Explorer. .
        /// </summary>
        public static string ModuleWithoutFolderInspection {
            get {
                return ResourceManager.GetString("ModuleWithoutFolderInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A module-level variable used only in one procedure should be declared in that procedure..
        /// </summary>
        public static string MoveFieldCloserToUsageInspection {
            get {
                return ResourceManager.GetString("MoveFieldCloserToUsageInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider continuing long signatures between parameters. Splitting a parameter declaration across multiple lines arguably hurts readability..
        /// </summary>
        public static string MultilineParameterInspection {
            get {
                return ResourceManager.GetString("MultilineParameterInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Declaring multiple variables in the same instruction is legal, but should be used sparingly. Consider declaring variables closer to their usage, in a single instruction per declaration..
        /// </summary>
        public static string MultipleDeclarationsInspection {
            get {
                return ResourceManager.GetString("MultipleDeclarationsInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This is likely a bug. The return value of a function or property getter must be assigned before exiting, otherwise the program will not be working with expected results. If a function has no meaningful return value, consider declaring it as a &apos;Sub&apos; procedure instead..
        /// </summary>
        public static string NonReturningFunctionInspection {
            get {
                return ResourceManager.GetString("NonReturningFunctionInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to As far as Rubberduck can tell, this variable is an object variable, assigned without the &apos;Set&apos; keyword. This causes run-time error 91 &apos;Object or With block variable not set&apos;..
        /// </summary>
        public static string ObjectVariableNotSetInspection {
            get {
                return ResourceManager.GetString("ObjectVariableNotSetInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Windows implementations of Visual Basic only support the StdCall calling convention, and use of of the CDecl calling convention is only supported in Macintosh versions of VBA. Use of this keyword in Windows will result in runtime error 49 - &apos;Bad DLL calling convention&apos;. If this procedure is only intended to be used on Macintosh hosts, it should be conditionally compiled..
        /// </summary>
        public static string ObsoleteCallingConventionInspection {
            get {
                return ResourceManager.GetString("ObsoleteCallingConventionInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The &apos;Call&apos; statement is no longer required to call procedures, and only exists in the language to support legacy code that required it; it can be safely rewritten to an implicit call..
        /// </summary>
        public static string ObsoleteCallStatementInspection {
            get {
                return ResourceManager.GetString("ObsoleteCallStatementInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The &apos;Rem&apos; statement only exists in the language to support legacy code that required it; it can be safely replaced with an apostrophe / single-quote comment..
        /// </summary>
        public static string ObsoleteCommentSyntaxInspection {
            get {
                return ResourceManager.GetString("ObsoleteCommentSyntaxInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The &apos;Error&apos; statement only exists in the language to support legacy code that required it; prefer using &apos;Err.Raise&apos; instead..
        /// </summary>
        public static string ObsoleteErrorSyntaxInspection {
            get {
                return ResourceManager.GetString("ObsoleteErrorSyntaxInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The &apos;Global&apos; keyword only exists in the language to support legacy code that required it; it can be safely replaced with the &apos;Public&apos; modifier..
        /// </summary>
        public static string ObsoleteGlobalInspection {
            get {
                return ResourceManager.GetString("ObsoleteGlobalInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The &apos;Let&apos; statement only exists in the language to support legacy code that required it; it can be safely removed, since modern VBA does not require that keyword for value assignments..
        /// </summary>
        public static string ObsoleteLetStatementInspection {
            get {
                return ResourceManager.GetString("ObsoleteLetStatementInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This member is marked &apos;@Obsolete&apos;. It should no longer be used, there should be a better alternative..
        /// </summary>
        public static string ObsoleteMemberUsageInspection {
            get {
                return ResourceManager.GetString("ObsoleteMemberUsageInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type hint characters only exist in the language to support legacy code that required it; they can be safely replaced in declarations with an &quot;As&quot; type clause that specifies the type explicitly, and they can be omitted in other identifier references..
        /// </summary>
        public static string ObsoleteTypeHintInspection {
            get {
                return ResourceManager.GetString("ObsoleteTypeHintInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to On Local Error exists only for compatibility with previous versions of Visual Basic, and all Errors are treated as Local regardless of the Error statement. Use of this keyword inaccurately gives the impression that there is a distinction between types of error handling when there is not..
        /// </summary>
        public static string OnLocalErrorInspection {
            get {
                return ResourceManager.GetString("OnLocalErrorInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Arrays are typically zero-based. This option changes the default lower boundary for implicitly-sized arrays, which can introduce off-by-one errors if one isn&apos;t cautious..
        /// </summary>
        public static string OptionBaseInspection {
            get {
                return ResourceManager.GetString("OptionBaseInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This is the default setting, it does not need to be specified..
        /// </summary>
        public static string OptionBaseZeroInspection {
            get {
                return ResourceManager.GetString("OptionBaseZeroInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to VBA will happily compile a typo: use &apos;Option Explicit&apos; to prevent successfully compiling an erroneous program..
        /// </summary>
        public static string OptionExplicitInspection {
            get {
                return ResourceManager.GetString("OptionExplicitInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A parameter that is passed by reference and isn&apos;t assigned a new value/reference, could be passed by value instead..
        /// </summary>
        public static string ParameterCanBeByValInspection {
            get {
                return ResourceManager.GetString("ParameterCanBeByValInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A parameter is passed into a member that does not use it. Consider removing that parameter..
        /// </summary>
        public static string ParameterNotUsedInspection {
            get {
                return ResourceManager.GetString("ParameterNotUsedInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A procedure that only has one parameter passed by reference that is assigned a new value/reference before the procedure exits, is using a ByRef parameter as a return value: consider making it a function instead..
        /// </summary>
        public static string ProcedureCanBeWrittenAsFunctionInspection {
            get {
                return ResourceManager.GetString("ProcedureCanBeWrittenAsFunctionInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rubberduck could not find any caller for a procedure. If the procedure is hooked to a macro-button, used as a user-defined function (UDF) or handles an application event that Rubberduck didn&apos;t know of you can safely ignore this inspection result; otherwise, consider removing it..
        /// </summary>
        public static string ProcedureNotUsedInspection {
            get {
                return ResourceManager.GetString("ProcedureNotUsedInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to By default, all parameters are passed by reference, so it is not necessary to include the &apos;ByRef&apos; modifier..
        /// </summary>
        public static string RedundantByRefModifierInspection {
            get {
                return ResourceManager.GetString("RedundantByRefModifierInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Being the default/implicit setting for this option, this instruction can be safely omitted..
        /// </summary>
        public static string RedundantOptionInspection {
            get {
                return ResourceManager.GetString("RedundantOptionInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An auto-instantiated object variable declaration at procedure scope changes how nulling the reference works, which can lead to unexpected behavior..
        /// </summary>
        public static string SelfAssignedDeclarationInspection {
            get {
                return ResourceManager.GetString("SelfAssignedDeclarationInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Two declarations are in scope and have the same identifier name. This means that only one of them will be available to use..
        /// </summary>
        public static string ShadowedDeclarationInspection {
            get {
                return ResourceManager.GetString("ShadowedDeclarationInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Excel already defines a globally scoped object variable with this reference. Consider using the sheet&apos;s &apos;CodeName&apos; property..
        /// </summary>
        public static string SheetAccessedUsingStringInspection {
            get {
                return ResourceManager.GetString("SheetAccessedUsingStringInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Step of the for-next loop is not specified. This might be unintentional..
        /// </summary>
        public static string StepIsNotSpecifiedInspection {
            get {
                return ResourceManager.GetString("StepIsNotSpecifiedInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 1 is the default step in a for-next loop and therefore is redundant..
        /// </summary>
        public static string StepOneIsRedundantInspection {
            get {
                return ResourceManager.GetString("StepOneIsRedundantInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The &apos;Stop&apos; keyword halts execution and brings up the debugger. Avoid its use in distributed code..
        /// </summary>
        public static string StopKeywordInspection {
            get {
                return ResourceManager.GetString("StopKeywordInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This is likely a bug. A variable is being referred to, but is never assigned..
        /// </summary>
        public static string UnassignedVariableUsageInspection {
            get {
                return ResourceManager.GetString("UnassignedVariableUsageInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Code that uses undeclared variables does not compile when Option Explicit is specified. Undeclared variables are always Variant, a data type that incurs unnecessary overhead and storage..
        /// </summary>
        public static string UndeclaredVariableInspection {
            get {
                return ResourceManager.GetString("UndeclaredVariableInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A class module that contains members with underscores cannot be implemented by other classes. The underscore is used as a separator between the interface/object name and the implemented member name: having an underscore in the member name confuses the compiler, which then refuses to compile the project. Avoid underscores in public member names by following a &apos;PascalCase&apos; naming convention..
        /// </summary>
        public static string UnderscoreInPublicClassModuleMemberInspection {
            get {
                return ResourceManager.GetString("UnderscoreInPublicClassModuleMemberInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Error handling should be restored after using &apos;On Error Resume Next&apos;..
        /// </summary>
        public static string UnhandledOnErrorResumeNextInspection {
            get {
                return ResourceManager.GetString("UnhandledOnErrorResumeNextInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Detects Case Clauses that will never execute. .
        /// </summary>
        public static string UnreachableCaseInspection {
            get {
                return ResourceManager.GetString("UnreachableCaseInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A string-returning equivalent function exists and should preferably be used to avoid implicit type conversions. 
        ///If the parameter can be null, ignore this inspection result; passing a null value to a function expecting a string would raise a type mismatch runtime error..
        /// </summary>
        public static string UntypedFunctionUsageInspection {
            get {
                return ResourceManager.GetString("UntypedFunctionUsageInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identifier names should indicate what they&apos;re used for and should be readable; avoid disemvoweling, numeric suffixes, and 1-2 character names..
        /// </summary>
        public static string UseMeaningfulNameInspection {
            get {
                return ResourceManager.GetString("UseMeaningfulNameInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Variable is not assigned. If this isn&apos;t intended, there&apos;s probably a bug. Ignore this inspection result if the variable is assigned in another procedure via a ByRef parameter..
        /// </summary>
        public static string VariableNotAssignedInspection {
            get {
                return ResourceManager.GetString("VariableNotAssignedInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Variable is not referred to.
        /// </summary>
        public static string VariableNotUsedInspection {
            get {
                return ResourceManager.GetString("VariableNotUsedInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A variable whose type isn&apos;t explicitly declared, is implicitly &apos;Variant&apos;. Consider making it an explicit &apos;Variant&apos; if that&apos;s intended, or declare a more specific type..
        /// </summary>
        public static string VariableTypeNotDeclaredInspection {
            get {
                return ResourceManager.GetString("VariableTypeNotDeclaredInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A property that exposes a mutator but no accessor is a design smell and makes a confusing API. Consider exposing a getter, or converting the mutator to a method..
        /// </summary>
        public static string WriteOnlyPropertyInspection {
            get {
                return ResourceManager.GetString("WriteOnlyPropertyInspection", resourceCulture);
            }
        }
    }
}
