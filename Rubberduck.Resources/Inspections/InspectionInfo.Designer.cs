//------------------------------------------------------------------------------
// <auto-generated>
//     Il codice è stato generato da uno strumento.
//     Versione runtime:4.0.30319.42000
//
//     Le modifiche apportate a questo file possono provocare un comportamento non corretto e andranno perse se
//     il codice viene rigenerato.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Rubberduck.Resources.Inspections {
    using System;
    
    
    /// <summary>
    ///   Classe di risorse fortemente tipizzata per la ricerca di stringhe localizzate e così via.
    /// </summary>
    // Questa classe è stata generata automaticamente dalla classe StronglyTypedResourceBuilder.
    // tramite uno strumento quale ResGen o Visual Studio.
    // Per aggiungere o rimuovere un membro, modificare il file con estensione ResX ed eseguire nuovamente ResGen
    // con l'opzione /str oppure ricompilare il progetto VS.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public class InspectionInfo {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal InspectionInfo() {
        }
        
        /// <summary>
        ///   Restituisce l'istanza di ResourceManager nella cache utilizzata da questa classe.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Rubberduck.Resources.Inspections.InspectionInfo", typeof(InspectionInfo).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Esegue l'override della proprietà CurrentUICulture del thread corrente per tutte le
        ///   ricerche di risorse eseguite utilizzando questa classe di risorse fortemente tipizzata.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a An annotation was specified in a module of a type that isn&apos;t compatible with that annotation. Some annotations can only be used in a module of a specific type; others cannot be used in modules of certain types..
        /// </summary>
        public static string AnnotationInIncompatibleComponentTypeInspection {
            get {
                return ResourceManager.GetString("AnnotationInIncompatibleComponentTypeInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a The Excel Application object does not implement the WorksheetFunction interface directly. All calls made to WorksheetFunction members are handled as late bound and errors in the called member will be returned wrapped in a Variant of VbVarType.vbError. This makes errors un-trappable with error handlers and adds a performance penalty in comparison to early bound calls. Consider calling Application.WorksheetFunction explicitly. Note: If this call generated errors in the past, those errors were ignored. If appl [stringa troncata]&quot;;.
        /// </summary>
        public static string ApplicationWorksheetFunctionInspection {
            get {
                return ResourceManager.GetString("ApplicationWorksheetFunctionInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a The VBA compiler does not raise an error if an object is passed as an argument for a parameter with an incompatible declared object type, i.e. with an object type that is neither the same type, a supertype nor a subtype. Under almost all circumstances passing such an argument leads to a run-time error, which is harder to detect and indicates a bug. In all other situations the code can be changed to only pass arguments of compatible declared types..
        /// </summary>
        public static string ArgumentWithIncompatibleObjectTypeInspection {
            get {
                return ResourceManager.GetString("ArgumentWithIncompatibleObjectTypeInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Parameter is passed by value, but is assigned a new value/reference. Consider making a local copy instead if the caller isn&apos;t supposed to know the new value. If the caller should see the new value, the parameter should be passed ByRef instead, and you have a bug..
        /// </summary>
        public static string AssignedByValParameterInspection {
            get {
                return ResourceManager.GetString("AssignedByValParameterInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a An assignment is immediately overridden by another assignment or is never referenced..
        /// </summary>
        public static string AssignmentNotUsedInspection {
            get {
                return ResourceManager.GetString("AssignmentNotUsedInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a A Rubberduck annotation is specified for a module or member, but the corresponding attribute has a different value. Module attributes and annotations need to be synchronized..
        /// </summary>
        public static string AttributeValueOutOfSyncInspection {
            get {
                return ResourceManager.GetString("AttributeValueOutOfSyncInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a A member is assigned True/False in different branches of an if statement with no other statements in the conditional. Use the condition directly to the member instead..
        /// </summary>
        public static string BooleanAssignedInIfElseInspection {
            get {
                return ResourceManager.GetString("BooleanAssignedInIfElseInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Rubberduck could not find any reference to constant. Consider removing the unused declaration..
        /// </summary>
        public static string ConstantNotUsedInspection {
            get {
                return ResourceManager.GetString("ConstantNotUsedInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a The VBA compiler does not raise an error if an indexed default member call is required but the object&apos;s declared type does not have a suitable default member. Under almost all circumstances, this leads to a run-time error 91 &apos;Object or With block variable not set&apos; or 438 &apos;Object doesn&apos;t support this property or method&apos; depending on whether the object has the value &apos;Nothing&apos; or not, which is harder to detect and indicates a bug..
        /// </summary>
        public static string DefaultMemberRequiredInspection {
            get {
                return ResourceManager.GetString("DefaultMemberRequiredInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Consider naming your VBA project..
        /// </summary>
        public static string DefaultProjectNameInspection {
            get {
                return ResourceManager.GetString("DefaultProjectNameInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Using the &apos;Def[Type]&apos; statement leads to specifying types by using a prefix. This style of naming is heavily discouraged and should be avoided..
        /// </summary>
        public static string DefTypeStatementInspection {
            get {
                return ResourceManager.GetString("DefTypeStatementInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a An annotation is specified multiple times, but is intended to be specified only once..
        /// </summary>
        public static string DuplicatedAnnotationInspection {
            get {
                return ResourceManager.GetString("DuplicatedAnnotationInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a An empty &apos;Case&apos; block without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn&apos;t need to be written..
        /// </summary>
        public static string EmptyCaseBlockInspection {
            get {
                return ResourceManager.GetString("EmptyCaseBlockInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a An empty &apos;Do...While&apos; loop without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn&apos;t need to be written..
        /// </summary>
        public static string EmptyDoWhileBlockInspection {
            get {
                return ResourceManager.GetString("EmptyDoWhileBlockInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a An empty &apos;Else&apos; loop without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn&apos;t need to be written..
        /// </summary>
        public static string EmptyElseBlockInspection {
            get {
                return ResourceManager.GetString("EmptyElseBlockInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a An empty &apos;For Each...Next&apos; loop without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn&apos;t need to be written..
        /// </summary>
        public static string EmptyForEachBlockInspection {
            get {
                return ResourceManager.GetString("EmptyForEachBlockInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a An empty &apos;For...Next&apos; loop without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn&apos;t need to be written..
        /// </summary>
        public static string EmptyForLoopBlockInspection {
            get {
                return ResourceManager.GetString("EmptyForLoopBlockInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a An empty conditional branch without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn&apos;t need to be written..
        /// </summary>
        public static string EmptyIfBlockInspection {
            get {
                return ResourceManager.GetString("EmptyIfBlockInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Methods without executable statements may appear to be doing something which they actually don&apos;t, and therefore causing unexpected behaviour..
        /// </summary>
        public static string EmptyMethodInspection {
            get {
                return ResourceManager.GetString("EmptyMethodInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Empty modules and classes either point to not yet implemented functionality or represent unnecessary baggage that can hurt the maintainability of a project..
        /// </summary>
        public static string EmptyModuleInspection {
            get {
                return ResourceManager.GetString("EmptyModuleInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a The built-in constant &apos;vbNullString&apos; is a null string pointer taking up 0 bytes of memory, that unambiguously conveys the intent of an empty string..
        /// </summary>
        public static string EmptyStringLiteralInspection {
            get {
                return ResourceManager.GetString("EmptyStringLiteralInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a An empty &apos;Loop&apos; block without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn&apos;t need to be written..
        /// </summary>
        public static string EmptyWhileWendBlockInspection {
            get {
                return ResourceManager.GetString("EmptyWhileWendBlockInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Consider exposing a property instead..
        /// </summary>
        public static string EncapsulatePublicFieldInspection {
            get {
                return ResourceManager.GetString("EncapsulatePublicFieldInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a A procedure that returns an object may return &apos;Nothing&apos;. That will cause a runtime error 91 - &quot;Object variable or With block variable not set&quot; on subsequent member access. Perform an &apos;Is Nothing&apos; check after the &apos;Set&apos; assignment to guard against runtime errors..
        /// </summary>
        public static string ExcelMemberMayReturnNothingInspection {
            get {
                return ResourceManager.GetString("ExcelMemberMayReturnNothingInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Functions that are visible to Excel as User-Defined Functions will return a &apos;#REF!&apos; error when used on a Worksheet if they match the name of a valid cell reference. If the function is intended to be used as a UDF, it must be renamed. If the function is not intended to be used as a UDF, it should be scoped as &apos;Private&apos; or moved out of a standard Module..
        /// </summary>
        public static string ExcelUdfNameIsValidCellReferenceInspection {
            get {
                return ResourceManager.GetString("ExcelUdfNameIsValidCellReferenceInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a A member is written as a function, but always used as a procedure. Consider converting the &apos;Function&apos; into a &apos;Sub&apos;..
        /// </summary>
        public static string FunctionReturnValueAlwaysDiscardedInspection {
            get {
                return ResourceManager.GetString("FunctionReturnValueAlwaysDiscardedInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a The return value of a function gets discarded, i.e. the function is used like a &apos;Sub&apos; procedure. This is either an oversight or the function is used for its side-effects, whose existence would also be a code smell..
        /// </summary>
        public static string FunctionReturnValueDiscardedInspection {
            get {
                return ResourceManager.GetString("FunctionReturnValueDiscardedInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Bracketed expressions are evaluated by the host application at runtime, which means VBA can&apos;t validate the expression at compile-time. Consider using the host application&apos;s object model instead..
        /// </summary>
        public static string HostSpecificExpressionInspection {
            get {
                return ResourceManager.GetString("HostSpecificExpressionInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Hungarian notation makes code less readable, and is redundant when strongly typed variables and meaningful names are used..
        /// </summary>
        public static string HungarianNotationInspection {
            get {
                return ResourceManager.GetString("HungarianNotationInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a All arguments of any function/procedure call are always evaluated before the function is invoked so that their respective values can be passed as parameters. Even so, the IIf Function&apos;s behavior is sometimes mis-interpreted to expect that ONLY the &apos;TruePart&apos; or ONLY the &apos;FalsePart&apos; expression will be evaluated based on the result of the first argument expression. Consequently, the IIf Function can be a source of unanticipated side-effects and errors if the user does not account for the fact that both the Tr [stringa troncata]&quot;;.
        /// </summary>
        public static string IIfSideEffectInspection {
            get {
                return ResourceManager.GetString("IIfSideEffectInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a A class module that is meant to be used as interface for concrete classes should generally be abstracted of any implementations. If it is your intention to use this class module as a concrete type, you can safely ignore this inspection result..
        /// </summary>
        public static string ImplementedInterfaceMemberInspection {
            get {
                return ResourceManager.GetString("ImplementedInterfaceMemberInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Implicit references to the active sheet make the code frail and harder to debug. Consider making these references explicit when they&apos;re intended, and prefer working off object references. Ignore if the member call is referring to a type Rubberduck can&apos;t resolve..
        /// </summary>
        public static string ImplicitActiveSheetReferenceInspection {
            get {
                return ResourceManager.GetString("ImplicitActiveSheetReferenceInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Implicit references to the active workbook make the code frail and harder to debug. Consider making these references explicit when they&apos;re intended, and prefer working off object references. Ignore if the member call is referring to a type Rubberduck can&apos;t resolve..
        /// </summary>
        public static string ImplicitActiveWorkbookReferenceInspection {
            get {
                return ResourceManager.GetString("ImplicitActiveWorkbookReferenceInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Parameters are passed by reference unless specified otherwise, which can be confusing and bug-prone. Prefer passing parameters by value, and specify ByRef explicitly when passing parameters by reference..
        /// </summary>
        public static string ImplicitByRefModifierInspection {
            get {
                return ResourceManager.GetString("ImplicitByRefModifierInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Implicit references to workbook members inside a workbook document module can be mistaken for implicit references to the active workbook, which is the behavior in all other modules. By explicitly qualifying these member calls with &apos;Me&apos;, the ambiguity can be resolved. If the intent was to refer to the active workbook, qualify with &apos;ActiveWorkbook&apos; to prevent a bug..
        /// </summary>
        public static string ImplicitContainingWorkbookReferenceInspection {
            get {
                return ResourceManager.GetString("ImplicitContainingWorkbookReferenceInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Implicit references to worksheet members inside a worksheet document module can be mistaken for implicit references to the active worksheet, which is the behavior in all other modules. By explicitly qualifying these member calls with &apos;Me&apos;, the ambiguity can be resolved. If the intent is to refer to the active worksheet, qualify with &apos;ActiveSheet&apos; to prevent a bug..
        /// </summary>
        public static string ImplicitContainingWorksheetReferenceInspection {
            get {
                return ResourceManager.GetString("ImplicitContainingWorksheetReferenceInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Default member accesses hide away the actually called member. This is especially misleading if there is no indication in the expression that such a call is made. It can cause errors in which a member was forgotten to be called to go unnoticed..
        /// </summary>
        public static string ImplicitDefaultMemberAccessInspection {
            get {
                return ResourceManager.GetString("ImplicitDefaultMemberAccessInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a If the &apos;As&apos; type clause for a &apos;Const&apos; declaration isn&apos;t included it is implicitly typed. Include an explicit &apos; As &lt;Type&gt;&apos; replacing &apos;&lt;Type&gt;&apos; with the correct data type to explicitly type your constant value..
        /// </summary>
        public static string ImplicitlyTypedConstInspection {
            get {
                return ResourceManager.GetString("ImplicitlyTypedConstInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Module members are public by default, which can be counter-intuitive. Consider specifying explicit access modifiers to avoid ambiguity..
        /// </summary>
        public static string ImplicitPublicMemberInspection {
            get {
                return ResourceManager.GetString("ImplicitPublicMemberInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Default member accesses hide away the actually called member. This is especially misleading if there is no indication in the expression that such a call is made and the final default member is not on the interface of the object itself. In particular, this can cause errors in which a member was forgotten to be called to go unnoticed..
        /// </summary>
        public static string ImplicitRecursiveDefaultMemberAccessInspection {
            get {
                return ResourceManager.GetString("ImplicitRecursiveDefaultMemberAccessInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Default member accesses hide away the actually called member. This is especially misleading if there is no indication in the expression that such a call is made and if the default member cannot be determined from the declared type of the object. As a consequence, errors in which a member was forgotten to be called can go unnoticed and should there not be a suitable default member at runtime, an error 438 &apos;Object doesn&apos;t support this property or method&apos; will be raised..
        /// </summary>
        public static string ImplicitUnboundDefaultMemberAccessInspection {
            get {
                return ResourceManager.GetString("ImplicitUnboundDefaultMemberAccessInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Members with a return value implicitly return a &apos;Variant&apos; unless specified otherwise. Consider returning an explicit &apos;Variant&apos; when the return type isn&apos;t known, or specify it explicitly..
        /// </summary>
        public static string ImplicitVariantReturnTypeInspection {
            get {
                return ResourceManager.GetString("ImplicitVariantReturnTypeInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a A default member access hides away which member is actually called. Although it is apparent that some call is made in the case of an indexed default member access being explicit is usually better for readability..
        /// </summary>
        public static string IndexedDefaultMemberAccessInspection {
            get {
                return ResourceManager.GetString("IndexedDefaultMemberAccessInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a A default member access hides away which member is actually called. Although it is apparent that some call is made in the case of an indexed default member access being explicit is usually better for readability. This especially holds if the accessed default member is not on the interface of the object itself but has to be resolved via a chain of default member calls..
        /// </summary>
        public static string IndexedRecursiveDefaultMemberAccessInspection {
            get {
                return ResourceManager.GetString("IndexedRecursiveDefaultMemberAccessInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a A default member access hides away which member is actually called. Although it is apparent that some call is made in the case of an indexed default member access being explicit is usually better for readability. This is especially true if the default member cannot be determined at compile time. In addition, should there not be a suitable default member at runtime, an error 438 &apos;Object doesn&apos;t support this property or method&apos; will be raised..
        /// </summary>
        public static string IndexedUnboundDefaultMemberAccessInspection {
            get {
                return ResourceManager.GetString("IndexedUnboundDefaultMemberAccessInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a The maximum value of a 16-bit signed integer is 32,767 - using a 32-bit (Long) integer data type where possible can help prevent &apos;Overflow&apos; run-time errors, and is better handled by modern CPUs..
        /// </summary>
        public static string IntegerDataTypeInspection {
            get {
                return ResourceManager.GetString("IntegerDataTypeInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a The annotation could not be bound to a target. Is the annotation misplaced? An annotation meant to be specified at module level cannot be used to annotate members; conversely, annotations meant to be annotate members cannot be used at module level..
        /// </summary>
        public static string InvalidAnnotationInspection {
            get {
                return ResourceManager.GetString("InvalidAnnotationInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a IsMissing is only intended to be called on optional arguments, and will only return correct results if the type of the argument is &apos;Variant&apos; with no explicit default value. All other uses will return &apos;False&apos;..
        /// </summary>
        public static string IsMissingOnInappropriateArgumentInspection {
            get {
                return ResourceManager.GetString("IsMissingOnInappropriateArgumentInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a IsMissing is only intended to be called on arguments of the containing procedure, and almost all other usages will return &apos;False&apos;. Passing any other expression to the function is the equivalent to &apos;VarType({expression}) = vbError&apos;, and in rare circumstances can cause the host application to crash..
        /// </summary>
        public static string IsMissingWithNonArgumentParameterInspection {
            get {
                return ResourceManager.GetString("IsMissingWithNonArgumentParameterInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a A keyword is being used as a member in either an enumeration or an user defined type. That can lead to ambiguous resolution. Consider renaming the member..
        /// </summary>
        public static string KeywordsUsedAsMemberInspection {
            get {
                return ResourceManager.GetString("KeywordsUsedAsMemberInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a There are line continuations between keywords. There is no good reason to put it there; consider removing them altogether..
        /// </summary>
        public static string LineContinuationBetweenKeywordsInspection {
            get {
                return ResourceManager.GetString("LineContinuationBetweenKeywordsInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a A line label that is never jumpted to (&apos;GoTo&apos;, &apos;Resume&apos;, ...), serves no purpose. Consider removing it..
        /// </summary>
        public static string LineLabelNotUsedInspection {
            get {
                return ResourceManager.GetString("LineLabelNotUsedInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a A member access call is made against an extended interface that Rubberduck couldn&apos;t resolve, or the member couldn&apos;t be found. If VBA cannot resolve the type at run-time, error 438 will be raised. If an equivalent, non-extended interface that Rubberduck can resolve is available, consider using it instead..
        /// </summary>
        public static string MemberNotOnInterfaceInspection {
            get {
                return ResourceManager.GetString("MemberNotOnInterfaceInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a The last parameter (the &apos;Value&apos; parameter) of property mutators (Let/Set) are always passed ByVal. This is true regardless of the presence or absence of a ByRef or ByVal modifier. Exception: A UserDefinedType must always be passed ByRef even when it is the last parameter of a property mutator..
        /// </summary>
        public static string MisleadingByRefParameterInspection {
            get {
                return ResourceManager.GetString("MisleadingByRefParameterInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a An annotation parameter is missing or incorrectly specified. The correct syntax is : &apos;@Annotation([parameter])\nExample: &apos;@Folder(&quot;Parent.Child&quot;).
        /// </summary>
        public static string MissingAnnotationArgumentInspection {
            get {
                return ResourceManager.GetString("MissingAnnotationArgumentInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a A Rubberduck annotation is specified for a module or member, but the corresponding attribute isn&apos;t present. Module attributes and annotations need to be synchronized..
        /// </summary>
        public static string MissingAttributeInspection {
            get {
                return ResourceManager.GetString("MissingAttributeInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Member attributes are not displayed in the VBE. By adding an annotation, you make these attributes more explicit, and Rubberduck can keep annotations and attributes synchronized..
        /// </summary>
        public static string MissingMemberAnnotationInspection {
            get {
                return ResourceManager.GetString("MissingMemberAnnotationInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Module attributes are not displayed in the VBE. By adding an annotation, you make these attributes more explicit, and Rubberduck can keep annotations and attributes synchronized..
        /// </summary>
        public static string MissingModuleAnnotationInspection {
            get {
                return ResourceManager.GetString("MissingModuleAnnotationInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a The &apos;Public&apos; keyword can only be used at module level; its counterpart &apos;Private&apos; can also only be used at module level. &apos;Dim&apos; however, can be used to declare both procedure and module scope variables. For consistency, it would be preferable to reserve &apos;Dim&apos; for locals, and thus to use &apos;Private&apos; instead of &apos;Dim&apos; at module level..
        /// </summary>
        public static string ModuleScopeDimKeywordInspection {
            get {
                return ResourceManager.GetString("ModuleScopeDimKeywordInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Modules without the &apos;@Folder&apos; annotation cannot receive custom groupings in the Code Explorer..
        /// </summary>
        public static string ModuleWithoutFolderInspection {
            get {
                return ResourceManager.GetString("ModuleWithoutFolderInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a A module-level variable used only in one procedure should be declared in that procedure..
        /// </summary>
        public static string MoveFieldCloserToUsageInspection {
            get {
                return ResourceManager.GetString("MoveFieldCloserToUsageInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Consider continuing long signatures between parameters. Splitting a parameter declaration across multiple lines arguably hurts readability..
        /// </summary>
        public static string MultilineParameterInspection {
            get {
                return ResourceManager.GetString("MultilineParameterInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Declaring multiple variables in the same instruction is legal, but should be used sparingly. Consider declaring variables closer to their usage, in a single instruction per declaration..
        /// </summary>
        public static string MultipleDeclarationsInspection {
            get {
                return ResourceManager.GetString("MultipleDeclarationsInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Negative line numbers are actually input as hex literal and then prettified by VBE. Editing the line again will cause it to turn red since negative line numbers are in fact illegal..
        /// </summary>
        public static string NegativeLineNumberInspection {
            get {
                return ResourceManager.GetString("NegativeLineNumberInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a The identifier contains a non-breaking space which looks very much like just an ordinary space (illegal in an identifier name), which obfuscates the code and makes for a confusing experience. Consider using visible characters for the identifiers..
        /// </summary>
        public static string NonBreakingSpaceIdentifierInspection {
            get {
                return ResourceManager.GetString("NonBreakingSpaceIdentifierInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a This is likely a bug. The return value of a function or property getter must be assigned before exiting, otherwise the program will not be working with expected results. If a function has no meaningful return value, consider declaring it as a &apos;Sub&apos; procedure instead..
        /// </summary>
        public static string NonReturningFunctionInspection {
            get {
                return ResourceManager.GetString("NonReturningFunctionInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a As far as Rubberduck can tell, this variable is an object variable, assigned without the &apos;Set&apos; keyword. This causes run-time error 91 &apos;Object or With block variable not set&apos; or 438 &apos;Object doesn&apos;t support this property or method&apos; depending on whether the variable has the value &apos;Nothing&apos; or not..
        /// </summary>
        public static string ObjectVariableNotSetInspection {
            get {
                return ResourceManager.GetString("ObjectVariableNotSetInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Using an object with a default member in a place that requires a procedure leads to an implicit invocation of the default member. This is most likely unintentional and negatively affects readability..
        /// </summary>
        public static string ObjectWhereProcedureIsRequiredInspection {
            get {
                return ResourceManager.GetString("ObjectWhereProcedureIsRequiredInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Windows implementations of Visual Basic only support the StdCall calling convention. The CDecl calling convention is only supported in Macintosh versions of VBA. Use of this keyword in Windows will result in runtime error 49 - &apos;Bad DLL calling convention&apos;. If this procedure is only intended to be used on Macintosh hosts, it should be conditionally compiled..
        /// </summary>
        public static string ObsoleteCallingConventionInspection {
            get {
                return ResourceManager.GetString("ObsoleteCallingConventionInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a The &apos;Call&apos; statement is no longer required to call procedures, and only exists in the language to support legacy code that required it; it can be safely rewritten to an implicit call..
        /// </summary>
        public static string ObsoleteCallStatementInspection {
            get {
                return ResourceManager.GetString("ObsoleteCallStatementInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a The &apos;Rem&apos; statement only exists in the language to support legacy code that required it; it can be safely replaced with an apostrophe / single-quote comment..
        /// </summary>
        public static string ObsoleteCommentSyntaxInspection {
            get {
                return ResourceManager.GetString("ObsoleteCommentSyntaxInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a The &apos;Error&apos; statement only exists in the language to support legacy code that required it; prefer using &apos;Err.Raise&apos; instead..
        /// </summary>
        public static string ObsoleteErrorSyntaxInspection {
            get {
                return ResourceManager.GetString("ObsoleteErrorSyntaxInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a The &apos;Global&apos; keyword only exists in the language to support legacy code that required it; it can be safely replaced with the &apos;Public&apos; modifier..
        /// </summary>
        public static string ObsoleteGlobalInspection {
            get {
                return ResourceManager.GetString("ObsoleteGlobalInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a The &apos;Let&apos; statement only exists in the language to support legacy code that required it; it can be safely removed, since modern VBA does not require that keyword for value assignments..
        /// </summary>
        public static string ObsoleteLetStatementInspection {
            get {
                return ResourceManager.GetString("ObsoleteLetStatementInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a This member is marked &apos;@Obsolete&apos;. It should no longer be used, there should be a better alternative..
        /// </summary>
        public static string ObsoleteMemberUsageInspection {
            get {
                return ResourceManager.GetString("ObsoleteMemberUsageInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Type hint characters only exist in the language to support legacy code that required it; they can be safely replaced in declarations with an &quot;As&quot; type clause that specifies the type explicitly, and they can be omitted in other identifier references..
        /// </summary>
        public static string ObsoleteTypeHintInspection {
            get {
                return ResourceManager.GetString("ObsoleteTypeHintInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a &apos;While...Wend&apos; loops exist for backward compatibility and have been superseded by the introduction of &apos;Do While...Loop&apos; blocks, which support the &apos;Exit Do&apos; exit statement. &apos;While...Wend&apos; loops cannot be exited other than fulfilling the &apos;While&apos; condition..
        /// </summary>
        public static string ObsoleteWhileWendStatementInspection {
            get {
                return ResourceManager.GetString("ObsoleteWhileWendStatementInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a While this is legal, this is poorly documented &quot;feature&quot; that means something different -- the error state is also cleared in addition to disabling any error handling. However, this can be ambiguous as a negative line label of -1 may end up as a target and excessively complex error handling usually indicates a need of refactoring the procedure..
        /// </summary>
        public static string OnErrorGoToMinusOneInspection {
            get {
                return ResourceManager.GetString("OnErrorGoToMinusOneInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a On Local Error exists only for compatibility with previous versions of Visual Basic, and all Errors are treated as Local regardless of the On Local Error statement. Use of this keyword inaccurately gives the impression that there is a distinction between types of error handling when there is not..
        /// </summary>
        public static string OnLocalErrorInspection {
            get {
                return ResourceManager.GetString("OnLocalErrorInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Arrays are typically zero-based. This option changes the default lower boundary for implicitly-sized arrays, which can introduce off-by-one errors if one isn&apos;t cautious..
        /// </summary>
        public static string OptionBaseInspection {
            get {
                return ResourceManager.GetString("OptionBaseInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a This is the default setting, it does not need to be specified..
        /// </summary>
        public static string OptionBaseZeroInspection {
            get {
                return ResourceManager.GetString("OptionBaseZeroInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a VBA will happily compile a typo: use &apos;Option Explicit&apos; to prevent successfully compiling an erroneous program..
        /// </summary>
        public static string OptionExplicitInspection {
            get {
                return ResourceManager.GetString("OptionExplicitInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a A parameter that is passed by reference and isn&apos;t assigned a new value/reference, could be passed by value instead..
        /// </summary>
        public static string ParameterCanBeByValInspection {
            get {
                return ResourceManager.GetString("ParameterCanBeByValInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a A parameter is passed into a member that does not use it. Consider removing that parameter..
        /// </summary>
        public static string ParameterNotUsedInspection {
            get {
                return ResourceManager.GetString("ParameterNotUsedInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a A procedure that only has one parameter passed by reference that is assigned a new value/reference before the procedure exits, is using a ByRef parameter as a return value: consider making it a function instead..
        /// </summary>
        public static string ProcedureCanBeWrittenAsFunctionInspection {
            get {
                return ResourceManager.GetString("ProcedureCanBeWrittenAsFunctionInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Rubberduck could not find any caller for a procedure. If the procedure is hooked to a macro-button, used as a user-defined function (UDF) or handles an application event that Rubberduck didn&apos;t know of you can safely ignore this inspection result; otherwise, consider removing it..
        /// </summary>
        public static string ProcedureNotUsedInspection {
            get {
                return ResourceManager.GetString("ProcedureNotUsedInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a The VBA compiler does not raise an error if an object variable is used in a place that requires a procedure and the object&apos;s declared type does not have a suitable default member. Under almost all circumstances, this leads to a run-time error 91 &apos;Object or With block variable not set&apos; or 438 &apos;Object doesn&apos;t support this property or method&apos; depending on whether the object has the value &apos;Nothing&apos; or not, which is harder to detect and indicates a bug..
        /// </summary>
        public static string ProcedureRequiredInspection {
            get {
                return ResourceManager.GetString("ProcedureRequiredInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a MSForms exposes UserForm controls as public fields; accessing these fields outside the UserForm class breaks encapsulation and needlessly couples code with specific form controls. Consider encapsulating the desired values into their own &apos;model&apos; class, making event handlers in the form manipulate these &apos;model&apos; properties, and then the calling code can query this encapsulated state instead of querying form controls..
        /// </summary>
        public static string PublicControlFieldAccessInspection {
            get {
                return ResourceManager.GetString("PublicControlFieldAccessInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a In general, the VBE editor catches this type of error and will not compile.  However, there are a few scenarios where the error is overlooked by the compiler and an error is generated at runtime.  To avoid a runtime error, implement the missing Property or Subroutine. .
        /// </summary>
        public static string ReadOnlyPropertyAssignmentInspection {
            get {
                return ResourceManager.GetString("ReadOnlyPropertyAssignmentInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a By default, all parameters are passed by reference, so it is not necessary to include the &apos;ByRef&apos; modifier..
        /// </summary>
        public static string RedundantByRefModifierInspection {
            get {
                return ResourceManager.GetString("RedundantByRefModifierInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Being the default/implicit setting for this option, this instruction can be safely omitted..
        /// </summary>
        public static string RedundantOptionInspection {
            get {
                return ResourceManager.GetString("RedundantOptionInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a An auto-instantiated object variable declaration at procedure scope changes how nulling the reference works, which can lead to unexpected behavior..
        /// </summary>
        public static string SelfAssignedDeclarationInspection {
            get {
                return ResourceManager.GetString("SelfAssignedDeclarationInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a The VBA compiler does not raise an error if an object is set assigned to a variable with an incompatible declared object type, i.e. with an object type that is neither the same type, a supertype nor a subtype. Under almost all circumstances such an assignment leads to a run-time error, which is harder to detect and indicates a bug. In all other situations the code can be changed to use only assignments between compatible declared types..
        /// </summary>
        public static string SetAssignmentWithIncompatibleObjectTypeInspection {
            get {
                return ResourceManager.GetString("SetAssignmentWithIncompatibleObjectTypeInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Two declarations are in scope and have the same identifier name. Consider using fully qualified identifier names, otherwise only one of them will be available to use..
        /// </summary>
        public static string ShadowedDeclarationInspection {
            get {
                return ResourceManager.GetString("ShadowedDeclarationInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Excel already defines a globally scoped object variable with this reference. Consider using the sheet&apos;s &apos;CodeName&apos; property..
        /// </summary>
        public static string SheetAccessedUsingStringInspection {
            get {
                return ResourceManager.GetString("SheetAccessedUsingStringInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Step of the for-next loop is not specified. This might be unintentional..
        /// </summary>
        public static string StepIsNotSpecifiedInspection {
            get {
                return ResourceManager.GetString("StepIsNotSpecifiedInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a 1 is the default step in a for-next loop and therefore is redundant..
        /// </summary>
        public static string StepOneIsRedundantInspection {
            get {
                return ResourceManager.GetString("StepOneIsRedundantInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a The &apos;Stop&apos; keyword halts execution and brings up the debugger. Avoid its use in distributed code..
        /// </summary>
        public static string StopKeywordInspection {
            get {
                return ResourceManager.GetString("StopKeywordInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a An annotation has more arguments than allowed; superfluous arguments are ignored..
        /// </summary>
        public static string SuperfluousAnnotationArgumentInspection {
            get {
                return ResourceManager.GetString("SuperfluousAnnotationArgumentInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Whenever both sides of an assignment without Set are objects, there is an assignment from the default member of the RHS to the one on the LHS. Although this might be intentional, in many situations it will just mask an erroneously forgotten Set..
        /// </summary>
        public static string SuspiciousLetAssignmentInspection {
            get {
                return ResourceManager.GetString("SuspiciousLetAssignmentInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a While a stateful default instance might be intentional, it is a common source of bugs and should be avoided. Use the &apos;Me&apos; qualifier to explicitly refer to the current instance and eliminate any ambiguity..
        /// </summary>
        public static string SuspiciousPredeclaredInstanceAccessInspection {
            get {
                return ResourceManager.GetString("SuspiciousPredeclaredInstanceAccessInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a This is likely a bug. A variable is being referred to, but is never assigned..
        /// </summary>
        public static string UnassignedVariableUsageInspection {
            get {
                return ResourceManager.GetString("UnassignedVariableUsageInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Code that uses undeclared variables does not compile when Option Explicit is specified. Undeclared variables are always Variant, a data type that incurs unnecessary overhead and storage..
        /// </summary>
        public static string UndeclaredVariableInspection {
            get {
                return ResourceManager.GetString("UndeclaredVariableInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a A class module that contains members with underscores cannot be implemented by other classes. The underscore is used as a separator between the interface/object name and the implemented member name: having an underscore in the member name confuses the compiler, which then refuses to compile the project. Avoid underscores in public member names by following a &apos;PascalCase&apos; naming convention..
        /// </summary>
        public static string UnderscoreInPublicClassModuleMemberInspection {
            get {
                return ResourceManager.GetString("UnderscoreInPublicClassModuleMemberInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Error handling should be restored after using &apos;On Error Resume Next&apos;..
        /// </summary>
        public static string UnhandledOnErrorResumeNextInspection {
            get {
                return ResourceManager.GetString("UnhandledOnErrorResumeNextInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a A &apos;Case&apos; condition either always evaluates to False, causes a run-time error, or the cumulative effect of prior &apos;Case&apos; statements represents all possible values or a superset of the &apos;Case&apos; statement&apos;s values.  As a result, the &apos;Case&apos; block will never execute and is &quot;dead code&quot;, or the &apos;Case&apos; statement is a run-time error waiting to happen. Consider removing, reordering, or modifying the &apos;Case&apos; statement..
        /// </summary>
        public static string UnreachableCaseInspection {
            get {
                return ResourceManager.GetString("UnreachableCaseInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a A comment was parsed as a syntactically valid annotation, but not recognized as a supported annotation type..
        /// </summary>
        public static string UnrecognizedAnnotationInspection {
            get {
                return ResourceManager.GetString("UnrecognizedAnnotationInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a A string-returning equivalent function exists and should preferably be used to avoid implicit type conversions. 
        ///If the parameter can be null, ignore this inspection result; passing a null value to a function expecting a string would raise a type mismatch runtime error..
        /// </summary>
        public static string UntypedFunctionUsageInspection {
            get {
                return ResourceManager.GetString("UntypedFunctionUsageInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Identifier names should indicate what they&apos;re used for and should be readable; avoid disemvoweling, numeric suffixes, and 1-2 character names..
        /// </summary>
        public static string UseMeaningfulNameInspection {
            get {
                return ResourceManager.GetString("UseMeaningfulNameInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Bang notation, formally known as dictionary access expression, looks like it is strongly typed. However, it is actually a stringly-typed access to the parameterized default member of the object it is used on..
        /// </summary>
        public static string UseOfBangNotationInspection {
            get {
                return ResourceManager.GetString("UseOfBangNotationInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Bang notation, formally known as dictionary access expression, looks like it is strongly typed. However, it is actually a stringly-typed access to the parameterized default member of the object it is used on. This is especially misleading if the parameterized default member is not on the object itself and can only be reached by calling the parameterless default member first..
        /// </summary>
        public static string UseOfRecursiveBangNotationInspection {
            get {
                return ResourceManager.GetString("UseOfRecursiveBangNotationInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Bang notation, formally known as dictionary access expression, looks like it is strongly typed. However, it is actually a stringly-typed access to the parameterized default member of the object it is used on. This is especially misleading the default member cannot be determined at compile time..
        /// </summary>
        public static string UseOfUnboundBangNotationInspection {
            get {
                return ResourceManager.GetString("UseOfUnboundBangNotationInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a The VBA compiler does not raise an error if an object is used in a place that requires a value type and the object&apos;s declared type does not have a suitable default member. Under almost all circumstances, this leads to a run-time error 91 &apos;Object or With block variable not set&apos; or 438 &apos;Object doesn&apos;t support this property or method&apos; depending on whether the object has the value &apos;Nothing&apos; or not, which is harder to detect and indicates a bug..
        /// </summary>
        public static string ValueRequiredInspection {
            get {
                return ResourceManager.GetString("ValueRequiredInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Variable is not assigned. If this isn&apos;t intended, there&apos;s probably a bug. Ignore this inspection result if the variable is assigned in another procedure via a ByRef parameter..
        /// </summary>
        public static string VariableNotAssignedInspection {
            get {
                return ResourceManager.GetString("VariableNotAssignedInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a Variable is not referred to.
        /// </summary>
        public static string VariableNotUsedInspection {
            get {
                return ResourceManager.GetString("VariableNotUsedInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a A variable whose type isn&apos;t explicitly declared, is implicitly &apos;Variant&apos;. Consider making it an explicit &apos;Variant&apos; if that&apos;s intended, or declare a more specific type..
        /// </summary>
        public static string VariableTypeNotDeclaredInspection {
            get {
                return ResourceManager.GetString("VariableTypeNotDeclaredInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Cerca una stringa localizzata simile a A property that exposes a mutator but no accessor is a design smell and makes a confusing API. Consider exposing a getter, or converting the mutator to a method..
        /// </summary>
        public static string WriteOnlyPropertyInspection {
            get {
                return ResourceManager.GetString("WriteOnlyPropertyInspection", resourceCulture);
            }
        }
    }
}
