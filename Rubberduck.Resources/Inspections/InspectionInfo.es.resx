<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AssignedByValParameterInspection" xml:space="preserve">
    <value>El parámetro se pasa por valor, pero se le asigna un nuevo valor/referencia. Considere hacer una copia local en su lugar si se supone que la persona que llama no sabe el nuevo valor. Si la persona que llama debería ver el nuevo valor, el parámetro debería pasar ByRef en su lugar, y tiene un error.</value>
  </data>
  <data name="ConstantNotUsedInspection" xml:space="preserve">
    <value>Rubberduck no pudo encontrar ninguna referencia a la constante. Considere la posibilidad de eliminar la declaración no utilizada.</value>
  </data>
  <data name="DefaultProjectNameInspection" xml:space="preserve">
    <value>Considera nombrar tu proyecto VBA.</value>
  </data>
  <data name="EmptyStringLiteralInspection" xml:space="preserve">
    <value>La constante incorporada 'vbNullString' es un puntero de cadena nulo que ocupa 0 bytes de memoria, que transmite inequívocamente la intención de una cadena vacía.</value>
  </data>
  <data name="EncapsulatePublicFieldInspection" xml:space="preserve">
    <value>En su lugar, considere hacer una propiedad disponible.</value>
  </data>
  <data name="ImplicitActiveSheetReferenceInspection" xml:space="preserve">
    <value>Las referencias implícitas a la hoja activa hacen que el código sea frágil y más difícil de depurar. Considere hacer estas referencias explícitas cuando estén destinadas y prefiera trabajar con referencias de objetos. Ignorar si la llamada del miembro hace referencia a un tipo que Rubberduck no puede resolver.</value>
  </data>
  <data name="ImplicitActiveWorkbookReferenceInspection" xml:space="preserve">
    <value>Las referencias implícitas al libro de trabajo activo hacen que el código sea frágil y más difícil de depurar. Considere hacer estas referencias explícitas cuando estén destinadas y prefiera trabajar con referencias de objetos. Ignorar si la llamada del miembro hace referencia a un tipo que Rubberduck no puede resolver.</value>
  </data>
  <data name="ImplicitByRefModifierInspection" xml:space="preserve">
    <value>Los parámetros se pasan por referencia a menos que se especifique lo contrario, lo que puede ser confuso y propenso a errores. Prefiera pasar parámetros por valor y especifique ByRef explícitamente cuando pase parámetros por referencia.</value>
  </data>
  <data name="ImplicitPublicMemberInspection" xml:space="preserve">
    <value>Los miembros del módulo son públicos por defecto, lo que puede ser contraintuitivo. Considere la posibilidad de especificar modificadores de acceso explícitos para evitar la ambigüedad.</value>
  </data>
  <data name="ImplicitVariantReturnTypeInspection" xml:space="preserve">
    <value>Los miembros con un valor de retorno devuelven implícitamente un 'Variant' a menos que se especifique lo contrario. Considere devolver un 'Variant' explícito cuando no se conozca el tipo de retorno, o especifíquelo explícitamente.</value>
  </data>
  <data name="MoveFieldCloserToUsageInspection" xml:space="preserve">
    <value>Una variable de nivel de módulo utilizada solo en un procedimiento debe declararse en ese procedimiento.</value>
  </data>
  <data name="MultilineParameterInspection" xml:space="preserve">
    <value>Considere la posibilidad de continuar las firmas largas entre los parámetros. La división de una declaración de parámetros en múltiples líneas podría perjudicar la legibilidad.</value>
  </data>
  <data name="MultipleDeclarationsInspection" xml:space="preserve">
    <value>Declarar múltiples variables en la misma instrucción es legal, pero debe usarse con moderación. Considere declarar las variables más cerca de su uso, en una sola instrucción por declaración.</value>
  </data>
  <data name="NonReturningFunctionInspection" xml:space="preserve">
    <value>Esto es probablemente un error. El valor de retorno de una función o un captador de propiedades debe asignarse antes de salir, de lo contrario el programa no funcionará con los resultados esperados. Si una función no tiene un valor de retorno significativo, considere declararlo como un procedimiento 'Sub' en su lugar.</value>
  </data>
  <data name="ObsoleteCallStatementInspection" xml:space="preserve">
    <value>La declaración de 'Call' ya no es necesaria para llamar a procedimientos, y solo existe en el idioma para admitir el código heredado que lo requirió; Se puede reescribir de forma segura a una llamada implícita.</value>
  </data>
  <data name="ObsoleteCommentSyntaxInspection" xml:space="preserve">
    <value>La declaración 'Rem' solo existe en el idioma para admitir el código heredado que lo requirió; se puede reemplazar de forma segura con un comentario de apóstrofe / comilla simple.</value>
  </data>
  <data name="ObsoleteGlobalInspection" xml:space="preserve">
    <value>La palabra clave 'Global' solo existe en el idioma para admitir el código heredado que lo requería; Puede ser reemplazado de forma segura con el modificador 'Public'.</value>
  </data>
  <data name="ObsoleteLetStatementInspection" xml:space="preserve">
    <value>La declaración 'Let' solo existe en el idioma para admitir el código heredado que lo requería; se puede eliminar de forma segura, ya que el VBA moderno no requiere esa palabra clave para las asignaciones de valor.</value>
  </data>
  <data name="ObsoleteTypeHintInspection" xml:space="preserve">
    <value>Los caracteres de sugerencia de tipo solo existen en el idioma para admitir el código heredado que lo requirió; se pueden reemplazar de forma segura en declaraciones con una cláusula de tipo "As" que especifica el tipo explícitamente y se pueden omitir en otras referencias de identificador.</value>
  </data>
  <data name="OptionBaseInspection" xml:space="preserve">
    <value>Las matrices son típicamente basadas en cero. Esta opción cambia el límite inferior predeterminado para arreglos de tamaño implícito, que pueden introducir errores off-by-one si uno no es cauteloso.</value>
  </data>
  <data name="OptionExplicitInspection" xml:space="preserve">
    <value>VBA alegremente compilará un error tipográfico: use 'Option Explicit' para evitar compilar con éxito un programa erróneo.</value>
  </data>
  <data name="ParameterCanBeByValInspection" xml:space="preserve">
    <value>Un parámetro que se pasa por referencia y no se le asigna un nuevo valor / referencia, podría pasarse por valor en su lugar.</value>
  </data>
  <data name="ParameterNotUsedInspection" xml:space="preserve">
    <value>Un parámetro se pasa a un miembro que no lo usa. Considere eliminar ese parámetro.</value>
  </data>
  <data name="ProcedureNotUsedInspection" xml:space="preserve">
    <value>Rubberduck no pudo encontrar ninguna llamada para el procedimiento. Si el procedimiento está conectado a un botón macro, se utiliza como una función definida por el usuario (UDF) o maneja un evento de aplicación que Rubberduck no sabía que puede ignorar este resultado de la inspección; De lo contrario, considere eliminarlo.</value>
  </data>
  <data name="UnassignedVariableUsageInspection" xml:space="preserve">
    <value>Esto es probablemente un error. Se hace referencia a una variable, pero nunca se asigna.</value>
  </data>
  <data name="UntypedFunctionUsageInspection" xml:space="preserve">
    <value>Existe una función equivalente que devuelve una cadena de caracteres y debería usarse preferiblemente para evitar conversiones de tipos implícitas.
Si el parámetro puede ser nulo, ignore el resultado de esta inspección; pasar un valor nulo a una función que espera una cadena provocaría un error de tiempo de ejecución de falta de coincidencia de tipo.</value>
  </data>
  <data name="UseMeaningfulNameInspection" xml:space="preserve">
    <value>Los nombres de los identificadores deben indicar para qué se usan y deben ser legibles; evitar el desmontaje, los sufijos numéricos y los nombres de 1 o 2 caracteres.</value>
  </data>
  <data name="VariableNotAssignedInspection" xml:space="preserve">
    <value>La variable no está asignada. Si esto no es intencional, probablemente hay un error. Ignore este resultado de la inspección si la variable se asigna en otro procedimiento a través de un parámetro ByRef.</value>
  </data>
  <data name="VariableNotUsedInspection" xml:space="preserve">
    <value>La variable no es referida</value>
  </data>
  <data name="VariableTypeNotDeclaredInspection" xml:space="preserve">
    <value>Una variable cuyo tipo no se declara explícitamente, es implícitamente 'Variant'. Considere convertirlo en una 'Variant' explícita si está destinada, o declare un tipo más específico.</value>
  </data>
  <data name="WriteOnlyPropertyInspection" xml:space="preserve">
    <value>Una propiedad que expone un mutador pero que no tiene acceso es un error de diseño y crea una API confusa. Considere la posibilidad de exponer un captador o convertir el mutador en un método.</value>
  </data>
  <data name="ProcedureCanBeWrittenAsFunctionInspection" xml:space="preserve">
    <value>Un procedimiento que solo tiene un parámetro pasado por referencia al que se le asigna un nuevo valor / referencia antes de que finalice el procedimiento, está utilizando un parámetro ByRef como valor de retorno: en su lugar, considere convertirlo en una función.</value>
  </data>
  <data name="SelfAssignedDeclarationInspection" xml:space="preserve">
    <value>Una declaración de variable de objeto auto-instanciada en el ámbito del procedimiento cambia cómo funciona la anulación de la referencia, lo que puede llevar a un comportamiento inesperado.</value>
  </data>
  <data name="FunctionReturnValueNotUsedInspection" xml:space="preserve">
    <value>Un miembro se escribe como una función, pero se usa como un procedimiento. A menos que la función sea recursiva, considere convertir la 'Función' en un 'Sub'. Si la función es recursiva, ninguno de sus llamadores externos está utilizando el valor devuelto.</value>
  </data>
  <data name="ObjectVariableNotSetInspection" xml:space="preserve">
    <value>Por lo que Rubberduck puede decir, esta variable es una variable de objeto, asignada sin la palabra clave 'Set'. Esto causa el error 91 en tiempo de ejecución 'Objeto o variable de bloque no establecida'.</value>
  </data>
  <data name="MissingAnnotationArgumentInspection" xml:space="preserve">
    <value>Falta un parámetro de anotación o está incorrectamente especificado. La sintaxis correcta es: '@Annotation([parámetro]) \nEjemplo:' @Folder("Padre.Hijo")</value>
  </data>
  <data name="ModuleScopeDimKeywordInspection" xml:space="preserve">
    <value>La palabra clave 'Public' solo se puede utilizar a nivel de módulo; su contraparte 'Privado' también puede usarse solo a nivel de módulo. Sin embargo, 'Dim' se puede usar para declarar las variables de alcance del módulo y del procedimiento. Por coherencia, sería preferible reservar 'Dim' para los locales, y así usar 'Private' en lugar de 'Dim' a nivel de módulo.</value>
  </data>
  <data name="UndeclaredVariableInspection" xml:space="preserve">
    <value>El código que utiliza variables no declaradas no se compila cuando se especifica Option Explicit. Las variables no declaradas siempre son Variant, un tipo de datos que incurre en gastos generales y almacenamiento innecesarios.</value>
  </data>
  <data name="HungarianNotationInspection" xml:space="preserve">
    <value>La notación húngara hace que el código sea menos legible, y es redundante cuando se usan variables fuertemente tipificadas y nombres significativos.</value>
  </data>
  <data name="MemberNotOnInterfaceInspection" xml:space="preserve">
    <value>Se realiza una llamada de acceso de miembro contra una interfaz extendida que Rubberduck no pudo resolver, o no se pudo encontrar al miembro. Si VBA no puede resolver el tipo en tiempo de ejecución, se generará el error 438. Si hay disponible una interfaz equivalente, no extendida, que Rubberduck puede resolver, considere usarla en su lugar.</value>
  </data>
  <data name="HostSpecificExpressionInspection" xml:space="preserve">
    <value>La aplicación host evalúa las expresiones entre corchetes en tiempo de ejecución, lo que significa que VBA no puede validar la expresión en tiempo de compilación. Considere usar el modelo de objetos de la aplicación host en su lugar.</value>
  </data>
  <data name="ApplicationWorksheetFunctionInspection" xml:space="preserve">
    <value>El objeto de la aplicación de Excel no implementa la interfaz WorksheetFunction directamente. Todas las llamadas realizadas a los miembros de WorksheetFunction se manejan como un enlace tardío y los errores en el miembro llamado se devolverán envueltos en una Variant de VbVarType.vbError. Esto hace que los errores no se puedan interceptar con los controladores de errores y agrega una penalización de rendimiento en comparación con las llamadas enlazadas tempranas. Considere llamar a Application.WorksheetFunction explícitamente. Nota: Si esta llamada generó errores en el pasado, esos errores se ignoraron. Si está aplicando la solución rápida, el manejo correcto de errores debe estar en su lugar.</value>
  </data>
  <data name="OptionBaseZeroInspection" xml:space="preserve">
    <value>Esta es la configuración predeterminada, no es necesario especificarla.</value>
  </data>
  <data name="IllegalAnnotationInspection" xml:space="preserve">
    <value>Una anotación que debe especificarse a nivel de módulo no se puede utilizar para anotar miembros; las anotaciones destinadas a ser miembros de anotaciones no se pueden utilizar a nivel de módulo.</value>
  </data>
  <data name="MissingAttributeInspection" xml:space="preserve">
    <value>Se especifica una anotación de Rubberduck para un módulo o miembro, pero el atributo correspondiente no está presente. Los atributos del módulo y las anotaciones deben estar sincronizados.</value>
  </data>
  <data name="EmptyIfBlockInspection" xml:space="preserve">
    <value>Una rama condicional vacía sin declaraciones ejecutables deja a un programador preguntándose sobre la intención del código. Evite escribir código que no necesita ser escrito.</value>
  </data>
  <data name="RedundantOptionInspection" xml:space="preserve">
    <value>Being the default/implicit setting for this option, this instruction can be safely omitted.</value>
  </data>
  <data name="RedundantByRefModifierInspection" xml:space="preserve">
    <value>De forma predeterminada, todos los parámetros se pasan por referencia, por lo que no es necesario incluir el modificador 'ByRef'.</value>
  </data>
  <data name="LineLabelNotUsedInspection" xml:space="preserve">
    <value>Una etiqueta de línea que nunca se salta a ('GoTo', 'Resume', ...), no sirve para nada. Considera removerlo.</value>
  </data>
  <data name="EmptyElseBlockInspection" xml:space="preserve">
    <value>Un bucle 'Else' sin ninguna instrucción ejecutable, deja a un programador preguntándose acerca de la intención del código. Evite escribir código que no necesita ser escrito.</value>
  </data>
  <data name="IntegerDataTypeInspection" xml:space="preserve">
    <value>El valor máximo de un entero con signo de 16 bits es 32.767: el uso de un tipo de datos de entero de 32 bits (Long) siempre que sea posible puede ayudar a prevenir errores de "Desbordamiento" en el tiempo de ejecución, y es mejor manejado por las CPU modernas.</value>
  </data>
  <data name="StopKeywordInspection" xml:space="preserve">
    <value>La palabra clave 'Stop' detiene la ejecución y abre el depurador. Evita su uso en código distribuido.</value>
  </data>
  <data name="EmptyCaseBlockInspection" xml:space="preserve">
    <value>Un bloque 'Case' vacío sin ninguna instrucción ejecutable, deja a un programador preguntándose sobre la intención del código. Evite escribir código que no necesita ser escrito.</value>
  </data>
  <data name="EmptyDoWhileBlockInspection" xml:space="preserve">
    <value>Un bucle 'Do...While' sin ninguna instrucción ejecutable deja a un programador preguntándose acerca de la intención del código. Evite escribir código que no necesita ser escrito.</value>
  </data>
  <data name="EmptyForEachBlockInspection" xml:space="preserve">
    <value>Un bucle 'For Each...Next' sin declaraciones ejecutables deja a un programador preguntándose sobre la intención del código. Evite escribir código que no necesita ser escrito.</value>
  </data>
  <data name="EmptyForLoopBlockInspection" xml:space="preserve">
    <value>Un bucle 'For...Next' sin declaraciones ejecutables deja a un programador preguntándose sobre la intención del código. Evite escribir código que no necesita ser escrito.</value>
  </data>
  <data name="EmptyWhileWendBlockInspection" xml:space="preserve">
    <value>Un bloque 'Loop' sin declaraciones ejecutables, deja a un programador preguntándose sobre la intención del código. Evite escribir código que no necesita ser escrito.</value>
  </data>
  <data name="ShadowedDeclarationInspection" xml:space="preserve">
    <value>Dos declaraciones están dentro del alcance y tienen el mismo nombre de identificador. Esto significa que solo uno de ellos estará disponible para usar.</value>
  </data>
  <data name="ObsoleteErrorSyntaxInspection" xml:space="preserve">
    <value>La declaración de 'Error' solo existe en el idioma para admitir el código heredado que lo requirió; use 'Err.Raise' en su lugar.</value>
  </data>
  <data name="BooleanAssignedInIfElseInspection" xml:space="preserve">
    <value>A un miembro se le asigna Verdadero / Falso en diferentes ramas de una declaración if sin otras declaraciones en el condicional. Utilice la condición directamente al miembro en su lugar.</value>
  </data>
  <data name="EmptyModuleInspection" xml:space="preserve">
    <value>Los módulos y clases vacíos apuntan a una funcionalidad aún no implementada o representan un equipaje innecesario que puede perjudicar la mantenibilidad de un proyecto.</value>
  </data>
  <data name="UnhandledOnErrorResumeNextInspection" xml:space="preserve">
    <value>El manejo de errores se debe restaurar después de usar 'On Error Resume Next'.</value>
  </data>
  <data name="DefTypeStatementInspection" xml:space="preserve">
    <value>El uso de la declaración 'Def [Type]' lleva a especificar tipos utilizando un prefijo. Este estilo de denominación está muy desaconsejado y debe evitarse.</value>
  </data>
  <data name="StepIsNotSpecifiedInspection" xml:space="preserve">
    <value>Step del bucle for-next no está especificado. Esto podría ser involuntario.</value>
  </data>
  <data name="StepOneIsRedundantInspection" xml:space="preserve">
    <value>1 es el Step predeterminado en un bucle 'For ... Next' y, por lo tanto, es redundante.</value>
  </data>
  <data name="SheetAccessedUsingStringInspection" xml:space="preserve">
    <value>Excel ya define una variable de objeto de ámbito global con esta referencia. Considere usar la propiedad 'CodeName' de la hoja.</value>
  </data>
  <data name="ObsoleteMemberUsageInspection" xml:space="preserve">
    <value>Este miembro está marcado '@Obsolete'. Ya no se debe usar, debería haber una mejor alternativa.</value>
  </data>
  <data name="ObsoleteCallingConventionInspection" xml:space="preserve">
    <value>Las implementaciones de Windows de Visual Basic solo son compatibles con la convención de llamada StdCall. La convención de llamada CDecl solo es compatible con las versiones de VBA de Macintosh. El uso de esta palabra clave en Windows resultará en el error 49 en tiempo de ejecución - 'convención de llamada a DLL incorrecta'. Si este procedimiento solo está destinado a ser usado en hosts de Macintosh, debe compilarse condicionalmente.</value>
  </data>
  <data name="DuplicatedAnnotationInspection" xml:space="preserve">
    <value>Una anotación se especifica varias veces, pero se pretende que se especifique solo una vez.</value>
  </data>
  <data name="ModuleWithoutFolderInspection" xml:space="preserve">
    <value>Los módulos sin la anotación '@Folder' no pueden recibir agrupaciones personalizadas en el Explorador de códigos.</value>
  </data>
  <data name="OnLocalErrorInspection" xml:space="preserve">
    <value>On Local Error existe solo por compatibilidad con versiones anteriores de Visual Basic, y todos los errores se tratan como locales, independientemente de la declaración de On Local Error. El uso incorrecto de esta palabra clave da la impresión de que existe una distinción entre los tipos de manejo de errores cuando no existe.</value>
  </data>
  <data name="IsMissingOnInappropriateArgumentInspection" xml:space="preserve">
    <value>IsMissing solo está destinado a ser invocado en argumentos opcionales, y solo devolverá resultados correctos si el tipo del argumento es 'Variant' sin un valor predeterminado explícito. Todos los demás usos devolverán 'False'.</value>
  </data>
  <data name="IsMissingWithNonArgumentParameterInspection" xml:space="preserve">
    <value>IsMissing solo está destinado a ser invocado en los argumentos del procedimiento de contención, y casi todos los demás usos devolverán 'False'. Pasar cualquier otra expresión a la función es equivalente a 'VarType ({expresión}) = vbError', y en raras ocasiones puede causar que la aplicación host se bloque.</value>
  </data>
  <data name="AssignmentNotUsedInspection" xml:space="preserve">
    <value>Una asignación es anulada inmediatamente por otra asignación o nunca se hace referencia.</value>
  </data>
  <data name="UnderscoreInPublicClassModuleMemberInspection" xml:space="preserve">
    <value>Un módulo de clase que contiene miembros con guiones bajos no puede ser implementado por otras clases. El guión bajo se usa como separador entre la interfaz/nombre de objeto y el nombre de miembro implementado: tener un guión bajo en el nombre de miembro confunde el programador, que luego se niega a compilar el proyecto. Evite los guiones bajos en los nombres de miembros públicos siguiendo una convención de nomenclatura 'PascalCase'.</value>
  </data>
  <data name="ExcelMemberMayReturnNothingInspection" xml:space="preserve">
    <value>Un procedimiento que devuelve un objeto puede devolver "Nothing". Eso causará un error 91 en tiempo de ejecución - "Variable de objeto o variable de bloque no declarada" en el acceso subsiguiente del miembro. Realice una verificación 'Is Nothing' después de la asignación 'Set' para protegerse contra los errores en tiempo de ejecución.</value>
  </data>
  <data name="ExcelUdfNameIsValidCellReferenceInspection" xml:space="preserve">
    <value>Las funciones que son visibles para Excel como funciones definidas por el usuario devolverán un '#REF!' error cuando se utiliza en una hoja de trabajo si coinciden con el nombre de una referencia de celda válida. Si la función está destinada a ser utilizada como un UDF, debe cambiar su nombre. Si la función no está diseñada para ser utilizada como un UDF, debe tener un ámbito como 'Privado' o retirarse de un Módulo estándar.</value>
  </data>
  <data name="AttributeValueOutOfSyncInspection" xml:space="preserve">
    <value>Se especifica una anotación de Rubberduck para un módulo o miembro, pero el atributo correspondiente tiene un valor diferente. Los atributos del módulo y las anotaciones deben estar sincronizados.</value>
  </data>
  <data name="MissingMemberAnnotationInspection" xml:space="preserve">
    <value>Los atributos de los miembros no se muestran en el VBE. Al agregar una anotación, hace que estos atributos sean más explícitos, y Rubberduck puede mantener las anotaciones y los atributos sincronizados.</value>
  </data>
  <data name="MissingModuleAnnotationInspection" xml:space="preserve">
    <value>Los atributos del módulo no se muestran en el VBE. Al agregar una anotación, hace que estos atributos sean más explícitos, y Rubberduck puede mantener las anotaciones y los atributos sincronizados.</value>
  </data>
  <data name="KeywordsUsedAsMemberInspection" xml:space="preserve">
    <value>Una palabra clave se usa como miembro en una enumeración o en un tipo definido por el usuario. Eso puede llevar a una resolución ambigua. Considere cambiar el nombre del miembro.</value>
  </data>
  <data name="LineContinuationBetweenKeywordsInspection" xml:space="preserve">
    <value>Hay continuaciones de línea entre palabras clave. No hay una buena razón para ponerlas allí; Considera eliminarlas por completo</value>
  </data>
  <data name="NonBreakingSpaceIdentifierInspection" xml:space="preserve">
    <value>El identificador contiene un espacio de no ruptura que se parece mucho a un espacio ordinario, que concibe el código y crea una experiencia confusa. Considere el uso de caracteres visibles para los identificadores.</value>
  </data>
  <data name="NegativeLineNumberInspection" xml:space="preserve">
    <value>Los números de línea negativos en realidad se ingresan como literal hexadecimal y luego son prectificados por VBE. Volver a editar la línea hará que se vuelva roja, ya que los números de línea negativos son, de hecho, ilegales.</value>
  </data>
  <data name="OnErrorGoToMinusOneInspection" xml:space="preserve">
    <value>Si bien esto es legal, se trata de una "característica" mal documentada que significa algo diferente: el estado de error también se borra además de deshabilitar cualquier manejo de errores. Sin embargo, esto puede ser ambiguo, ya que una etiqueta de línea negativa de -1 puede terminar como un objetivo y un manejo de errores excesivamente complejo generalmente indica la necesidad de refactorizar el procedimiento.</value>
  </data>
</root>