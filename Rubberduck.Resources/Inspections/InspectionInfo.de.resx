<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AssignedByValParameterInspection" xml:space="preserve">
    <value>Parameter wird als Wert übergeben, aber überschrieben. Eine Lokale Kopie verdeutlicht, dass die Aufrufende den neuen Wert nicht kennen soll. Falls die Aufrufende den neuen Wert kennen soll, müsste der Parameter 'ByRef' übergeben werden und dies ist ein Bug.</value>
  </data>
  <data name="ConstantNotUsedInspection" xml:space="preserve">
    <value>Rubberduck konnte keine Referenz auf eine Konstante finden. Überlegen Sie eine Entfernung der nicht verwendeten Deklaration.</value>
  </data>
  <data name="DefaultProjectNameInspection" xml:space="preserve">
    <value>Erwäge Sie dem VBA-Projekt einen Namen zu geben.</value>
  </data>
  <data name="EmptyStringLiteralInspection" xml:space="preserve">
    <value>Die eingebaute Konstante 'vbNullString' ist ein Null-String Zeiger, der 0 bytes Arbeitsspeicher benötigt. Dies ist das beabsichtigte Verhalten eines leeren Strings.</value>
  </data>
  <data name="EncapsulatePublicFieldInspection" xml:space="preserve">
    <value>Erwägen Sie stattdessen, eine Eigenschaft verfügbar zu machen.</value>
  </data>
  <data name="ImplicitActiveSheetReferenceInspection" xml:space="preserve">
    <value>Implizite Referenzen zum aktuellen Tabellenblatt macht den Code anfällig und schwieriger zu debuggen. Erwäge die Referenz explizit anzugeben oder vorzugsweise mit Objektreferenzen zu arbeiten. Ignoriere wenn der Methodenaufruf sich auf einen Typ bezieht, den Rubberduck nicht auflösen kann.</value>
  </data>
  <data name="ImplicitActiveWorkbookReferenceInspection" xml:space="preserve">
    <value>Implizite Referenzen zur aktuellen Arbeitsmappe macht den Code anfällig und schwieriger zu debuggen. Erwäge die Referenz explizit anzugeben oder vorzugsweise mit Objektreferenzen zu arbeiten. Ignoriere wenn der Methodenaufruf sich auf einen Typ bezieht, den Rubberduck nicht auflösen kann.</value>
  </data>
  <data name="ImplicitPublicMemberInspection" xml:space="preserve">
    <value>Die Methoden eines Moduls sind standardmäßig öffentlich, was irreführend sein kann. Besser ist es, den Gültigkeitsbereich der Methoden explizit zu definieren.</value>
  </data>
  <data name="ImplicitVariantReturnTypeInspection" xml:space="preserve">
    <value>Methoden mit einem Rückgabewert geben, wenn nicht anders angegeben, implizit 'Variant' zurück. Überlege, ob es nicht besser ist, den Rückgabewert explizit als 'Variant' zu definieren, wenn der Typ des Rückgabewertes nicht bekannt ist.</value>
  </data>
  <data name="MoveFieldCloserToUsageInspection" xml:space="preserve">
    <value>Eine Variable, die im Modulkopf deklariert wurde aber nur in einer Prozedur verwendet wird, sollte in der Prozedur deklariert werden.</value>
  </data>
  <data name="MultilineParameterInspection" xml:space="preserve">
    <value>Überlege lange Parameterdeklarationen zusammenzuhalten. Das Aufteilen einer Parameterdeklaration über mehrere Zeilen sollte zugunsten der besseren Lesbarkeit vermieden werden.</value>
  </data>
  <data name="MultipleDeclarationsInspection" xml:space="preserve">
    <value>Die Deklaration von mehren Variablen in der gleichen Codezeile ist erlaubt, sollte aber sparsam eingesetzt werden. Erwäge die Variablendeklartion in der Nähe der Nutzung als separate Anweisung pro Deklaration.</value>
  </data>
  <data name="NonReturningFunctionInspection" xml:space="preserve">
    <value>Hier könnte ein Fehler vorliegen. Der Rückgabewert einer Funktion oder Eigenschaft wird nicht zugewiesen. Dies kann zu unvorhersehbaren Verhalten des Codes führen. Wenn die Funktion keinen sinnvollen Rückgabewert hat, sollte sie in eine 'Sub'-Routine umgeschrieben werden.</value>
  </data>
  <data name="ObsoleteCallStatementInspection" xml:space="preserve">
    <value>Die 'Call'-Anweisung ist nicht mehr zum Aufruf einer Anweisung notwendig. Sie existiert aus Gründen der Abwärtskompatibilität. Sie kann problemlos durch einen impliziten Anweisungsaufruf ersetzt werden.</value>
  </data>
  <data name="ObsoleteCommentSyntaxInspection" xml:space="preserve">
    <value>Die 'REM'-Anweisung existiert aus Gründen der Abwärtskompatibilität. Sie kann gefahrlos durch ein einfaches Anführungszeichen ersetzt werden.</value>
  </data>
  <data name="ObsoleteGlobalInspection" xml:space="preserve">
    <value>Das Schlüsselwort 'Global' existiert aus Gründen der Abwärtskompatibilität. Es kann gefahrlos durch 'Public' ersetzt werden.</value>
  </data>
  <data name="ObsoleteLetStatementInspection" xml:space="preserve">
    <value>Die 'Let'-Anweisung  existiert aus Gründen der Abwärtskompatibilität. Sie kann gefahrlos entfernt werden, da das moderne VBA dieses Schlüsselwort nicht mehr zur Werte-Zuweisung benötigt.</value>
  </data>
  <data name="ObsoleteTypeHintInspection" xml:space="preserve">
    <value>Die Verwendung der Typ-Buchstaben (z.B. $)  existiert aus Gründen der Abwärtskompatibilität. Sie kann gefahrlos durch eine 'As'-Typdeklaration ersetzt werden.</value>
  </data>
  <data name="OptionBaseInspection" xml:space="preserve">
    <value>Arrays sind normalerweise null-basiert. Diese Option ändert die untere Standardgrenze für impliziert erzeugte Arrays. Dies kann einen 'off-by-one' Fehler erzeugen, wenn sie nicht sorgsam eingesetzt wird.</value>
  </data>
  <data name="OptionExplicitInspection" xml:space="preserve">
    <value>VBA kompiliert ohne ohne 'Option Explicit` auch Tippfehlern erfolgreich: Verwenden Sie 'Option Explicit', um zu verhindern, dass ein fehlerhaftes Programm erfolgreich kompiliert wird.</value>
  </data>
  <data name="ParameterCanBeByValInspection" xml:space="preserve">
    <value>Ein Parameter der als Referenz übergeben wird, aber keine neue Wert- oder Referenzzuweisung erhält, sollte als Wert übergeben werden.</value>
  </data>
  <data name="ParameterNotUsedInspection" xml:space="preserve">
    <value>Ein Parameter, der der Methode übergeben wird, wird nicht verwendet. Erwäge diesen zu entfernen.</value>
  </data>
  <data name="ProcedureNotUsedInspection" xml:space="preserve">
    <value>Rubberduck kann keinen Aufruf für die Prozedur finden. Falls diese über eine Markro-Schaltfläche, als benutzerdefinierte Funktion oder als Event-Handler genutzt wird, den Rubberduck nicht kennt, kann dieser Hinweis ignoriert werden. Ansonsten sollte sie entfernt werden.</value>
  </data>
  <data name="UnassignedVariableUsageInspection" xml:space="preserve">
    <value>Hier könnte ein Fehler vorliegen. Eine Variable wird referenziert aber ihr wird kein Wert zugewiesen.</value>
  </data>
  <data name="UntypedFunctionUsageInspection" xml:space="preserve">
    <value>Es gibt eine äquivalente Funktion, die einen String zurückgibt. Diese sollte bevorzugt genutzt werden, um implitizite Typumwandlungen zu vermeiden.
Falls der Parameter 'null' sein kann, bitte dieses Auftreten ignorieren. 'null' an die Funktion zu übergeben, die einen String erwartet würde zu einem "Type Mismatch"-Laufzeitfehler führen.</value>
  </data>
  <data name="UseMeaningfulNameInspection" xml:space="preserve">
    <value>Bezeicher sollten lesbar sein und ihren Verwendungszweck widerspiegeln. Bezeichner ohne Vokale, mit nummerischem Suffix oder nur 1-2 Buchstaben sollten vermieden werden.</value>
  </data>
  <data name="VariableNotAssignedInspection" xml:space="preserve">
    <value>Einer Variable wird kein Wert zugewiesen. Falls das nicht beabsichtigt ist, kann das zu einem Fehler führen. Ignorieren Sie diese Warnung, falls die Variable in einer anderen Prozedur durch einen 'ByRef'-Parameter zugewiesen wird.</value>
  </data>
  <data name="VariableNotUsedInspection" xml:space="preserve">
    <value>Variable wird nicht gelesen</value>
  </data>
  <data name="VariableTypeNotDeclaredInspection" xml:space="preserve">
    <value>Variable, deren Typ nicht explizit deklariert wurde, erhält implizit den Typ 'Variant'. Überlege die Variable explizit als 'Variant' zu definieren oder eine besseren Typ zu zuweisen.</value>
  </data>
  <data name="WriteOnlyPropertyInspection" xml:space="preserve">
    <value>Eine Eigenschaft, die eine Änderungsfunktion, aber keine Zugriffsfunktion bereitstellt, führt zu einer unklaren API. Enweder erstelle einen öffentlichen getter oder ändere die Änderungsfunktion in eine Methode ab.</value>
  </data>
  <data name="ProcedureCanBeWrittenAsFunctionInspection" xml:space="preserve">
    <value>Eine Prozedur, die nur einen Parameter als Referenz übergibt, der vor dem Verlassen der Prozedur einen neuen Wert oder Referenz erhält, sollte als Funktion umgeschrieben werden.</value>
  </data>
  <data name="SelfAssignedDeclarationInspection" xml:space="preserve">
    <value>Eine selbstzugewiesene Objektvariablendeklaration in einer Prozedur kann das Verhalten beim Nulling verändern. Dies kann zu unvorhergesehen Verhalten des Codes führen.</value>
  </data>
  <data name="ObjectVariableNotSetInspection" xml:space="preserve">
    <value>Rubberduck hat festgestellt, dass die Variable eine Objektvariable ist, die ohne 'Set'-Schlüsselwort zugewiesen wird. Dies führt zu dem Laufzeitfehler 91 'Objektvariable oder With-Blockvariable nicht festgelegt' oder 438 'Objekt unterstützt diese Eigenschaft oder Methode nicht' abhängig davon, ob die Variable den Wert 'Nothing' hat oder nicht.</value>
  </data>
  <data name="MissingAnnotationArgumentInspection" xml:space="preserve">
    <value>Einer Annotation in einem Kommentar fehlt ein Argument oder sie konnte nicht gelesen werden. Die korrekte Syntax ist: '@Annotation([parameter])'\nBeispiel: '@Folder("Parent.Child")'</value>
  </data>
  <data name="UndeclaredVariableInspection" xml:space="preserve">
    <value>Code, der undeklarierte Variablen verwendet, kompiliert nicht wenn 'Option Explicit' spezifiziert wird. Undeklarierte Variablen sind immer vom Typ 'Variant', was unnötige Zusatzkosten in Ausführungszeit und Speicherverbauch verursacht.</value>
  </data>
  <data name="ModuleScopeDimKeywordInspection" xml:space="preserve">
    <value>Das Schlüsselwort 'Public' kann nur auf Modulebene verwendet werden; Sein Konterpart 'Private' kann auch nur auf Modulebene verwendet werden. 'Dim' jedoch kann verwendet werden, um sowohl modulweite als auch prozedurweite Variablen zu deklarieren. Um der Konsistenz Willen ist es besser, 'Dim' nur für lokale Variablen zu verwenden, also 'Private' statt 'Dim' auf Modulebene zu verwenden.</value>
  </data>
  <data name="FunctionReturnValueAlwaysDiscardedInspection" xml:space="preserve">
    <value>Ein Element ist als Funktion geschrieben, wird aber überall wie eine Prozedur verwendet. Sie sollten in Erwägung ziehen die 'Function' in ein 'Sub' zu konvertieren.</value>
  </data>
  <data name="MemberNotOnInterfaceInspection" xml:space="preserve">
    <value>Es wird ein Elementzugriff verwendet, der vom Interface des Objektes nicht deklariert wird. Dies ist höchstwahrscheinlich ein Fehler. Falls der Elementzugriff das erweiterbare Interface des Objektes verwendet, erwägen Sie ein nicht erweiterbares Äquivalent zu verwenden um Prüfungen zur Kompilierzeit zu ermöglichen und das Auftreten von Laufzeitfehler 438 zu verhindern.</value>
  </data>
  <data name="HungarianNotationInspection" xml:space="preserve">
    <value>'Ungarische Notation' macht Code weniger lesbar und ist redundant, sobald stark typisierte Variablen und aussagekräftige Namen verwendet werden.</value>
  </data>
  <data name="ApplicationWorksheetFunctionInspection" xml:space="preserve">
    <value>Das Excel Application-Objekt implementiert das WorksheetFunction Interface nicht direkt. Alle Aufrufe an WorksheetFunction Elemente werden als spät gebunden behandelt und Fehler im aufgerufenen Element werden in ein Variant des Typs VbVarType.Error gekapselt. Dadurch können Fehler nicht mit Fehleranweisungen behandelt werden und gegenüber früh gebundenen Aufrufen sinkt die Performanz. Ziehen Sie in Erwägung Application.WorksheetFunction explizit aufzurufen. Bedenken Sie: Falls dieser Aufruf in der Vergangenheit Fehler erzeugt hat, wurden diese ignoriert. Es sollte eine Fehlerbehandlung vorhanden sein, bevor Sie die schnelle Korrektur anwenden.</value>
  </data>
  <data name="HostSpecificExpressionInspection" xml:space="preserve">
    <value>Geklammerte Ausdrücke werden von der Hostanwendung zur Laufzeit ausgewertet, was bedeutet, dass VBA den Ausdruck nicht zur Kompilierzeit validieren kann. Erwägen sie, das hostspezifische Objektmodell zu verwenden.</value>
  </data>
  <data name="OptionBaseZeroInspection" xml:space="preserve">
    <value>Dies ist die Standardeinstellung, sie muss nicht spezifiziert werden.</value>
  </data>
  <data name="RedundantOptionInspection" xml:space="preserve">
    <value>Da dies die Standardeinstellung für diese Option ist, kann die Anweisung ohne Nebeneffekte entfernt werden.</value>
  </data>
  <data name="RedundantByRefModifierInspection" xml:space="preserve">
    <value>Alle Parameter werden, falls nicht anders spezifiziert als Referenz übergeben. Es ist also nicht nötig, die 'ByRef'-Markierung zu verwenden.</value>
  </data>
  <data name="ImplicitByRefModifierInspection" xml:space="preserve">
    <value>Parameter werden, falls nicht anders spezifiziert, als Referenz übergeben. Dies kann verwirrend sein und Bugs hervorrufen. Bevorzugen Sie die Übergabe von Parametern als Werte und spezifizieren Sie eine Referenzübergabe explizit als ByRef.</value>
  </data>
  <data name="MissingAttributeInspection" xml:space="preserve">
    <value>Eine Rubberduck-Annotation wurde für ein Modul oder Element festgelegt, aber das zugehörige Attribut fehlt. Die Modul-Attribute und Annotationen sollten synchronisiert werden.</value>
  </data>
  <data name="EmptyIfBlockInspection" xml:space="preserve">
    <value>Ein leerer 'If'-Block ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="LineLabelNotUsedInspection" xml:space="preserve">
    <value>Rubberduck konnte keine Resume oder GoTo Anweisung zu einer Zeilenbezeichnung finden. Erwägen Sie eine Entfernung der Bezeichnung.</value>
  </data>
  <data name="EmptyForLoopBlockInspection" xml:space="preserve">
    <value>Eine leere 'For…Next'-Schleife ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="ShadowedDeclarationInspection" xml:space="preserve">
    <value>Zwei Deklarationen sind aktiv und haben denselben Namen. Dies bedeutet, dass nur eine von ihnen zur Verwendung verfügbar ist.</value>
  </data>
  <data name="StopKeywordInspection" xml:space="preserve">
    <value>Das Schlüsselwort 'Stop' unterbricht die Ausführung und ruft den Debugger auf. Vermeiden Sie die Verwendung in verteiltem Code.</value>
  </data>
  <data name="EmptyCaseBlockInspection" xml:space="preserve">
    <value>Ein leerer 'Case'-Block ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="EmptyForEachBlockInspection" xml:space="preserve">
    <value>Eine leere 'For Each…Next'-Schleife ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="EmptyElseBlockInspection" xml:space="preserve">
    <value>Ein leerer 'Else'-Block ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="EmptyWhileWendBlockInspection" xml:space="preserve">
    <value>Eine leere 'While…Wend'-Schleife ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="ObsoleteErrorSyntaxInspection" xml:space="preserve">
    <value>Die 'Error'-Anweisung existiert in der Sprache nur um Legacy-Programme zu unterstützen, die sie benötigten; Bevorzugen Sie stattdessen 'Err.Raise'.</value>
  </data>
  <data name="IntegerDataTypeInspection" xml:space="preserve">
    <value>Der größte Wert einer vorzeichenbehafteten 16-bit Ganzzahl ist 32.767 - Eine 32-bit Ganzzahl (Long) zu verwenden, wo es möglich ist, kann Überlauffehler zur Laufzeit verhindern und ist für moderne CPUs einfacher.</value>
  </data>
  <data name="EmptyDoWhileBlockInspection" xml:space="preserve">
    <value>Eine leere 'Do…While'-Schleife ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="BooleanAssignedInIfElseInspection" xml:space="preserve">
    <value>Ein Element wird in verschiedenen Zweigen einer if-Anweisung mit True / False zugewiesen, wobei keine anderen Anweisungen in der Bedingung enthalten sind. Verwenden Sie die Bedingung stattdessen direkt (als Zuweisung) für das Element.</value>
  </data>
  <data name="EmptyModuleInspection" xml:space="preserve">
    <value>Leere Module und Klassen weisen entweder auf noch nicht implementierte Funktionalitäten hin oder stellen unnötigen Ballast dar, der die Wartbarkeit eines Projekts behindern kann.</value>
  </data>
  <data name="UnhandledOnErrorResumeNextInspection" xml:space="preserve">
    <value>Fehlerbehandlung sollte nach Verwendung von 'On Error Resume Next' wiederhergestellt werden.</value>
  </data>
  <data name="DefTypeStatementInspection" xml:space="preserve">
    <value>Verwendung der 'Def[Type]' Anweisung führt zur Typspezifikation mit einem Präfix. Von diese Benennungskonvention wird stark abgeraten und sie sollte vermieden werden.</value>
  </data>
  <data name="StepIsNotSpecifiedInspection" xml:space="preserve">
    <value>'Step'  der 'For-Next'-Schleife ist nicht angegeben. Dies könnte versehentlich sein.</value>
  </data>
  <data name="StepOneIsRedundantInspection" xml:space="preserve">
    <value>1 ist der Standardwert für 'Step' in einer 'For-Next'-Schleife und daher redundant.</value>
  </data>
  <data name="SheetAccessedUsingStringInspection" xml:space="preserve">
    <value>Excel already defines a globally scoped object variable with this reference. Consider using the sheet's 'CodeName' property.</value>
  </data>
  <data name="ObsoleteMemberUsageInspection" xml:space="preserve">
    <value>Dieses Element ist als '@Obsolete' markiert. Er sollte nicht länger verwendet werden: eine bessere Alternative müsste existieren.</value>
  </data>
  <data name="ObsoleteCallingConventionInspection" xml:space="preserve">
    <value>Windows-Implementierungen von Visual Basic unterstützen nur die StdCall Aufrufkonvention. Die CDecl Aufrufkonvention wird nur von Macintosh-Versionen von VBA unterstützt. Dieses Schlüsselwort unter Windows zu verwenden, wird zum Laufzeitfehler 49 - 'Falsche DLL-Aufrufkonvention' führen. Falls diese Prozedur nur auf Macintosh-Hostanwendungen verwendet werden soll, sollte sie bedingt kompiliert werden.</value>
  </data>
  <data name="DuplicatedAnnotationInspection" xml:space="preserve">
    <value>Eine Annotation wurde mehrmals spezifiziert, obwohl sie nur einmal spezifiziert werden soll.</value>
  </data>
  <data name="ModuleWithoutFolderInspection" xml:space="preserve">
    <value>Module ohne '@Folder'-Annotation können im Code Explorer nicht in gesonderte Gruppen unterschieden werden.</value>
  </data>
  <data name="OnLocalErrorInspection" xml:space="preserve">
    <value>Die 'On Local Error'-Direktive existiert nur, um Kompatibilität zu vorigen Versionen von Visual Basic zu wahren. Alle Fehler werden unabhängig von der 'On Local Error'-Direktive als lokale Fehler behandelt. Die Verwendung dieser Direktive vermittelt irrtümlich den Eindruck, es existierten unterschiedliche Fehlerbehandlungstypen.</value>
  </data>
  <data name="IsMissingOnInappropriateArgumentInspection" xml:space="preserve">
    <value>'IsMissing' ist nur dafür gedacht, auf optionalen Argumenten aufgerufen zu werden und wird nur bei Variant-Argumenten ohne Standardwert korrekte Ergebnisse liefern. Jegliche andere Verwendung wird 'False' zurückliefern.</value>
  </data>
  <data name="IsMissingWithNonArgumentParameterInspection" xml:space="preserve">
    <value>'IsMissing' ist nur dafür gedacht, auf Argumenten der umgebenden Prozedur aufgerufen zu werden. Beinahe jegliche andere Verwendung wird 'False' zurückgeben. Einen anderen Ausdruck an diese Funktion zu übergeben ist äquvalent zu 'VarType({Ausdruck}) = vbError', und kann in seltenen Fällen zum Absturz der Hostanwendung führen.</value>
  </data>
  <data name="AssignmentNotUsedInspection" xml:space="preserve">
    <value>Eine Zuweisung wird direkt überschrieben oder nie referenziert.</value>
  </data>
  <data name="UnderscoreInPublicClassModuleMemberInspection" xml:space="preserve">
    <value>Ein Klassenmodul, das Element(e) mit Unterstrichen im Namen beinhaltet, kann nicht von anderen Klassen implementiert werden. Der Unterstrich ist als Trennzeichen zwischen Interface-/Objektname und dem Namen des implementierten Members definiert. Ein Unterstrich im Elementnamen verwirrt den Compiler, der eine Übersetzung des Projektes dann verweigert. Die 'PascalCase'-Namenskonvention erlaubt, Unterstriche in Elementnamen zu vermeiden.</value>
  </data>
  <data name="ExcelMemberMayReturnNothingInspection" xml:space="preserve">
    <value>Eine Prozedur, die ein Objekt zurückgibt, kann 'Nothing' zurückgeben. Dies wird bei darauffolgenden Elementzugriff zum Laufzeitfehler 91 - 'Objektblockvariable oder With-Blockvariable nicht festgelegt' führen. Prüfen sie mit 'Is Nothing' nach dem 'Set', um einen Laufzeitfehler auszuschließen.</value>
  </data>
  <data name="ExcelUdfNameIsValidCellReferenceInspection" xml:space="preserve">
    <value>Funktionen, die für EXCEL als benutzerdefinierte Funktionen sichtbar sind, werden einen '#REF!'-Fehler erzeugen, wenn sie in einem Arbeitsblatt verwendet werden, in dem ihr Name dem einer korrekten Zellreferenz entspricht. Wenn die Funktion als benutzerdefinierte Funktion gedacht ist, muss sie umbenannt werden. Wenn die Funktion nicht als benutzerdefinierte Funktion gedacht ist, sollte sie 'Private' deklariert oder aus einem Standardmodul herausgenommen werden.</value>
  </data>
  <data name="AttributeValueOutOfSyncInspection" xml:space="preserve">
    <value>Eine Rubberduck-Annotation wurde für ein Modul oder Element festgelegt, aber das zugehörige Attribut hat einen anderen Wert. Die Modul-Attribute und Annotationen sollten synchronisiert werden.</value>
  </data>
  <data name="MissingMemberAnnotationInspection" xml:space="preserve">
    <value>Elementattribute werden von der VBE nicht angezeigt. Durch das hinzufügen einer Annotation werden diese Attribute deutlicher. Außerdem kann Rubberduck die Annotationen und Attribute synchronisieren.</value>
  </data>
  <data name="MissingModuleAnnotationInspection" xml:space="preserve">
    <value>Modulattribute werden von der VBE nicht angezeigt. Durch das hinzufügen einer Annotation werden diese Attribute deutlicher. Außerdem kann Rubberduck die Annotationen und Attribute synchronisieren.</value>
  </data>
  <data name="KeywordsUsedAsMemberInspection" xml:space="preserve">
    <value>Ein Schlüsselwort wird als Name eines Elements einer Aufzählung oder eines benutzerdefinierten Typs verwendet. Dies kann zu Problemen bei der Auflösung von Referenzen auf das Element führen. Sie sollten in Betracht ziehen den Namen zu ändern.</value>
  </data>
  <data name="LineContinuationBetweenKeywordsInspection" xml:space="preserve">
    <value>Es befinden sich Zeilenfortsetzungszeichen zwischen Schlüsselwörtern. Dafür gibt es keinen guten Grund. Sie sollten in Betracht ziehen sie zu entfernen.</value>
  </data>
  <data name="NonBreakingSpaceIdentifierInspection" xml:space="preserve">
    <value>Der Bezeichner enthält ein geschütztes Leerzeichen, welches wie eine gewöhnliches Leerzeichen aussieht (nicht zulässig in Bezeichnern). Das macht es schwerer den Programmcode zu lesen. Sie sollten in Betracht ziehen stattdessen sichtbare Zeichen zu verwenden.</value>
  </data>
  <data name="NegativeLineNumberInspection" xml:space="preserve">
    <value>Negative Zeilennummern können nur als Hexadezimalzahlen eingegeben werden, welche der VBE in Dezimalzahlen umwandelt. Wird die Programmzeile erneut bearbeitet, macht die negative Zeilennummer die Zeile ungültig.</value>
  </data>
  <data name="OnErrorGoToMinusOneInspection" xml:space="preserve">
    <value>Hierbei handelt es sich um ein schlecht dokumentiertes Feature: Im Normallfall wird der Fehlerspeicher geleert und jegliche Fehlerbehandlung deaktiviert. Sollte allerdings -1 als Zeilennummer vorhanden sein, kann diese als Marker der zu verwendenden Fehlerbehandlung interpretiert werden.</value>
  </data>
  <data name="ObsoleteWhileWendStatementInspection" xml:space="preserve">
    <value>'While...Wend'-Schleifen sind aus Gründen der Abwärtskompatibilität vorhanden und wurden durch die Einführung von 'Do While...Loop'-Blöcken ersetzt, die die 'Exit Do'-Exit-Anweisung unterstützen. 'While...Wend'-Schleifen können nur beendet werden, wenn die 'While'-Bedingung erfüllt ist.</value>
  </data>
  <data name="SetAssignmentWithIncompatibleObjectTypeInspection" xml:space="preserve">
    <value>Der VBA-Compiler gibt keinen Fehler aus, wenn ein Objekt einer Variables Set-zugewiesen wird mit einem inkompatiblen Objekttype, d.h. deren Typ weder identisch, ein Subtyp noch ein Supertyp ist. In fast allen Fällen führt dies zu einem Laufzeitfehler, der schwerer zu entdecken ist und auf einen Programmierfehler hinweist. In allen anderen Fällen kann der Quallcode so geändert werden, dass er ausschließlich Zuweisungen zwischen kompatiblen deklarierten Typen verwendet.</value>
  </data>
  <data name="ArgumentWithIncompatibleObjectTypeInspection" xml:space="preserve">
    <value>Der VBA-Compiler gibt keinen Fehler aus, wenn ein Objekt als Argument für einen Parameter mit einem inkompatiblen Objekttyp übergeben wird, d.h. dessen Typ weder identisch, ein Subtyp, noch ein Supertyp ist. In fast allen Fällen führt dies zu einem Laufzeitfehler, der schwer zu entdecken ist und auf einen Programmierfehler hinweist. In allen anderen Fällen kann der Quellcode so geändert werden, dass ausschließlich Argumente mit kompatiblen deklarierten Typen verwendet werden.</value>
  </data>
  <data name="EmptyMethodInspection" xml:space="preserve">
    <value>Methoden ohne ausführbare Anweisungen können den Eindruck erwecken, dass sie etwas tun, was sie eigentlich nicht tun. Dies kann zu unerwartetem Verhalten führen.</value>
  </data>
  <data name="ImplementedInterfaceMemberInspection" xml:space="preserve">
    <value>Eine Klasse, die dafür gedacht ist von anderen Klassen als Interface genutzt zu werden, sollte gewöhnlicher Weise keine Implementierungen enthalten. Falls die Intention ist diese Klasse direkt als konkrete Klasse zu verwenden, kann dieses Inspektionsresultat ignoriert werden.</value>
  </data>
  <data name="ValueRequiredInspection" xml:space="preserve">
    <value>Der VBA-Compiler gibt keinen Fehler aus, wenn ein Objekt an einer Stelle verwendet wird, die einen Wert verlangt, und der deklarierte Type des Objekts keinen passendes Standardelement hat. In fast allen Fällen führt dies zu einem Laufzeitfehler 91 'Objektvariable oder With-Blockvariable nicht festgelegt' oder 438 'Objekt unterstützt diese Eigenschaft oder Methode nicht' abhängig davon, ob die Variable den Wert 'Nothing' hat oder nicht, der schwerer zu entdecken ist und auf einen Programmierfehler hinweist.</value>
  </data>
  <data name="ProcedureRequiredInspection" xml:space="preserve">
    <value>Der VBA-Compiler gibt keinen Fehler aus, wenn eine Objektvariable an einer Stelle verwendet wird, die eine Prozedur erfordert, und der deklarierte Type des Objekts kein passendes Standardelement hat. In fast allen Fällen führt dies zu einem Laufzeitfehler 91 'Objektvariable oder With-Blockvariable nicht festgelegt' oder 438 'Objekt unterstützt diese Eigenschaft oder Methode nicht' abhängig davon, ob die Variable den Wert 'Nothing' hat oder nicht, der schwerer zu entdecken ist und auf einen Programmierfehler hinweist.</value>
  </data>
  <data name="DefaultMemberRequiredInspection" xml:space="preserve">
    <value>Der VBA-Compiler gibt keinen Fehler aus, wenn ein Standardelementzugriff nötig ist, aber der der deklarierte Type des Objekts kein passendes Standardelement hat. In fast allen Fällen führt dies zu einem Laufzeitfehler 91 'Objektvariable oder With-Blockvariable nicht festgelegt' oder 438 'Objekt unterstützt diese Eigenschaft oder Methode nicht' abhängig davon, ob die Variable den Wert 'Nothing' hat oder nicht, der schwerer zu entdecken ist und auf einen Programmierfehler hinweist.</value>
  </data>
  <data name="UseOfBangNotationInspection" xml:space="preserve">
    <value>Die Ausrufezeichennotation erweckt den Eindruck, dass es sich um einen Zugriff handelt, der Typchecks unterliegt. Allerdings handelt es sich lediglich um einen Zugriff auf den Standardmember des Objekts, auf das sie angewendet wird, bei dem das Argument als Zeichenkette übergeben wird.</value>
  </data>
  <data name="UseOfRecursiveBangNotationInspection" xml:space="preserve">
    <value>Die Ausrufezeichennotation erweckt den Eindruck, dass es sich um einen Zugriff handelt, der Typprüfungen unterliegt. Allerdings handelt es sich lediglich um einen Zugriff auf das Standardelement des Objekts, auf das sie angewendet wird, bei dem das Argument als Zeichenkette übergeben wird. Dies ist besonders verwirrend, wenn das Standardelement des Objekts selber keine Zeichenkette akzeptiert und deshalb ein rekursiver Zugriff auf das parameterlose Standardelement erfolgen muss.</value>
  </data>
  <data name="UseOfUnboundBangNotationInspection" xml:space="preserve">
    <value>Die Ausrufezeichennotation erweckt den Eindruck, dass es sich um einen Zugriff handelt, der Typchecks unterliegt. Allerdings handelt es sich lediglich um einen Zugriff auf das Standardelement des Objekts, auf das sie angewendet wird, bei dem das Argument als Zeichenkette übergeben wird. Dies ist besonders verwirrend, wenn das Standardelement nicht zum Zeitpunkt des Kompilierens ermittelt werden kann.</value>
  </data>
  <data name="ObjectWhereProcedureIsRequiredInspection" xml:space="preserve">
    <value>Wenn ein Objekt mit einem Standardelement an einer Stelle verwendet wird, die nach einer Prozedur verlangt, wird implizit das Standardelement aufgerufen. Die ist wahrscheinlich nicht beabsichtigt und mindert die Lesbarkeit des Programms.</value>
  </data>
  <data name="IndexedDefaultMemberAccessInspection" xml:space="preserve">
    <value>Zugriffe auf Standardelemente verstecken, welches Element aufgerufen wird. Auch wenn im Fall eines paramtrisierten Zugriffs ersichtlich ist, dass ein Zugriff erfolgt, so ist es in der Regel für die Lesbarkeit zuträglich, explizit zu sein.</value>
  </data>
  <data name="IndexedRecursiveDefaultMemberAccessInspection" xml:space="preserve">
    <value>Zugriffe auf Standardelemente verstecken, welches Element aufgerufen wird. Auch wenn im Fall eines paramtrisierten Zugriffs ersichtlich ist, dass ein Zugriff erfolgt, so ist es in der Regel für die Lesbarkeit zuträglich explizit zu sein. Dies trifft besonders zu, wenn das Standardelement nicht auf dem Interface des Objekts selber zu finden ist uns stattdessen mittels einer Kette von Standardelementzugriffen erreicht werden muss.</value>
  </data>
  <data name="IndexedUnboundDefaultMemberAccessInspection" xml:space="preserve">
    <value>Zugriffe auf Standardelemente verstecken, welches Element aufgerufen wird. Auch wenn im Fall eines paramtrisierten Zugriffs ersichtlich ist, dass ein Zugriff erfolgt, so ist es in der Regel für die Lesbarkeit zuträglich explizit zu sein. Dies trifft insbesondere zu, wenn das Standardelement erst zur Laufzeit ermittelt werden kann. Sollte dann kein passendes Standardelement existieren, kommt es zu einem Fehler 438 'Objekt unterstützt diese Eigenschaft oder Methode nicht'.</value>
  </data>
  <data name="ImplicitDefaultMemberAccessInspection" xml:space="preserve">
    <value>Zugriffe auf Standardelemente verstecken, welches Element aufgerufen wird. Dies ist besonders verwirrend, wenn in dem Ausdruck selber keine Indikation vorhanden ist, dass ein solcher Zugriff erfolgt. Dies kann dazu führen, dass Fehler durch vergessene Elementaufrufe nicht erkannt werden.</value>
  </data>
  <data name="ImplicitRecursiveDefaultMemberAccessInspection" xml:space="preserve">
    <value>Zugriffe auf das Standardelement verstecken, welches Element aufgerufen wird. Dies ist besonders verwirrend, wenn in dem Ausdruck selber keine Indikation vorhanden ist, dass ein solcher Zugriff erfolgt, und zudem das Standardelement nicht auf dem Interface des Objekts selber zu finden ist. Dies kann dazu führen, dass Fehler durch vergessene Elementaufrufe nicht erkannt werden.</value>
  </data>
  <data name="ImplicitUnboundDefaultMemberAccessInspection" xml:space="preserve">
    <value>Zugriffe auf das Standardelemente verstecken, welches Element aufgerufen wird. Dies ist besonders verwirrend, wenn in dem Ausdruck selber keine Indikation vorhanden ist, dass ein solcher Zugriff erfolgt, und zudem das Standardelement erst zur Laufzeit ermittelt werden kann. Dies kann dazu führen, dass Fehler durch vergessene Elementaufrufe nicht erkannt werden. Sollte weiterhin zur Laufzeit kein Standardelement auf dem Objekt existsieren, so kommt es zu einem Fehler 438 'Objekt unterstützt diese Eigenschaft oder Methode nicht'.</value>
  </data>
  <data name="SuspiciousLetAssignmentInspection" xml:space="preserve">
    <value>Wenn beide Seiten einer Zuweisung ohne Set Objekte sind, kommt es zu einer Zuweisung vom Standardelement der rechten Seite zu dem der linken. Auch wenn dies manchmal beabsichtigt sein kann, verschleiert es meistens, dass Set fehlerhafter Weise vergessen wurde.</value>
  </data>
  <data name="UnreachableCaseInspection" xml:space="preserve">
    <value>Eine Bedingung in einem Case-Ausdruck ist entweder nie erfüllt, verursacht einen Laufzeitfehler oder kann nicht erfüllt werden, da die vorherigen Case-Ausdrücke bereits alle zulässigen Werte abdecken. Infolgedessen wird der Code in dem Case-Zweig nie ausgeführt und stellt "toten Code" dar oder der Case-Ausdruck stellt sogar einen Laufzeitfehler dar, der nur darauf wartet irgendwann aufzutreten. Der Case-Zweig sollte entweder gelöscht, verändert oder an eine andere Stelle verschoben werden.</value>
  </data>
  <data name="FunctionReturnValueDiscardedInspection" xml:space="preserve">
    <value>Der Rückgabewert einer Funktion wird verworfen, d.h. die Funktion wird wie eine Prozedur verwendet. Dies ist entweder ein Versäumnis oder die Funktion wird wegen ihrer Nebenwirkungen verwendet, deren Existenz in der Regel selber problematisch wäre.</value>
  </data>
  <data name="ImplicitlyTypedConstInspection" xml:space="preserve">
    <value>Wird keine Typdeklaration verwendet wird der Datentyp einer Konstante implizit bestimmt. Erwägen Sie eine explizite 'As &lt;Datentyp&gt;'-Deklaration zu verwenden um die Lesbarkeit zu verbessern, wobei '&lt;Datentyp&gt;' der erwünschte Datentyp der Konstante ist.</value>
  </data>
  <data name="SuperfluousAnnotationArgumentInspection" xml:space="preserve">
    <value>Eine Annotation hat mehr Argumente als erlaubt. Die überzähligen Argumente werden ignoriert.</value>
  </data>
  <data name="ImplicitContainingWorkbookReferenceInspection" xml:space="preserve">
    <value>Implizite Referenzen zu Elementen eines Workbooks in einem Workbook-Modul können mit Referenzen zum aktiven Workbook verwechselt werden, da dies das Verhalten für solche Referenzen ist überall außerhalb von Workbook-Modulen. Die Uneindeutigkeit kann aufgelöst werden, indem die Referenzen mit 'Me' qualifiziert werden. Sollte eine Referenz zum aktiven Workbook beabsichtigt gewesen sein, sollte der Elementzugriff explizit mit 'ActiveWorkbook' qualifiziert werden.</value>
  </data>
  <data name="ImplicitContainingWorksheetReferenceInspection" xml:space="preserve">
    <value>Implizite Referenzen zu Elementen eines Worksheets in einem Worksheet-Modul können mit Referenzen zum aktiven Worksheet verwechselt werden, da dies das Verhalten für solche Referenzen ist überall außerhalb von Worksheet-Modulen. Die Uneindeutigkeit kann aufgelöst werden, indem die Referenzen mit 'Me' qualifiziert werden. Sollte eine Referenz zum aktiven Worksheet beabsichtigt gewesen sein, sollte der Elementzugriff explizit mit 'ActiveSheet' qualifiziert werden.</value>
  </data>
  <data name="MisleadingByRefParameterInspection" xml:space="preserve">
    <value>Der letzte Parameter (der 'Wert'-Parameter) der Eigenschaftsmutation wird immer als ByVal übergeben. Dies gilt unabhänig der An- oder Abwesenheit eines ByRef oder ByVal Modifizieres. Ausnahme: Ein nutzerdefinierter Type (UserDefinedType) muss immer als ByRef übergeben werden, auch wenn er der letzte Parameter einer Eigenschaftmutation ist.</value>
  </data>
  <data name="UnrecognizedAnnotationInspection" xml:space="preserve">
    <value>Ein Kommentar wurde als eine syntaktisch zulässige Annotation erkannt, doch kein unterstützter Annotationstyp konnte erkannt werden.</value>
  </data>
  <data name="AnnotationInIncompatibleComponentTypeInspection" xml:space="preserve">
    <value>Eine Annotation wurde in einer Komponente mit einem zu dieser inkompatiblen Typ verwendet. Manche Annotationen können nur in Komponenten eines spezifischen Typs verwendet werden, andere wiederum nicht in Komponenten bestimmter Typen.</value>
  </data>
  <data name="InvalidAnnotationInspection" xml:space="preserve">
    <value>Die Annotation konnte keinem Ziel zugewiesen werden. Eine Annotation für die Modulebene kann nicht verwendet werden, um Elemente zu annotieren. Eine Annotation für Elemente kann auf Modulebene nicht verwendet werden. Modul- und Elementannotationen sollten nur einmal spezifiziert werden.</value>
  </data>
  <data name="UDTMemberNotUsedInspection" xml:space="preserve">
    <value>Ein UDT (User Defined Type) Element ist deklariert, das allerdings nicht verwendet wird. Es sollte überlegt werden, die Deklaration des UDT Elementes zu löschen.</value>
  </data>
  <data name="PublicImplementationShouldBePrivateInspection" xml:space="preserve">
    <value>Das Standard (Public) Interface einer Modul-Klasse sollte nicht die Implementierung anderer Interfaces oder Ereignishandler offenlegen.</value>
  </data>
  <data name="PublicEnumerationDeclaredInWorksheetInspection" xml:space="preserve">
    <value>Das Kopieren eines Arbeitsblattes, das eine öffentliche Enumerationsdeklartion enthält, wird auch eine Kopie der Enumerationsdeklaration anlegen. Diese Kopie wird einen 'Ambiguous name detected'-Kompiler-Fehler auslösen. Die Deklaration von Enumerationen in Standard- oder Klassenmodulen vermeidet ungewollte Duplikate einer Enumerationsdeklaration.</value>
  </data>
  <data name="PublicControlFieldAccessInspection" xml:space="preserve">
    <value>MS Forms legt UserForms-Steuerelemente als öffentliche Felder an. Der Zugriff auf diese Felder außerhalb der UserForm-Klasse bricht die Kapselung und verursacht unnötigen Code mit speziellen Formularsteuerelementen. Überlege, die gewünschten Werte in eigene 'Modell-Klassen' zu kapseln und Ereignishandler innerhalb des Formulars zu verwenden, um diese 'Modelleigenschaften' zu ändern. Der Code kann dann die gekapselten Werte anfragen anstatt der Formularsteuerelemente.</value>
  </data>
  <data name="SuspiciousPredeclaredInstanceAccessInspection" xml:space="preserve">
    <value>Obwohl eine zustandsorientierte (stateful) Standardinstanz eventuell gewünscht ist, ist diese eine beliebte Quelle von Fehlern und sollte vermieden werden. Nutze die 'Me'-Auszeichnung, um die aktuelle Instanz explizit anzusprechen und Zweideutigkeiten zu vermeiden.</value>
  </data>
  <data name="ReadOnlyPropertyAssignmentInspection" xml:space="preserve">
    <value>Normalerweise fängt der VBE Editor diesen Fehlertyp und bricht das Kompilieren ab. Allerdings gibt es einige wenige Szenarien, in denen dieser Fehler übergangen und ein Laufzeitfehler ausgelöst wird. Um den Laufzeitfehler zu vermeiden, sollte die fehlende Property oder Subroutine implementiert werden.</value>
  </data>
  <data name="IIfSideEffectInspection" xml:space="preserve">
    <value>Alle Argumente eines Funktions-/Prozeduraufrufes werden immer evaluiert, bevor die Funktion aufgerufen wird, so dass ihre Werte als Parameter übergeben werden. Allerdings führt die 'IIf'-Funktion manchmal zu einer Fehlinterpretation, dass entweder nur der 'Wahr-Teil' oder nur der 'Falsch-Teil' auf der Basis des ersten Argumentes ausgewertet wird. Somit kann die 'IIf'-Funktion eine Quelle von unvorhergesehen Nebeneffekten und Fehlern sein, wenn der Nutzer den Umstand nicht vor Augen hat, dass immer beide Argumente, 'Wahr-Teil' und 'Falsch-Teil', ausgewertet werden.</value>
  </data>
</root>