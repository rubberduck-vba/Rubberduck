<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AssignedByValParameterInspection" xml:space="preserve">
    <value>Parameter wird als Wert übergeben, aber überschrieben. Eine Lokale Kopie verdeutlicht, dass die Aufrufende den neuen Wert nicht kennen soll. Falls die Aufrufende den neuen Wert kennen soll, müsste der Parameter 'ByRef' übergeben werden und dies ist ein Bug.</value>
  </data>
  <data name="ConstantNotUsedInspection" xml:space="preserve">
    <value>Rubberduck konnte keine Referenz auf eine Konstante finden. Überlegen Sie eine Entfernung der nicht verwendeten Deklaration.</value>
  </data>
  <data name="DefaultProjectNameInspection" xml:space="preserve">
    <value>Erwäge Sie dem VBA-Projekt einen Namen zu geben.</value>
  </data>
  <data name="EmptyStringLiteralInspection" xml:space="preserve">
    <value>Die eingebaute Konstante 'vbNullString' ist ein Null-String Zeiger, der 0 bytes Arbeitsspeicher benötigt. Dies ist das beabsichtigte Verhalten eines leeren Strings.</value>
  </data>
  <data name="EncapsulatePublicFieldInspection" xml:space="preserve">
    <value>Erwägen Sie stattdessen, eine Eigenschaft verfügbar zu machen.</value>
  </data>
  <data name="ImplicitActiveSheetReferenceInspection" xml:space="preserve">
    <value>Implizite Referenzen zum aktuellen Tabellenblatt macht den Code anfällig und schwieriger zu debuggen. Erwäge die Referenz explizit anzugeben oder vorzugsweise mit Objektreferenzen zu arbeiten. Ignoriere wenn der Methodenaufruf sich auf einen Typ bezieht, den Rubberduck nicht auflösen kann.</value>
  </data>
  <data name="ImplicitActiveWorkbookReferenceInspection" xml:space="preserve">
    <value>Implizite Referenzen zur aktuellen Arbeitsmappe macht den Code anfällig und schwieriger zu debuggen. Erwäge die Referenz explizit anzugeben oder vorzugsweise mit Objektreferenzen zu arbeiten. Ignoriere wenn der Methodenaufruf sich auf einen Typ bezieht, den Rubberduck nicht auflösen kann.</value>
  </data>
  <data name="ImplicitPublicMemberInspection" xml:space="preserve">
    <value>Die Methoden eines Moduls sind standardmäßig öffentlich, was irreführend sein kann. Besser ist es, den Gültigkeitsbereich der Methoden explizit zu definieren.</value>
  </data>
  <data name="ImplicitVariantReturnTypeInspection" xml:space="preserve">
    <value>Methoden mit einem Rückgabewert geben, wenn nicht anders angegeben, implizit 'Variant' zurück. Überlege, ob es nicht besser ist, den Rückgabewert explizit als 'Variant' zu definieren, wenn der Typ des Rückgabewertes nicht bekannt ist.</value>
  </data>
  <data name="MoveFieldCloserToUsageInspection" xml:space="preserve">
    <value>Eine Variable, die im Modulkopf deklariert wurde aber nur in einer Prozedur verwendet wird, sollte in der Prozedur deklariert werden.</value>
  </data>
  <data name="MultilineParameterInspection" xml:space="preserve">
    <value>Überlege lange Parameterdeklarationen zusammenzuhalten. Das Aufteilen einer Parameterdeklaration über mehrere Zeilen sollte zugunsten der besseren Lesbarkeit vermieden werden.</value>
  </data>
  <data name="MultipleDeclarationsInspection" xml:space="preserve">
    <value>Die Deklaration von mehren Variablen in der gleichen Codezeile ist erlaubt, sollte aber sparsam eingesetzt werden. Erwäge die Variablendeklartion in der Nähe der Nutzung als separate Anweisung pro Deklaration.</value>
  </data>
  <data name="NonReturningFunctionInspection" xml:space="preserve">
    <value>Hier könnte ein Fehler vorliegen. Der Rückgabewert einer Funktion oder Eigenschaft wird nicht zugewiesen. Dies kann zu unvorhersehbaren Verhalten des Codes führen. Wenn die Funktion keinen sinnvollen Rückgabewert hat, sollte sie in eine 'Sub'-Routine umgeschrieben werden.</value>
  </data>
  <data name="ObsoleteCallStatementInspection" xml:space="preserve">
    <value>Die 'Call'-Anweisung ist nicht mehr zum Aufruf einer Anweisung notwendig. Sie existiert aus Gründen der Abwärtskompatibilität. Sie kann problemlos durch einen impliziten Anweisungsaufruf ersetzt werden.</value>
  </data>
  <data name="ObsoleteCommentSyntaxInspection" xml:space="preserve">
    <value>Die 'REM'-Anweisung existiert aus Gründen der Abwärtskompatibilität. Sie kann gefahrlos durch ein einfaches Anführungszeichen ersetzt werden.</value>
  </data>
  <data name="ObsoleteGlobalInspection" xml:space="preserve">
    <value>Das Schlüsselwort 'Global' existiert aus Gründen der Abwärtskompatibilität. Es kann gefahrlos durch 'Public' ersetzt werden.</value>
  </data>
  <data name="ObsoleteLetStatementInspection" xml:space="preserve">
    <value>Die 'Let'-Anweisung  existiert aus Gründen der Abwärtskompatibilität. Sie kann gefahrlos entfernt werden, da das moderne VBA dieses Schlüsselwort nicht mehr zur Werte-Zuweisung benötigt.</value>
  </data>
  <data name="ObsoleteTypeHintInspection" xml:space="preserve">
    <value>Die Verwendung der Typ-Buchstaben (z.B. $)  existiert aus Gründen der Abwärtskompatibilität. Sie kann gefahrlos durch eine 'As'-Typdeklaration ersetzt werden.</value>
  </data>
  <data name="OptionBaseInspection" xml:space="preserve">
    <value>Arrays sind normalerweise null-basiert. Diese Option ändert die untere Standardgrenze für impliziert erzeugte Arrays. Dies kann einen 'off-by-one' Fehler erzeugen, wenn sie nicht sorgsam eingesetzt wird.</value>
  </data>
  <data name="OptionExplicitInspection" xml:space="preserve">
    <value>VBA kompiliert ohne ohne 'Option Explicit` auch Tippfehlern erfolgreich: Verwenden Sie 'Option Explicit', um zu verhindern, dass ein fehlerhaftes Programm erfolgreich kompiliert wird.</value>
  </data>
  <data name="ParameterCanBeByValInspection" xml:space="preserve">
    <value>Ein Parameter der als Referenz übergeben wird, aber keine neue Wert- oder Referenzzuweisung erhält, sollte als Wert übergeben werden.</value>
  </data>
  <data name="ParameterNotUsedInspection" xml:space="preserve">
    <value>Ein Parameter, der der Methode übergeben wird, wird nicht verwendet. Erwäge diesen zu entfernen.</value>
  </data>
  <data name="ProcedureNotUsedInspection" xml:space="preserve">
    <value>Rubberduck kann keinen Aufruf für die Prozedur finden. Falls diese über eine Markro-Schaltfläche, als benutzerdefinierte Funktion oder als Event-Handler genutzt wird, den Rubberduck nicht kennt, kann dieser Hinweis ignoriert werden. Ansonsten sollte sie entfernt werden.</value>
  </data>
  <data name="UnassignedVariableUsageInspection" xml:space="preserve">
    <value>Hier könnte ein Fehler vorliegen. Eine Variable wird referenziert aber ihr wird kein Wert zugewiesen.</value>
  </data>
  <data name="UntypedFunctionUsageInspection" xml:space="preserve">
    <value>Es gibt eine äquivalente Funktion, die einen String zurückgibt. Diese sollte bevorzugt genutzt werden, um implitizite Typumwandlungen zu vermeiden.
Falls der Parameter 'null' sein kann, bitte dieses Auftreten ignorieren. 'null' an die Funktion zu übergeben, die einen String erwartet würde zu einem "Type Mismatch"-Laufzeitfehler führen.</value>
  </data>
  <data name="UseMeaningfulNameInspection" xml:space="preserve">
    <value>Bezeicher sollten lesbar sein und ihren Verwendungszweck widerspiegeln. Bezeichner ohne Vokale, mit nummerischem Suffix oder nur 1-2 Buchstaben sollten vermieden werden.</value>
  </data>
  <data name="VariableNotAssignedInspection" xml:space="preserve">
    <value>Einer Variable wird kein Wert zugewiesen. Falls das nicht beabsichtigt ist, kann das zu einem Fehler führen. Ignorieren Sie diese Warnung, falls die Variable in einer anderen Prozedur durch einen 'ByRef'-Parameter zugewiesen wird.</value>
  </data>
  <data name="VariableNotUsedInspection" xml:space="preserve">
    <value>Variable wird nicht gelesen</value>
  </data>
  <data name="VariableTypeNotDeclaredInspection" xml:space="preserve">
    <value>Variable, deren Typ nicht explizit deklariert wurde, erhält implizit den Typ 'Variant'. Überlege die Variable explizit als 'Variant' zu definieren oder eine besseren Typ zu zuweisen.</value>
  </data>
  <data name="WriteOnlyPropertyInspection" xml:space="preserve">
    <value>Eine Eigenschaft, die eine Änderungsfunktion, aber keine Zugriffsfunktion bereitstellt, führt zu einer unklaren API. Enweder erstelle einen öffentlichen getter oder ändere die Änderungsfunktion in eine Methode ab.</value>
  </data>
  <data name="ProcedureCanBeWrittenAsFunctionInspection" xml:space="preserve">
    <value>Eine Prozedur, die nur einen Parameter als Referenz übergibt, der vor dem Verlassen der Prozedur einen neuen Wert oder Referenz erhält, sollte als Funktion umgeschrieben werden.</value>
  </data>
  <data name="SelfAssignedDeclarationInspection" xml:space="preserve">
    <value>Eine selbstzugewiesene Objektvariablendeklaration in einer Prozedur kann das Verhalten beim Nulling verändern. Dies kann zu unvorhergesehen Verhalten des Codes führen.</value>
  </data>
  <data name="ObjectVariableNotSetInspection" xml:space="preserve">
    <value>Rubberduck hat festgestellt, dass die Variable eine Objektvariable ist, die ohne 'Set'-Schlüsselwort zugewiesen wird. Dies führt zu dem Laufzeitfehler 91 'Objektvariable oder With-Blockvariable nicht festgelegt' oder 438 'Objekt unterstützt diese Eigenschaft oder Methode nicht' abhängig davon, ob die Variable den Wert 'Nothing' hat oder nicht.</value>
  </data>
  <data name="MissingAnnotationArgumentInspection" xml:space="preserve">
    <value>Eine Annotation in einem Kommentar konnte nicht gelesen werden. Die korrekte Syntax ist: '@Annotation([parameter])'\nBeispiel: '@Folder("Parent.Child")'</value>
  </data>
  <data name="UndeclaredVariableInspection" xml:space="preserve">
    <value>Code, der undeklarierte Variablen verwendet, kompiliert nicht wenn 'Option Explicit' spezifiziert wird. Undeklarierte Variablen sind immer vom Typ 'Variant', was unnötige Zusatzkosten in Ausführungszeit und Speicherverbauch verursacht.</value>
  </data>
  <data name="ModuleScopeDimKeywordInspection" xml:space="preserve">
    <value>Das Schlüsselwort 'Public' kann nur auf Modulebene verwendet werden; Sein Konterpart 'Private' kann auch nur auf Modulebene verwendet werden. 'Dim' jedoch kann verwendet werden, um sowohl modulweite als auch prozedurweite Variablen zu deklarieren. Um der Konsistenz Willen ist es besser, 'Dim' nur für lokale Variablen zu verwenden, also 'Private' statt 'Dim' auf Modulebene zu verwenden.</value>
  </data>
  <data name="FunctionReturnValueNotUsedInspection" xml:space="preserve">
    <value>Ein Member ist als Funktion geschrieben, aber wird wie eine Prozedur verwendet. Falls die Funktion nicht rekursiv ist, sollten Sie in Erwägung ziehen, die 'Function' in ein 'Sub' zu konvertieren. Falls die Funktion rekursiv ist, verwendet keiner der externen Aufrufer den Rückgabewert.</value>
  </data>
  <data name="MemberNotOnInterfaceInspection" xml:space="preserve">
    <value>Es wird ein Memberzugriff verwendet, der vom Interface des Objektes nicht deklariert wird. Dies ist höchstwahrscheinlich ein Fehler. Falls der Memberzugriff das erweiterbare Interface des Objektes verwendet, erwägen Sie ein nicht erweiterbares Äquivalent zu verwenden um Prüfungen zur Kompilierzeit zu ermöglichen und das Auftreten von Laufzeitfehler 438 zu verhindern.</value>
  </data>
  <data name="HungarianNotationInspection" xml:space="preserve">
    <value>'Ungarische Notation' macht Code weniger lesbar und ist redundant, sobald stark typisierte Variablen und aussagekräftige Namen verwendet werden.</value>
  </data>
  <data name="ApplicationWorksheetFunctionInspection" xml:space="preserve">
    <value>Das Excel Application-Objekt implementiert das WorksheetFunction interface direkt. Alle Aufrufe an WorksheetFunction-Member werden als laufzeitgebunden behandelt und Fehler im aufgerufenen Member werden in ein Variant des Typs VbVarType.Error gekapselt. Dadurch können Fehler nicht mit Fehleranweisungen behandelt werden und gegenüber skriptzeitgebundenen Aufrufen sinkt die Performanz. Ziehen Sie in Erwägung Application.WorksheetFunction explizit aufzurufen. Bedenken Sie: Falls dieser Aufruf in der Vergangenheit Fehler erzeugt hat, wurden diese ignoriert. Es sollte eine Fehlerbehandlung vorhanden sein, bevor Sie die schnelle Korrektur anwenden.</value>
  </data>
  <data name="HostSpecificExpressionInspection" xml:space="preserve">
    <value>Geklammerte Ausdrücke werden von der Hostanwendung zur Laufzeit ausgewertet, was bedeutet, dass VBA den Ausdruck nicht zur Kompilierzeit validieren kann. Erwägen sie, das hostspezifische Objektmodell zu verwenden.</value>
  </data>
  <data name="OptionBaseZeroInspection" xml:space="preserve">
    <value>Dies ist die Standardeinstellung, sie muss nicht spezifiziert werden.</value>
  </data>
  <data name="IllegalAnnotationInspection" xml:space="preserve">
    <value>Eine Annotation für die Modulebene kann nicht verwendet werden, um Elemente zu annotieren; Eine Annotation für Elemente kann auf Modulebene nicht verwendet werden; Modul- und Elementannotationen sollten nur einmal spezifiziert werden.</value>
  </data>
  <data name="RedundantOptionInspection" xml:space="preserve">
    <value>Da dies die Standardeinstellung für diese Option ist, kann die Anweisung ohne Nebeneffekte entfernt werden.</value>
  </data>
  <data name="RedundantByRefModifierInspection" xml:space="preserve">
    <value>Alle Parameter werden, falls nicht anders spezifiziert als Referenz übergeben. Es ist also nicht nötig, die 'ByRef'-Markierung zu verwenden.</value>
  </data>
  <data name="ImplicitByRefModifierInspection" xml:space="preserve">
    <value>Parameter werden, falls nicht anders spezifiziert, als Referenz übergeben. Dies kann verwirrend sein und Bugs hervorrufen. Bevorzugen Sie die Übergabe von Parametern als Werte und spezifizieren Sie eine Referenzübergabe explizit als ByRef.</value>
  </data>
  <data name="MissingAttributeInspection" xml:space="preserve">
    <value>Eine Rubberduck-Annotation wurde für ein Modul oder Element festgelegt, aber das zugehörige Attribut fehlt. Die Modul-Attribute und Annotationen sollten synchronisiert werden.</value>
  </data>
  <data name="EmptyIfBlockInspection" xml:space="preserve">
    <value>Ein leerer 'If'-Block ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="LineLabelNotUsedInspection" xml:space="preserve">
    <value>Rubberduck konnte keine Resume oder GoTo Anweisung zu einer Zeilenbezeichnung finden. Erwägen Sie eine Entfernung der Bezeichnung.</value>
  </data>
  <data name="EmptyForLoopBlockInspection" xml:space="preserve">
    <value>Eine leere 'For…Next'-Schleife ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="ShadowedDeclarationInspection" xml:space="preserve">
    <value>Zwei Deklarationen sind aktiv und haben denselben Namen. Dies bedeutet, dass nur eine von ihnen zur Verwendung verfügbar ist.</value>
  </data>
  <data name="StopKeywordInspection" xml:space="preserve">
    <value>Das Schlüsselwort 'Stop' unterbricht die Ausführung und ruft den Debugger auf. Vermeiden Sie die Verwendung in verteiltem Code.</value>
  </data>
  <data name="EmptyCaseBlockInspection" xml:space="preserve">
    <value>Ein leerer 'Case'-Block ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="EmptyForEachBlockInspection" xml:space="preserve">
    <value>Eine leere 'For Each…Next'-Schleife ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="EmptyElseBlockInspection" xml:space="preserve">
    <value>Ein leerer 'Else'-Block ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="EmptyWhileWendBlockInspection" xml:space="preserve">
    <value>Eine leere 'While…Wend'-Schleife ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="ObsoleteErrorSyntaxInspection" xml:space="preserve">
    <value>Die 'Error'-Anweisung existiert in der Sprache nur um Legacy-Programme zu unterstützen, die sie benötigten; Bevorzugen Sie stattdessen 'Err.Raise'.</value>
  </data>
  <data name="IntegerDataTypeInspection" xml:space="preserve">
    <value>Der größte Wert einer vorzeichenbehafteten 16-bit Ganzzahl ist 32.767 - Eine 32-bit Ganzzahl (Long) zu verwenden, wo es möglich ist, kann Überlauffehler zur Laufzeit verhindern und ist für moderne CPUs einfacher.</value>
  </data>
  <data name="EmptyDoWhileBlockInspection" xml:space="preserve">
    <value>Eine leere 'Do…While'-Schleife ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="BooleanAssignedInIfElseInspection" xml:space="preserve">
    <value>Ein Mitglied wird in verschiedenen Zweigen einer if-Anweisung mit True / False zugewiesen, wobei keine anderen Anweisungen in der Bedingung enthalten sind. Verwenden Sie die Bedingung stattdessen direkt für das Mitglied.</value>
  </data>
  <data name="EmptyModuleInspection" xml:space="preserve">
    <value>Leere Module und Klassen weisen entweder auf noch nicht implementierte Funktionalitäten hin oder stellen unnötigen Ballast dar, der die Wartbarkeit eines Projekts behindern kann.</value>
  </data>
  <data name="UnhandledOnErrorResumeNextInspection" xml:space="preserve">
    <value>Fehlerbehandlung sollte nach Verwendung von 'On Error Resume Next' wiederhergestellt werden.</value>
  </data>
  <data name="DefTypeStatementInspection" xml:space="preserve">
    <value>Verwendung der 'Def[Type]' Anweisung führt zur Typspezifikation mit einem Präfix. Von diese Benennungskonvention wird stark abgeraten und sie sollte vermieden werden.</value>
  </data>
  <data name="StepIsNotSpecifiedInspection" xml:space="preserve">
    <value>'Step'  der 'For-Next'-Schleife ist nicht angegeben. Dies könnte versehentlich sein.</value>
  </data>
  <data name="StepOneIsRedundantInspection" xml:space="preserve">
    <value>1 ist der Standardwert für 'Step' in einer 'For-Next'-Schleife und daher redundant.</value>
  </data>
  <data name="SheetAccessedUsingStringInspection" xml:space="preserve">
    <value>Excel already defines a globally scoped object variable with this reference. Consider using the sheet's 'CodeName' property.</value>
  </data>
  <data name="ObsoleteMemberUsageInspection" xml:space="preserve">
    <value>Dieser Member ist als '@Obsolete' markiert. Er sollte nicht länger verwendet werden: eine bessere Alternative müsste existieren.</value>
  </data>
  <data name="ObsoleteCallingConventionInspection" xml:space="preserve">
    <value>Windows-Implementierungen von Visual Basic unterstützen nur die StdCall Aufrufkonvention. Die CDecl Aufrufkonvention wird nur von Macintosh-Versionen von VBA unterstützt. Dieses Schlüsselwort unter Windows zu verwenden, wird zum Laufzeitfehler 49 - 'Falsche DLL-Aufrufkonvention' führen. Falls diese Prozedur nur auf Macintosh-Hostanwendungen verwendet werden soll, sollte sie bedingt kompiliert werden.</value>
  </data>
  <data name="DuplicatedAnnotationInspection" xml:space="preserve">
    <value>Eine Annotation wurde mehrmals spezifiziert, obwohl sie nur einmal spezifiziert werden soll.</value>
  </data>
  <data name="ModuleWithoutFolderInspection" xml:space="preserve">
    <value>Module ohne '@Folder'-Annotation können im Code Explorer nicht in gesonderte Gruppen unterschieden werden.</value>
  </data>
  <data name="OnLocalErrorInspection" xml:space="preserve">
    <value>Die 'On Local Error'-Direktive existiert nur, um Kompatibilität zu vorigen Versionen von Visual Basic zu wahren. Alle Fehler werden unabhängig von der 'On Local Error'-Direktive als lokale Fehler behandelt. Die Verwendung dieser Direktive vermittelt irrtümlich den Eindruck, es existierten unterschiedliche Fehlerbehandlungstypen.</value>
  </data>
  <data name="IsMissingOnInappropriateArgumentInspection" xml:space="preserve">
    <value>'IsMissing' ist nur dafür gedacht, auf optionalen Argumenten aufgerufen zu werden und wird nur bei Variant-Argumenten ohne Standardwert korrekte Ergebnisse liefern. Jegliche andere Verwendung wird 'False' zurückliefern.</value>
  </data>
  <data name="IsMissingWithNonArgumentParameterInspection" xml:space="preserve">
    <value>'IsMissing' ist nur dafür gedacht, auf Argumenten der umgebenden Prozedur aufgerufen zu werden. Beinahe jegliche andere Verwendung wird 'False' zurückgeben. Einen anderen Ausdruck an diese Funktion zu übergeben ist äquvalent zu 'VarType({Ausdruck}) = vbError', und kann in seltenen Fällen zum Absturz der Hostanwendung führen.</value>
  </data>
  <data name="AssignmentNotUsedInspection" xml:space="preserve">
    <value>Eine Zuweisung wird direkt überschrieben oder nie referenziert.</value>
  </data>
  <data name="UnderscoreInPublicClassModuleMemberInspection" xml:space="preserve">
    <value>Ein Klassenmodul, das Member mit Unterstrichen im Namen beinhaltet, kann nicht von anderen Klassen implementiert werden. Der Unterstrich ist als Trennzeichen zwischen Interface-/Objektname und dem Namen des implementierten Members definiert. Ein Unterstrich im Membernamen verwirrt den Übersetzer, der eine Übersetzung des Projektes dann verweigert. Die 'PascalCase'-Namenskonvention erlaubt, Unterstriche in Membernamen zu vermeiden.</value>
  </data>
  <data name="ExcelMemberMayReturnNothingInspection" xml:space="preserve">
    <value>Eine Prozedur, die ein Objekt zurückgibt, kann 'Nothing' zurückgeben. Dies wird bei darauffolgenden Memberzugriff zum Laufzeitfehler 91 - 'Objektblockvariable oder With-Blockvariable nicht festgelegt' führen. Prüfen sie mit 'Is Nothing' nach dem 'Set', um einen Laufzeitfehler auszuschließen.</value>
  </data>
  <data name="ExcelUdfNameIsValidCellReferenceInspection" xml:space="preserve">
    <value>Funktionen, die für EXCEL als benutzerdefinierte Funktionen sichtbar sind, werden einen '#REF!'-Fehler erzeugen, wenn sie in einem Arbeitsblatt verwendet werden, in dem ihr Name dem einer korrekten Zellreferenz entspricht. Wenn die Funktion als benutzerdefinierte Funktion gedacht ist, muss sie umbenannt werden. Wenn die Funktion nicht als benutzerdefinierte Funktion gedacht ist, sollte sie 'Private' deklariert oder aus einem Standardmodul herausgenommen werden.</value>
  </data>
  <data name="AttributeValueOutOfSyncInspection" xml:space="preserve">
    <value>Eine Rubberduck-Annotation wurde für ein Modul oder Element festgelegt, aber das zugehörige Attribut hat einen anderen Wert. Die Modul-Attribute und Annotationen sollten synchronisiert werden.</value>
  </data>
  <data name="MissingMemberAnnotationInspection" xml:space="preserve">
    <value>Elementattribute werden von der VBE nicht angezeigt. Durch das hinzufügen einer Annotation werden diese Attribute deutlicher. Außerdem kann Rubberduck die Annotationen und Attribute synchronisieren.</value>
  </data>
  <data name="MissingModuleAnnotationInspection" xml:space="preserve">
    <value>Modulattribute werden von der VBE nicht angezeigt. Durch das hinzufügen einer Annotation werden diese Attribute deutlicher. Außerdem kann Rubberduck die Annotationen und Attribute synchronisieren.</value>
  </data>
  <data name="KeywordsUsedAsMemberInspection" xml:space="preserve">
    <value>Ein Schlüsselwort wird als Name eines Elements einer Aufzählung oder eines benutzerdefinierten Typs verwendet. Dies kann zu Problemen bei der Auflösung von Referenzen auf das Element führen. Sie sollten in Betracht ziehen den Namen zu ändern.</value>
  </data>
  <data name="LineContinuationBetweenKeywordsInspection" xml:space="preserve">
    <value>Es befinden sich Zeilenfortsetzungszeichen zwischen Schlüsselwörtern. Dafür gibt es keinen guten Grund. Sie sollten in Betracht ziehen sie zu entfernen.</value>
  </data>
  <data name="NonBreakingSpaceIdentifierInspection" xml:space="preserve">
    <value>Der Bezeichner enthält ein geschütztes Leerzeichen, welches wie eine gewöhnliches Leerzeichen aussieht (nicht zulässig in Bezeichnern). Die macht es schwerer den Programmcode zu lesen. Sie sollten in Betracht ziehen stattdessen sichtbare Zeichen zu verwenden.</value>
  </data>
  <data name="NegativeLineNumberInspection" xml:space="preserve">
    <value>Negative Zeilennummern können nur im Hexadezimalformat eingegeben werden, welches der VBE in negative Dezimalzahlen wandelt. Wird der Programmcode kopiert, mach die negative Dezimalzahl als Zeilennummer ihn illegal.</value>
  </data>
  <data name="OnErrorGoToMinusOneInspection" xml:space="preserve">
    <value>Hierbei handelt es sich um ein schlecht dokumentiertes Feature: Im Normallfall wird der Fehlerspeicher geleert und jegliche Fehlerbehandlung deaktiviert. Sollte allerdings -1 als Zeilennummer vorhanden sein, kann diese als Marker der zu verwendenden Fehlerbehandlung interpretiert werden.</value>
  </data>
  <data name="ObsoleteWhileWendStatementInspection" xml:space="preserve">
    <value>'While...Wend'-Schleifen sind aus Gründen der Abwärtskompatibilität vorhanden und wurden durch die Einführung von 'Do While...Loop'-Blöcken ersetzt, die die 'Exit Do'-Exit-Anweisung unterstützen. 'While...Wend'-Schleifen können nur beendet werden, wenn die 'While'-Bedingung erfüllt ist.</value>
  </data>
  <data name="SetAssignmentWithIncompatibleObjectTypeInspection" xml:space="preserve">
    <value>Der VBA-Compiler gibt keinen Fehler aus, wenn ein Objekt einer Variables Set-zugewiesen wird mit einem inkompatiblen Objekttype, d.h. deren Typ weder identisch, ein Subtyp noch ein Supertyp ist. In fast allen Fällen führt dies zu einem Laufzeitfehler, der schwerer zu entdecken ist und auf einen Programmierfehler hinweist. In allen anderen Fällen kann der Quallcode so geändert werden, dass er ausschließlich Zuweisungen zwischen kompatiblen deklarierten Typen verwendet.</value>
  </data>
  <data name="ArgumentWithIncompatibleObjectTypeInspection" xml:space="preserve">
    <value>Der VBA-Compiler gibt keinen Fehler aus, wenn ein Objekt als Argument für einen Parameter übergeben wird mit einem inkompatiblen Objekttype, d.h. dessen Typ weder identisch, ein Subtyp noch ein Supertyp ist. In fast allen Fällen führt dies zu einem Laufzeitfehler, der schwerer zu entdecken ist und auf einen Programmierfehler hinweist. In allen anderen Fällen kann der Quallcode so geändert werden, dass ausschließlich Argumente mit kompatiblen deklarierten Typen verwendet werden.</value>
  </data>
  <data name="EmptyMethodInspection" xml:space="preserve">
    <value>Methoden ohne ausführbare Anweisungen können den Eindruck erwecken, dass sie etwas tun, was sie eigentlich nicht tun. Dies kann zu unerwartetem Verhalten führen.</value>
  </data>
  <data name="ImplementedInterfaceMemberInspection" xml:space="preserve">
    <value>Eine Klasse, die dafür gedacht ist von anderen Klassen als Interface genutzt zu werden, sollte gewöhnlicher Weise keine Implementierungen enthalten. Falls die Intention ist diese Klasse direkt als konkrete Klasse zu verwenden, kann dieses Inspektionsresultat ignoriert werden.</value>
  </data>
  <data name="ValueRequiredInspection" xml:space="preserve">
    <value>Der VBA-Compiler gibt keinen Fehler aus, wenn ein Objekt an einer Stelle verwendet wird, die einen Wert verlangt, und der deklarierte Type des Objekts keinen passenden Standardmember hat. In fast allen Fällen führt dies zu einem Laufzeitfehler 91 'Objektvariable oder With-Blockvariable nicht festgelegt' oder 438 'Objekt unterstützt diese Eigenschaft oder Methode nicht' abhängig davon, ob die Variable den Wert 'Nothing' hat oder nicht, der schwerer zu entdecken ist und auf einen Programmierfehler hinweist.</value>
  </data>
  <data name="ProcedureRequiredInspection" xml:space="preserve">
    <value>Der VBA-Compiler gibt keinen Fehler aus, wenn eine Objektvariable an einer Stelle verwendet wird, die eine Prozedur erfordert, und der deklarierte Type des Objekts keinen passenden Standardmember hat. In fast allen Fällen führt dies zu einem Laufzeitfehler91 'Objektvariable oder With-Blockvariable nicht festgelegt' oder 438 'Objekt unterstützt diese Eigenschaft oder Methode nicht' abhängig davon, ob die Variable den Wert 'Nothing' hat oder nicht, der schwerer zu entdecken ist und auf einen Programmierfehler hinweist.</value>
  </data>
  <data name="DefaultMemberRequiredInspection" xml:space="preserve">
    <value>Der VBA-Compiler gibt keinen Fehler aus, wenn ein Standardmemberzugriff nötig ist, aber der der deklarierte Type des Objekts keinen passenden Standardmember hat. In fast allen Fällen führt dies zu einem Laufzeitfehler91 'Objektvariable oder With-Blockvariable nicht festgelegt' oder 438 'Objekt unterstützt diese Eigenschaft oder Methode nicht' abhängig davon, ob die Variable den Wert 'Nothing' hat oder nicht, der schwerer zu entdecken ist und auf einen Programmierfehler hinweist.</value>
  </data>
  <data name="UseOfBangNotationInspection" xml:space="preserve">
    <value>Die Ausrufezeichennotation erweckt den Eindruck, dass es sich um einen Zugriff handelt, der Typchecks unterliegt. Allerdings handelt es sich lediglich um einen Zugriff auf den Standardmember des Objekts, auf das sie angewendet wird, bei dem das Argument als Zeichenkette übergeben wird.</value>
  </data>
  <data name="UseOfRecursiveBangNotationInspection" xml:space="preserve">
    <value>Die Ausrufezeichennotation erweckt den Eindruck, dass es sich um einen Zugriff handelt, der Typchecks unterliegt. Allerdings handelt es sich lediglich um einen Zugriff auf den Standardmember des Objekts, auf das sie angewendet wird, bei dem das Argument als Zeichenkette übergeben wird. Dies ist besonders verwirrend, wenn der Standardmember des Objekts selber keine Zeichenkette akzeptiert und deshalb ein rekursiver Zugriff auf den parameterlosen Standardmember erfolgen muss.</value>
  </data>
  <data name="UseOfUnboundBangNotationInspection" xml:space="preserve">
    <value>Die Ausrufezeichennotation erweckt den Eindruck, dass es sich um einen Zugriff handelt, der Typchecks unterliegt. Allerdings handelt es sich lediglich um einen Zugriff auf den Standardmember des Objekts, auf das sie angewendet wird, bei dem das Argument als Zeichenkette übergeben wird. Dies ist besonders verwirrend, wenn der Standardmember nicht zum Zeitpunkt des Kompilierens ermittelt werden kann.</value>
  </data>
  <data name="ObjectWhereProcedureIsRequiredInspection" xml:space="preserve">
    <value>Wenn ein Objekt mit einem Standardmember an einer Stelle verwendet wird, die nach einer Prozedur verlangt, wird implizit der Standardmember aufgerufen. Die ist wahrscheinlich nicht beabsichtigt, minder aber zu Mindest die Lesbarkeit des Programms.</value>
  </data>
  <data name="IndexedDefaultMemberAccessInspection" xml:space="preserve">
    <value>Zugriffe auf Standardmember verstecken, welcher Member aufgerufen wird. Auch wenn im Fall eines paramtrisierten Zugriffs ersichtlich ist, dass ein Zugriff erfolgt, so ist es in der Regel für die Lesbarkeit zuträglich explizit zu sein.</value>
  </data>
  <data name="IndexedRecursiveDefaultMemberAccessInspection" xml:space="preserve">
    <value>Zugriffe auf Standardmember verstecken, welcher Member aufgerufen wird. Auch wenn im Fall eines paramtrisierten Zugriffs ersichtlich ist, dass ein Zugriff erfolgt, so ist es in der Regel für die Lesbarkeit zuträglich explizit zu sein. Dies trifft besonders zu, wenn der Standardmember nicht auf dem Interface des Objekts selber zu finden ist uns stattdessen mittels einer Kette von Standrdmemberzugriffen erreicht werden muss.</value>
  </data>
  <data name="IndexedUnboundDefaultMemberAccessInspection" xml:space="preserve">
    <value>Zugriffe auf Standardmember verstecken, welcher Member aufgerufen wird. Auch wenn im Fall eines paramtrisierten Zugriffs ersichtlich ist, dass ein Zugriff erfolgt, so ist es in der Regel für die Lesbarkeit zuträglich explizit zu sein. Dies trifft insbesondere zu, wenn der Standardmember erst zur Laufzeit ermittelt werden kann. Sollte dann kein passender Standardmember existieren, kommt es zu einem Fehler 438 'Objekt unterstützt diese Eigenschaft oder Methode nicht'.</value>
  </data>
  <data name="ImplicitDefaultMemberAccessInspection" xml:space="preserve">
    <value>Zugriffe auf Standardmember verstecken, welcher Member aufgerufen wird. Dies ist besonders verwirrend, wenn in dem Ausdruck selber keine Indikation vorhanden ist, dass ein solcher Zugriff erfolgt. Dies kann dazu führen, dass Fehler durch vergessene Memberaufrufe nicht erkannt werden.</value>
  </data>
  <data name="ImplicitRecursiveDefaultMemberAccessInspection" xml:space="preserve">
    <value>Zugriffe auf Standardmember verstecken, welcher Member aufgerufen wird. Dies ist besonders verwirrend, wenn in dem Ausdruck selber keine Indikation vorhanden ist, dass ein solcher Zugriff erfolgt, und zudem der Standardmember nicht auf dem Interface des Objekts selber zu finden ist. Dies kann dazu führen, dass Fehler durch vergessene Memberaufrufe nicht erkannt werden.</value>
  </data>
  <data name="ImplicitUnboundDefaultMemberAccessInspection" xml:space="preserve">
    <value>Zugriffe auf Standardmember verstecken, welcher Member aufgerufen wird. Dies ist besonders verwirrend, wenn in dem Ausdruck selber keine Indikation vorhanden ist, dass ein solcher Zugriff erfolgt, und zudem der Standardmember erst zur Laufzeit ermittelt werden kann. Dies kann dazu führen, dass Fehler durch vergessene Memberaufrufe nicht erkannt werden. Sollte weiterhin zur Laufzeit kein Standardmember auf dem Objekt existsieren, so kommt es zu einem Fehler 438 'Objekt unterstützt diese Eigenschaft oder Methode nicht'.</value>
  </data>
  <data name="SuspiciousLetAssignmentInspection" xml:space="preserve">
    <value>Wenn beide Seiten einer Zuweisung ohne Set Objekte sind, kommt es zu einer Zuweisung vom Standardmember der rechten Seite zu dem der linken. Auch wenn dies manchmal beabsichtigt sein kann, kann es in vielen Fällen dazu führen, dass nicht bemerkt wird, dass Set fehlerhafter Weise vergessen wurde.</value>
  </data>
</root>