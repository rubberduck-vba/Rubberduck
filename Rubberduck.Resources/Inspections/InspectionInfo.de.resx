<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AssignedByValParameterInspection" xml:space="preserve">
    <value>Parameter wird als Wert übergeben, aber überschrieben. Eine Lokale Kopie verdeutlicht, dass die Aufrufende den neuen Wert nicht kennen soll. Falls die Aufrufende den neuen Wert kennen soll, müsste der Parameter 'ByRef' übergeben werden und dies ist ein Bug.</value>
  </data>
  <data name="ConstantNotUsedInspection" xml:space="preserve">
    <value>Rubberduck konnte keine Referenz auf eine Konstante finden. Überlegen Sie eine Entfernung der nicht verwendeten Deklaration.</value>
  </data>
  <data name="DefaultProjectNameInspection" xml:space="preserve">
    <value>Erwäge Sie dem VBA-Projekt einen Namen zu geben.</value>
  </data>
  <data name="EmptyStringLiteralInspection" xml:space="preserve">
    <value>Die eingebaute Konstante 'vbNullString' ist ein Null-String Zeiger, der 0 bytes Arbeitsspeicher benötigt. Dies ist das beabsichtigte Verhalten eines leeren Strings.</value>
  </data>
  <data name="EncapsulatePublicFieldInspection" xml:space="preserve">
    <value>Erwägen Sie stattdessen, eine Eigenschaft verfügbar zu machen.</value>
  </data>
  <data name="ImplicitActiveSheetReferenceInspection" xml:space="preserve">
    <value>Implizite Referenzen zum aktuellen Tabellenblatt macht den Code anfällig und schwieriger zu debuggen. Erwäge die Referenz explizit anzugeben oder vorzugsweise mit Objektreferenzen zu arbeiten. Ignoriere wenn der Methodenaufruf sich auf einen Typ bezieht, den Rubberduck nicht auflösen kann.</value>
  </data>
  <data name="ImplicitActiveWorkbookReferenceInspection" xml:space="preserve">
    <value>Implizite Referenzen zur aktuellen Arbeitsmappe macht den Code anfällig und schwieriger zu debuggen. Erwäge die Referenz explizit anzugeben oder vorzugsweise mit Objektreferenzen zu arbeiten. Ignoriere wenn der Methodenaufruf sich auf einen Typ bezieht, den Rubberduck nicht auflösen kann.</value>
  </data>
  <data name="ImplicitPublicMemberInspection" xml:space="preserve">
    <value>Die Methoden eines Moduls sind standardmäßig öffentlich, was irreführend sein kann. Besser ist es, den Gültigkeitsbereich der Methoden explizit zu definieren.</value>
  </data>
  <data name="ImplicitVariantReturnTypeInspection" xml:space="preserve">
    <value>Methoden mit einem Rückgabewert geben, wenn nicht anders angegeben, implizit 'Variant' zurück. Überlege, ob es nicht besser ist, den Rückgabewert explizit als 'Variant' zu definieren, wenn der Typ des Rückgabewertes nicht bekannt ist.</value>
  </data>
  <data name="MoveFieldCloserToUsageInspection" xml:space="preserve">
    <value>Eine Variable, die im Modulkopf deklariert wurde aber nur in einer Prozedur verwendet wird, sollte in der Prozedur deklariert werden.</value>
  </data>
  <data name="MultilineParameterInspection" xml:space="preserve">
    <value>Überlege lange Parameterdeklarationen zusammenzuhalten. Das Aufteilen einer Parameterdeklaration über mehrere Zeilen sollte zugunsten der besseren Lesbarkeit vermieden werden.</value>
  </data>
  <data name="MultipleDeclarationsInspection" xml:space="preserve">
    <value>Die Deklaration von mehren Variablen in der gleichen Codezeile ist erlaubt, sollte aber sparsam eingesetzt werden. Erwäge die Variablendeklartion in der Nähe der Nutzung als separate Anweisung pro Deklaration.</value>
  </data>
  <data name="MultipleFolderAnnotationsInspection" xml:space="preserve">
    <value>Rubberduck nutzt nur die erste '@Folder'-Annotation innerhalb eines Code-Moduls. Entferne die Überzähligen.</value>
  </data>
  <data name="NonReturningFunctionInspection" xml:space="preserve">
    <value>Hier könnte ein Fehler vorliegen. Der Rückgabewert einer Funktion oder Eigenschaft wird nicht zugewiesen. Dies kann zu unvorhersehbaren Verhalten des Codes führen. Wenn die Funktion keinen sinnvollen Rückgabewert hat, sollte sie in eine 'Sub'-Routine umgeschrieben werden.</value>
  </data>
  <data name="ObsoleteCallStatementInspection" xml:space="preserve">
    <value>Die 'Call'-Anweisung ist nicht mehr zum Aufruf einer Anweisung notwendig. Sie existiert aus Gründen der Abwärtskompatibilität. Sie kann problemlos durch einen impliziten Anweisungsaufruf ersetzt werden.</value>
  </data>
  <data name="ObsoleteCommentSyntaxInspection" xml:space="preserve">
    <value>Die 'REM'-Anweisung existiert aus Gründen der Abwärtskompatibilität. Sie kann gefahrlos durch ein einfaches Anführungszeichen ersetzt werden.</value>
  </data>
  <data name="ObsoleteGlobalInspection" xml:space="preserve">
    <value>Das Schlüsselwort 'Global' existiert aus Gründen der Abwärtskompatibilität. Es kann gefahrlos durch 'Public' ersetzt werden.</value>
  </data>
  <data name="ObsoleteLetStatementInspection" xml:space="preserve">
    <value>Die 'Let'-Anweisung  existiert aus Gründen der Abwärtskompatibilität. Sie kann gefahrlos entfernt werden, da das moderne VBA dieses Schlüsselwort nicht mehr zur Werte-Zuweisung benötigt.</value>
  </data>
  <data name="ObsoleteTypeHintInspection" xml:space="preserve">
    <value>Die Verwendung der Typ-Buchstaben (z.B. $)  existiert aus Gründen der Abwärtskompatibilität. Sie kann gefahrlos durch eine 'As'-Typdeklaration ersetzt werden.</value>
  </data>
  <data name="OptionBaseInspection" xml:space="preserve">
    <value>Arrays sind normalerweise null-basiert. Diese Option ändert die untere Standardgrenze für impliziert erzeugte Arrays. Dies kann einen 'off-by-one' Fehler erzeugen, wenn sie nicht sorgsam eingesetzt wird.</value>
  </data>
  <data name="OptionExplicitInspection" xml:space="preserve">
    <value>VBA kompiliert ohne ohne 'Option Explicit` auch Tippfehlern erfolgreich: Verwenden Sie 'Option Explicit', um zu verhindern, dass ein fehlerhaftes Programm erfolgreich kompiliert wird.</value>
  </data>
  <data name="ParameterCanBeByValInspection" xml:space="preserve">
    <value>Ein Parameter der als Referenz übergeben wird, aber keine neue Wert- oder Referenzzuweisung erhält, sollte als Wert übergeben werden.</value>
  </data>
  <data name="ParameterNotUsedInspection" xml:space="preserve">
    <value>Ein Parameter, der der Methode übergeben wird, wird nicht verwendet. Erwäge diesen zu entfernen.</value>
  </data>
  <data name="ProcedureNotUsedInspection" xml:space="preserve">
    <value>Rubberduck kann keinen Aufruf für die Prozedur finden. Falls diese über eine Markro-Schaltfläche, als benutzerdefinierte Funktion oder als Event-Handler genutzt wird, den Rubberduck nicht kennt, kann dieser Hinweis ignoriert werden. Ansonsten sollte sie entfernt werden.</value>
  </data>
  <data name="UnassignedVariableUsageInspection" xml:space="preserve">
    <value>Hier könnte ein Fehler vorliegen. Eine Variable wird referenziert aber ihr wird kein Wert zugewiesen.</value>
  </data>
  <data name="UntypedFunctionUsageInspection" xml:space="preserve">
    <value>Es gibt eine äquivalente Funktion, die einen String zurückgibt. Diese sollte bevorzugt genutzt werden, um implitizite Typumwandlungen zu vermeiden.
Falls der Parameter 'null' sein kann, bitte dieses Auftreten ignorieren. 'null' an die Funktion zu übergeben, die einen String erwartet würde zu einem "Type Mismatch"-Laufzeitfehler führen.</value>
  </data>
  <data name="UseMeaningfulNameInspection" xml:space="preserve">
    <value>Bezeicher sollten lesbar sein und ihren Verwendungszweck widerspiegeln. Bezeichner ohne Vokale, mit nummerischem Suffix oder nur 1-2 Buchstaben sollten vermieden werden.</value>
  </data>
  <data name="VariableNotAssignedInspection" xml:space="preserve">
    <value>Einer Variable wird kein Wert zugewiesen. Falls das nicht beabsichtigt ist, kann das zu einem Fehler führen. Ignorieren Sie diese Warnung, falls die Variable in einer anderen Prozedur durch einen 'ByRef'-Parameter zugewiesen wird.</value>
  </data>
  <data name="VariableNotUsedInspection" xml:space="preserve">
    <value>Variable wird nicht gelesen</value>
  </data>
  <data name="VariableTypeNotDeclaredInspection" xml:space="preserve">
    <value>Variable, deren Typ nicht explizit deklariert wurde, erhält implizit den Typ 'Variant'. Überlege die Variable explizit als 'Variant' zu definieren oder eine besseren Typ zu zuweisen.</value>
  </data>
  <data name="WriteOnlyPropertyInspection" xml:space="preserve">
    <value>Eine Eigenschaft, die eine Änderungsfunktion, aber keine Zugriffsfunktion bereitstellt, führt zu einer unklaren API. Enweder erstelle einen öffentlichen getter oder ändere die Änderungsfunktion in eine Methode ab.</value>
  </data>
  <data name="ProcedureCanBeWrittenAsFunctionInspection" xml:space="preserve">
    <value>Eine Prozedur, die nur einen Parameter als Referenz übergibt, der vor dem Verlassen der Prozedur einen neuen Wert oder Referenz erhält, sollte als Funktion umgeschrieben werden.</value>
  </data>
  <data name="SelfAssignedDeclarationInspection" xml:space="preserve">
    <value>Eine selbstzugewiesene Objektvariablendeklaration in einer Prozedur kann das Verhalten beim Nulling verändern. Dies kann zu unvorhergesehen Verhalten des Codes führen.</value>
  </data>
  <data name="ObjectVariableNotSetInspection" xml:space="preserve">
    <value>Rubberduck hat festgestellt, dass die Variable eine Objektvariable ist, die ohne 'Set'-Schlüsselwort zugewiesen wird. Dies führt zu dem Laufzeitfehler '91': Objektvariable oder With-Blockvariable nicht festgelegt</value>
  </data>
  <data name="MissingAnnotationArgumentInspection" xml:space="preserve">
    <value>Eine Annotation in einem Kommentar konnte nicht gelesen werden. Die korrekte Syntax ist: '@Annotation([parameter])'\nBeispiel: '@Folder("Parent.Child")'</value>
  </data>
  <data name="UndeclaredVariableInspection" xml:space="preserve">
    <value>Code, der undeklarierte Variablen verwendet, kompiliert nicht wenn 'Option Explicit' spezifiziert wird. Undeklarierte Variablen sind immer vom Typ 'Variant', was unnötige Zusatzkosten in Ausführungszeit und Speicherverbauch verursacht.</value>
  </data>
  <data name="ModuleScopeDimKeywordInspection" xml:space="preserve">
    <value>Das Schlüsselwort 'Public' kann nur auf Modulebene verwendet werden; Sein Konterpart 'Private' kann auch nur auf Modulebene verwendet werden. 'Dim' jedoch kann verwendet werden, um sowohl modulweite als auch prozedurweite Variablen zu deklarieren. Um der Konsistenz Willen ist es besser, 'Dim' nur für lokale Variablen zu verwenden, also 'Private' statt 'Dim' auf Modulebene zu verwenden.</value>
  </data>
  <data name="FunctionReturnValueNotUsedInspection" xml:space="preserve">
    <value>Ein Member ist als Funktion geschrieben, aber wird wie eine Prozedur verwendet. Falls die Funktion nicht rekursiv ist, sollten Sie in Erwägung ziehen, die 'Function' in ein 'Sub' zu konvertieren. Falls die Funktion rekursiv ist, verwendet keiner der externen Aufrufer den Rückgabewert.</value>
  </data>
  <data name="MemberNotOnInterfaceInspection" xml:space="preserve">
    <value>Es wird ein Memberzugriff verwendet, der vom Interface des Objektes nicht deklariert wird. Dies ist höchstwahrscheinlich ein Fehler. Falls der Memberzugriff das erweiterbare Interface des Objektes verwendet, erwägen Sie ein nicht erweiterbares Äquivalent zu verwenden um Prüfungen zur Kompilierzeit zu ermöglichen und das Auftreten von Laufzeitfehler 438 zu verhindern.</value>
  </data>
  <data name="HungarianNotationInspection" xml:space="preserve">
    <value>'Ungarische Notation' macht Code weniger lesbar und ist redundant, sobald stark typisierte Variablen und aussagekräftige Namen verwendet werden.</value>
  </data>
  <data name="ApplicationWorksheetFunctionInspection" xml:space="preserve">
    <value>Das Excel Application-Objekt implementiert das WorksheetFunction interface direkt. Alle Aufrufe an WorksheetFunction-Member werden als laufzeitgebunden behandelt und Fehler im aufgerufenen Member werden in ein Variant des Typs VbVarType.Error gekapselt. Dadurch können Fehler nicht mit Fehleranweisungen behandelt werden und gegenüber skriptzeitgebundenen Aufrufen sinkt die Performanz. Ziehen Sie in Erwägung Application.WorksheetFunction explizit aufzurufen. Bedenken Sie: Falls dieser Aufruf in der Vergangenheit Fehler erzeugt hat, wurden diese ignoriert. Es sollte eine Fehlerbehandlung vorhanden sein, bevor Sie die schnelle Korrektur anwenden.</value>
  </data>
  <data name="ImplicitDefaultMemberAssignmentInspection" xml:space="preserve">
    <value>Solche Zuweisungen sehen aus als wiesen sie einer Objektvariable an einen Werttyp zu, aber tatsächlich wird der Standardmember des Objekts implizit zugewiesen. Um die Lesbarkeit zu verbessern, erwägen Sie explizit auf den Standardmember zuzugreifen.</value>
  </data>
  <data name="HostSpecificExpressionInspection" xml:space="preserve">
    <value>Geklammerte Ausdrücke werden von der Hostanwendung zur Laufzeit ausgewertet, was bedeutet, dass VBA den Ausdruck nicht zur Kompilierzeit validieren kann. Erwägen sie, das hostspezifische Objektmodell zu verwenden.</value>
  </data>
  <data name="OptionBaseZeroInspection" xml:space="preserve">
    <value>Dies ist die Standardeinstellung, sie muss nicht spezifiziert werden.</value>
  </data>
  <data name="MissingAnnotationInspection" xml:space="preserve">
    <value>Modul- und Elementattribute werden von der VBE nicht angezeigt. Durch das hinzufügen einer Annotation werden diese Attribute deutlicher. Außerdem kann Rubberduck die Annotationen und Attribute synchronisieren.</value>
  </data>
  <data name="IllegalAnnotationInspection" xml:space="preserve">
    <value>Eine Annotation für die Modulebene kann nicht verwendet werden, um Elemente zu annotieren; Eine Annotation für Elemente kann auf Modulebene nicht verwendet werden; Modul- und Elementannotationen sollten nur einmal spezifiziert werden.</value>
  </data>
  <data name="RedundantOptionInspection" xml:space="preserve">
    <value>Da dies die Standardeinstellung für diese Option ist, kann die Anweisung ohne Nebeneffekte entfernt werden.</value>
  </data>
  <data name="RedundantByRefModifierInspection" xml:space="preserve">
    <value>Alle Parameter werden, falls nicht anders spezifiziert als Referenz übergeben. Es ist also nicht nötig, die 'ByRef'-Markierung zu verwenden.</value>
  </data>
  <data name="ImplicitByRefModifierInspection" xml:space="preserve">
    <value>Parameter werden, falls nicht anders spezifiziert, als Referenz übergeben. Dies kann verwirrend sein und Bugs hervorrufen. Bevorzugen Sie die Übergabe von Parametern als Werte und spezifizieren Sie eine Referenzübergabe explizit als ByRef.</value>
  </data>
  <data name="MissingAttributeInspection" xml:space="preserve">
    <value>Eine Rubberduck-Annotation wurde für ein Modul oder Element festgelegt, aber das zugehörige Attribut fehlt. Die Modul-Attribute und Annotationen sollten synchronisiert werden.</value>
  </data>
  <data name="EmptyIfBlockInspection" xml:space="preserve">
    <value>Ein leerer 'If'-Block ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="LineLabelNotUsedInspection" xml:space="preserve">
    <value>Rubberduck konnte keine Resume oder GoTo Anweisung zu einer Zeilenbezeichnung finden. Erwägen Sie eine Entfernung der Bezeichnung.</value>
  </data>
  <data name="EmptyForLoopBlockInspection" xml:space="preserve">
    <value>Eine leere 'For…Next'-Schleife ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="ShadowedDeclarationInspection" xml:space="preserve">
    <value>Zwei Deklarationen sind aktiv und haben denselben Namen. Dies bedeutet, dass nur eine von ihnen zur Verwendung verfügbar ist.</value>
  </data>
  <data name="StopKeywordInspection" xml:space="preserve">
    <value>Das Schlüsselwort 'Stop' unterbricht die Ausführung und ruft den Debugger auf. Vermeiden Sie die Verwendung in verteiltem Code.</value>
  </data>
  <data name="EmptyCaseBlockInspection" xml:space="preserve">
    <value>Ein leerer 'Case'-Block ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="EmptyForEachBlockInspection" xml:space="preserve">
    <value>Eine leere 'For Each…Next'-Schleife ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="EmptyElseBlockInspection" xml:space="preserve">
    <value>Ein leerer 'Else'-Block ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="EmptyWhileWendBlockInspection" xml:space="preserve">
    <value>Eine leere 'While…Wend'-Schleife ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="ObsoleteErrorSyntaxInspection" xml:space="preserve">
    <value>Die 'Error'-Anweisung existiert in der Sprache nur um Legacy-Programme zu unterstützen, die sie benötigten; Bevorzugen Sie stattdessen 'Err.Raise'.</value>
  </data>
  <data name="IntegerDataTypeInspection" xml:space="preserve">
    <value>Der größte Wert einer vorzeichenbehafteten 16-bit Ganzzahl ist 32.767 - Eine 32-bit Ganzzahl (Long) zu verwenden, wo es möglich ist, kann Überlauffehler zur Laufzeit verhindern und ist für moderne CPUs einfacher.</value>
  </data>
  <data name="EmptyDoWhileBlockInspection" xml:space="preserve">
    <value>Eine leere 'Do…While'-Schleife ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="BooleanAssignedInIfElseInspection" xml:space="preserve">
    <value>Ein Mitglied wird in verschiedenen Zweigen einer if-Anweisung mit True / False zugewiesen, wobei keine anderen Anweisungen in der Bedingung enthalten sind. Verwenden Sie die Bedingung stattdessen direkt für das Mitglied.</value>
  </data>
  <data name="EmptyModuleInspection" xml:space="preserve">
    <value>Leere Module und Klassen weisen entweder auf noch nicht implementierte Funktionalitäten hin oder stellen unnötigen Ballast dar, der die Wartbarkeit eines Projekts behindern kann.</value>
  </data>
  <data name="UnreachableCaseInspection" xml:space="preserve">
    <value>Erkennt "Case"-Klauseln, die nie ausgeführt werden können.</value>
  </data>
  <data name="UnhandledOnErrorResumeNextInspection" xml:space="preserve">
    <value>Fehlerbehandlung sollte nach Verwendung von 'On Error Resume Next' wiederhergestellt werden.</value>
  </data>
  <data name="DefTypeStatementInspection" xml:space="preserve">
    <value>Verwendung der 'Def[Type]' Anweisung führt zur Typspezifikation mit einem Präfix. Von diese Benennungskonvention wird stark abgeraten und sie sollte vermieden werden.</value>
  </data>
  <data name="StepIsNotSpecifiedInspection" xml:space="preserve">
    <value>'Step'  der 'For-Next'-Schleife ist nicht angegeben. Dies könnte versehentlich sein.</value>
  </data>
  <data name="StepOneIsRedundantInspection" xml:space="preserve">
    <value>1 ist der Standardwert für 'Step' in einer 'For-Next'-Schleife und daher redundant.</value>
  </data>
  <data name="SheetAccessedUsingStringInspection" xml:space="preserve">
    <value>Excel already defines a globally scoped object variable with this reference. Consider using the sheet's 'CodeName' property.</value>
  </data>
  <data name="UndeclaredRedimVariableInspection" xml:space="preserve">
    <value>Code, der Variablen mittels redim statements deklariert macht Code schwieriger zu verstehen.</value>
  </data>
</root>