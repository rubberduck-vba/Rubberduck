<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="EmptyStringLiteralInspectionQuickFix" xml:space="preserve">
    <value>Leeren String durch die Konstante 'vbNullString' ersetzen</value>
  </data>
  <data name="EncapsulatePublicFieldInspectionQuickFix" xml:space="preserve">
    <value>Das Feld '{0}' mit einer Eigenschaft kapselen</value>
  </data>
  <data name="IgnoreOnce" xml:space="preserve">
    <value>Einmal ignorieren</value>
  </data>
  <data name="ProcedureShouldBeFunctionInspectionQuickFix" xml:space="preserve">
    <value>Als Funktion implementieren und Aufrufe anpassen.</value>
  </data>
  <data name="ConvertFunctionToProcedureQuickFix" xml:space="preserve">
    <value>Funktion zu Prozedur konvertieren</value>
  </data>
  <data name="DeclareAsExplicitVariantQuickFix" xml:space="preserve">
    <value>Als explizit 'Variant' deklarieren</value>
  </data>
  <data name="MakeSingleLineParameterQuickFix" xml:space="preserve">
    <value>Variable in einer Zeile schreiben </value>
  </data>
  <data name="ObsoleteGlobalInspectionQuickFix" xml:space="preserve">
    <value>'Global' durch 'Public' ersetzen</value>
  </data>
  <data name="OptionExplicitQuickFix" xml:space="preserve">
    <value>'Option Explicit' setzen</value>
  </data>
  <data name="PassParameterByReferenceQuickFix" xml:space="preserve">
    <value>Parameter als Referenz übergeben</value>
  </data>
  <data name="PassParameterByValueQuickFix" xml:space="preserve">
    <value>Parameter als Wert übergeben</value>
  </data>
  <data name="RemoveCommentQuickFix" xml:space="preserve">
    <value>Kommentar entfernen</value>
  </data>
  <data name="RemoveObsoleteStatementQuickFix" xml:space="preserve">
    <value>Überflüssige Anweisungen entfernen</value>
  </data>
  <data name="RemoveTypeHintsQuickFix" xml:space="preserve">
    <value>Typ-Hinweise entfernen</value>
  </data>
  <data name="RemoveUnassignedIdentifierQuickFix" xml:space="preserve">
    <value>Nicht verwendete Variablen entfernen</value>
  </data>
  <data name="RemoveUnassignedVariableUsageQuickFix" xml:space="preserve">
    <value>Nutzung enfernen (unterbricht den Code)</value>
  </data>
  <data name="RemoveUnusedDeclarationQuickFix" xml:space="preserve">
    <value>Unbenutze Deklaration enfernen</value>
  </data>
  <data name="RemoveUnusedParameterQuickFix" xml:space="preserve">
    <value>Nicht genutzte Parameter entfernen</value>
  </data>
  <data name="ReplaceCommentMarkerQuickFix" xml:space="preserve">
    <value>'REM' durch einfaches Anführungszeichen als Kommentarzeichen ersetzen</value>
  </data>
  <data name="SetExplicitVariantReturnTypeQuickFix" xml:space="preserve">
    <value>Explizit 'Variant' zurückgeben</value>
  </data>
  <data name="SpecifyExplicitPublicModifierQuickFix" xml:space="preserve">
    <value>Gültigkeitsbereich 'Public' explizit definieren</value>
  </data>
  <data name="SplitMultipleDeclarationsQuickFix" xml:space="preserve">
    <value>Mehrfach-Deklarationen in einer Zeile durch Deklaration in getrennten Zeilen ersetzen</value>
  </data>
  <data name="InvalidContextTypeInspectionFix" xml:space="preserve">
    <value>Kontexttyp '{0}' ist nicht gültig für {1}.</value>
  </data>
  <data name="SetObjectVariableQuickFix" xml:space="preserve">
    <value>Das Schlüsselwort 'Set' benutzen</value>
  </data>
  <data name="IntroduceLocalVariableQuickFix" xml:space="preserve">
    <value>Lokale Variable einführen</value>
  </data>
  <data name="WriteOnlyPropertyQuickFix" xml:space="preserve">
    <value>'Property Get' Zugriff hinzufügen</value>
  </data>
  <data name="ChangeDimToPrivateQuickFix" xml:space="preserve">
    <value>'Dim' durch 'Private' ersetzen</value>
  </data>
  <data name="ApplicationWorksheetFunctionQuickFix" xml:space="preserve">
    <value>Application.WorksheetFunction explizit verwenden.</value>
  </data>
  <data name="WhiteListIdentifierQuickFix" xml:space="preserve">
    <value>Zur Whitelist hinzufügen</value>
  </data>
  <data name="AssignedByValParameterMakeLocalCopyQuickFix" xml:space="preserve">
    <value>Eine lokale Kopie des Parameters erstellen und verwenden</value>
  </data>
  <data name="RemoveOptionBaseStatementQuickFix" xml:space="preserve">
    <value>'Option Base'-Anweisung entfernen</value>
  </data>
  <data name="SynchronizeAttributesQuickFix" xml:space="preserve">
    <value>Attribute/Annotationen im Modul synchronisieren</value>
  </data>
  <data name="RedundantByRefModifierQuickFix" xml:space="preserve">
    <value>Redundante 'ByRef'-Markierung entfernen</value>
  </data>
  <data name="RemoveEmptyIfBlockQuickFix" xml:space="preserve">
    <value>Leeren 'If'-Block entfernen</value>
  </data>
  <data name="ImplicitByRefModifierQuickFix" xml:space="preserve">
    <value>Parameter explizit als Referenz übergeben.</value>
  </data>
  <data name="ReplaceObsoleteErrorStatementQuickFix" xml:space="preserve">
    <value>'Error' durch 'Err.Raise' ersetzen</value>
  </data>
  <data name="RemoveEmptyElseBlockQuickFix" xml:space="preserve">
    <value>Leeren 'Else'-Block entfernen</value>
  </data>
  <data name="RemoveStopKeywordQuickFix" xml:space="preserve">
    <value>'Stop'-Schlüsselwort entfernen</value>
  </data>
  <data name="IntegerDataTypeQuickFix" xml:space="preserve">
    <value>Typ zu 'Long' änderen</value>
  </data>
  <data name="ReplaceIfElseWithConditionalStatementQuickFix" xml:space="preserve">
    <value>'If/Else' mit einer einfachen Zuordnung ersetzen</value>
  </data>
  <data name="UnhandledOnErrorResumeNextInspectionQuickFix" xml:space="preserve">
    <value>Subroutine zur Fehlerbehandlung einführen</value>
  </data>
  <data name="RemoveStepOneQuickFix" xml:space="preserve">
    <value>Step entfernen</value>
  </data>
  <data name="AddStepOneQuickFix" xml:space="preserve">
    <value>Step hinzufügen</value>
  </data>
  <data name="UseTypedFunctionQuickFix" xml:space="preserve">
    <value>'{0}' zu '{1}' ändern</value>
  </data>
  <data name="AccessSheetUsingCodeNameQuickFix" xml:space="preserve">
    <value>Das statisch erreichbare Tabellenblatt mit Codenamen referenzieren</value>
  </data>
  <data name="RemoveDuplicatedAnnotationQuickFix" xml:space="preserve">
    <value>Duplizierte Annotation entfernen</value>
  </data>
  <data name="RemoveLocalErrorQuickFix" xml:space="preserve">
    <value>'On Local Error' durch 'On Error' ersetzen</value>
  </data>
  <data name="IsMissingOnInappropriateArgumentQuickFix" xml:space="preserve">
    <value>'IsMissing'-Aufruf in Prüfung eines Standardwerts umschreiben.</value>
  </data>
  <data name="AddMissingAttributeQuickFix" xml:space="preserve">
    <value>Fehlendes Attribut hinzufügen</value>
  </data>
  <data name="AdjustAttributeValuesQuickFix" xml:space="preserve">
    <value>Attributwert(e) anpassen</value>
  </data>
  <data name="RemoveAttributeQuickFix" xml:space="preserve">
    <value>Attribut entfernen</value>
  </data>
  <data name="RemoveAnnotationQuickFix" xml:space="preserve">
    <value>Annotation entfernen</value>
  </data>
  <data name="AdjustAttributeAnnotationQuickFix" xml:space="preserve">
    <value>Attributannotation anpassen</value>
  </data>
  <data name="AddAttributeAnnotationQuickFix" xml:space="preserve">
    <value>Attributannotation hinzufügen</value>
  </data>
  <data name="ApplyQuickFixesFailedMessage" xml:space="preserve">
    <value>Die Ausführen des Quickfixes ist fehlgeschlagen. </value>
  </data>
  <data name="StaleModuleFailureReason" xml:space="preserve">
    <value>Ein betroffenes Module wurde seit dem letzten Parse modifiziert.</value>
  </data>
  <data name="ApplyQuickFixFailedCaption" xml:space="preserve">
    <value>Quickfixausführung fehlgeschlagen</value>
  </data>
  <data name="ReplaceWhileWendWithDoWhileLoopQuickFix" xml:space="preserve">
    <value>'While...Wend' durch'Do While...Loop' ersetzen</value>
  </data>
  <data name="ExpandBangNotationQuickFix" xml:space="preserve">
    <value>Ersetze die Ausrufezeichennotation durch einen expliziten Aufruf</value>
  </data>
  <data name="ExpandDefaultMemberQuickFix" xml:space="preserve">
    <value>Füge einen expliziten Zugriff auf den Standardmember ein</value>
  </data>
</root>