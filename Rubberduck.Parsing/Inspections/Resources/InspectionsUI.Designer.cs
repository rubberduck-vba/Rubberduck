//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Rubberduck.Parsing.Inspections.Resources {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public class InspectionsUI {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal InspectionsUI() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Rubberduck.Parsing.Inspections.Resources.InspectionsUI", typeof(InspectionsUI).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} ({1} results).
        /// </summary>
        public static string AggregateInspectionResultFormat {
            get {
                return ResourceManager.GetString("AggregateInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Excel Application object does not implement the WorksheetFunction interface directly. All calls made to WorksheetFunction members are handled as late bound and errors in the called member will be returned wrapped in a Variant of VbVarType.vbError. This makes errors un-trappable with error handlers and adds a performance penalty in comparison to early bound calls. Consider calling Application.WorksheetFunction explicitly. Note: If this call generated errors in the past, those errors were ignored. If appl [rest of string was truncated]&quot;;.
        /// </summary>
        public static string ApplicationWorksheetFunctionInspectionMeta {
            get {
                return ResourceManager.GetString("ApplicationWorksheetFunctionInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Late bound WorksheetFunction call..
        /// </summary>
        public static string ApplicationWorksheetFunctionInspectionName {
            get {
                return ResourceManager.GetString("ApplicationWorksheetFunctionInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use of late bound Application.{0} member..
        /// </summary>
        public static string ApplicationWorksheetFunctionInspectionResultFormat {
            get {
                return ResourceManager.GetString("ApplicationWorksheetFunctionInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use Application.WorksheetFunction explicitly..
        /// </summary>
        public static string ApplicationWorksheetFunctionQuickFix {
            get {
                return ResourceManager.GetString("ApplicationWorksheetFunctionQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter is passed by value, but is assigned a new value/reference. Consider making a local copy instead if the caller isn&apos;t supposed to know the new value. If the caller should see the new value, the parameter should be passed ByRef instead, and you have a bug..
        /// </summary>
        public static string AssignedByValParameterInspectionMeta {
            get {
                return ResourceManager.GetString("AssignedByValParameterInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to ByVal parameter is assigned.
        /// </summary>
        public static string AssignedByValParameterInspectionName {
            get {
                return ResourceManager.GetString("AssignedByValParameterInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter &apos;{0}&apos; is passed ByVal and assigned a value.
        /// </summary>
        public static string AssignedByValParameterInspectionResultFormat {
            get {
                return ResourceManager.GetString("AssignedByValParameterInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Create and use a local copy of the parameter.
        /// </summary>
        public static string AssignedByValParameterMakeLocalCopyQuickFix {
            get {
                return ResourceManager.GetString("AssignedByValParameterMakeLocalCopyQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Replace &apos;Dim&apos; with &apos;Private&apos;.
        /// </summary>
        public static string ChangeDimToPrivateQuickFix {
            get {
                return ResourceManager.GetString("ChangeDimToPrivateQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Code quality issues.
        /// </summary>
        public static string CodeQualityIssues {
            get {
                return ResourceManager.GetString("CodeQualityIssues", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rubberduck could not find any reference to constant. Consider removing the unused declaration..
        /// </summary>
        public static string ConstantNotUsedInspectionMeta {
            get {
                return ResourceManager.GetString("ConstantNotUsedInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Constant is not used.
        /// </summary>
        public static string ConstantNotUsedInspectionName {
            get {
                return ResourceManager.GetString("ConstantNotUsedInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Convert function to procedure.
        /// </summary>
        public static string ConvertFunctionToProcedureQuickFix {
            get {
                return ResourceManager.GetString("ConvertFunctionToProcedureQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Declare as explicit Variant.
        /// </summary>
        public static string DeclareAsExplicitVariantQuickFix {
            get {
                return ResourceManager.GetString("DeclareAsExplicitVariantQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider naming your VBA project..
        /// </summary>
        public static string DefaultProjectNameInspectionMeta {
            get {
                return ResourceManager.GetString("DefaultProjectNameInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Project name is not specified.
        /// </summary>
        public static string DefaultProjectNameInspectionName {
            get {
                return ResourceManager.GetString("DefaultProjectNameInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Project &apos;{0}&apos; has default name.
        /// </summary>
        public static string DefaultProjectNameInspectionResultFormat {
            get {
                return ResourceManager.GetString("DefaultProjectNameInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Disable this inspection.
        /// </summary>
        public static string DisableThisInspection {
            get {
                return ResourceManager.GetString("DisableThisInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An If block should have executable statements.
        /// </summary>
        public static string EmptyIfBlockInspectionMeta {
            get {
                return ResourceManager.GetString("EmptyIfBlockInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Empty If block.
        /// </summary>
        public static string EmptyIfBlockInspectionName {
            get {
                return ResourceManager.GetString("EmptyIfBlockInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to If block has no executable statements.
        /// </summary>
        public static string EmptyIfBlockInspectionResultFormat {
            get {
                return ResourceManager.GetString("EmptyIfBlockInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Prefer &apos;vbNullString&apos; to an empty string literal.
        /// </summary>
        public static string EmptyStringLiteralInspection {
            get {
                return ResourceManager.GetString("EmptyStringLiteralInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The built-in constant &apos;vbNullString&apos; is a null string pointer taking up 0 bytes of memory, that unambiguously conveys the intent of an empty string..
        /// </summary>
        public static string EmptyStringLiteralInspectionMeta {
            get {
                return ResourceManager.GetString("EmptyStringLiteralInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Empty string literal.
        /// </summary>
        public static string EmptyStringLiteralInspectionName {
            get {
                return ResourceManager.GetString("EmptyStringLiteralInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Replace empty string with the &apos;vbNullString&apos; constant.
        /// </summary>
        public static string EmptyStringLiteralInspectionQuickFix {
            get {
                return ResourceManager.GetString("EmptyStringLiteralInspectionQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;vbNullString&apos; preferred to empty string literals.
        /// </summary>
        public static string EmptyStringLiteralInspectionResultFormat {
            get {
                return ResourceManager.GetString("EmptyStringLiteralInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider exposing a property instead..
        /// </summary>
        public static string EncapsulatePublicFieldInspectionMeta {
            get {
                return ResourceManager.GetString("EncapsulatePublicFieldInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Public field breaks encapsulation.
        /// </summary>
        public static string EncapsulatePublicFieldInspectionName {
            get {
                return ResourceManager.GetString("EncapsulatePublicFieldInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Encapsulate field &apos;{0}&apos; with a property.
        /// </summary>
        public static string EncapsulatePublicFieldInspectionQuickFix {
            get {
                return ResourceManager.GetString("EncapsulatePublicFieldInspectionQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Public field &apos;{0}&apos; breaks encapsulation.
        /// </summary>
        public static string EncapsulatePublicFieldInspectionResultFormat {
            get {
                return ResourceManager.GetString("EncapsulatePublicFieldInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A member is written as a function, but used as a procedure. Unless the function is recursive, consider converting the &apos;Function&apos; into a &apos;Sub&apos;. If the function is recursive, none of its external callers are using the returned value..
        /// </summary>
        public static string FunctionReturnValueNotUsedInspectionMeta {
            get {
                return ResourceManager.GetString("FunctionReturnValueNotUsedInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Function return value is never used.
        /// </summary>
        public static string FunctionReturnValueNotUsedInspectionName {
            get {
                return ResourceManager.GetString("FunctionReturnValueNotUsedInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Return value of function &apos;{0}&apos; is never used..
        /// </summary>
        public static string FunctionReturnValueNotUsedInspectionResultFormat {
            get {
                return ResourceManager.GetString("FunctionReturnValueNotUsedInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bracketed expressions are evaluated by the host application at runtime, which means VBA can&apos;t validate the expression at compile-time. Consider using the host application&apos;s object model instead..
        /// </summary>
        public static string HostSpecificExpressionInspectionMeta {
            get {
                return ResourceManager.GetString("HostSpecificExpressionInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Host-specific bracketed expression is only evaluated at runtime.
        /// </summary>
        public static string HostSpecificExpressionInspectionName {
            get {
                return ResourceManager.GetString("HostSpecificExpressionInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Expression &apos;{0}&apos; cannot be validated at compile-time..
        /// </summary>
        public static string HostSpecificExpressionInspectionResultFormat {
            get {
                return ResourceManager.GetString("HostSpecificExpressionInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Hungarian notation makes code less readable, and is redundant when strongly typed variables and meaningful names are used..
        /// </summary>
        public static string HungarianNotationInspectionMeta {
            get {
                return ResourceManager.GetString("HungarianNotationInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Variable uses Hungarian notation..
        /// </summary>
        public static string HungarianNotationInspectionName {
            get {
                return ResourceManager.GetString("HungarianNotationInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider renaming {0} &apos;{1}&apos;.
        /// </summary>
        public static string IdentifierNameInspectionResultFormat {
            get {
                return ResourceManager.GetString("IdentifierNameInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} &apos;{1}&apos; is not used.
        /// </summary>
        public static string IdentifierNotUsedInspectionResultFormat {
            get {
                return ResourceManager.GetString("IdentifierNotUsedInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ignore once.
        /// </summary>
        public static string IgnoreOnce {
            get {
                return ResourceManager.GetString("IgnoreOnce", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implicit references to the active sheet make the code frail and harder to debug. Consider making these references explicit when they&apos;re intended, and prefer working off object references. Ignore if the member call is referring to a type Rubberduck can&apos;t resolve..
        /// </summary>
        public static string ImplicitActiveSheetReferenceInspectionMeta {
            get {
                return ResourceManager.GetString("ImplicitActiveSheetReferenceInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implicit reference to ActiveSheet.
        /// </summary>
        public static string ImplicitActiveSheetReferenceInspectionName {
            get {
                return ResourceManager.GetString("ImplicitActiveSheetReferenceInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Member &apos;{0}&apos; implicitly references ActiveSheet.
        /// </summary>
        public static string ImplicitActiveSheetReferenceInspectionResultFormat {
            get {
                return ResourceManager.GetString("ImplicitActiveSheetReferenceInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implicit references to the active workbook make the code frail and harder to debug. Consider making these references explicit when they&apos;re intended, and prefer working off object references. Ignore if the member call is referring to a type Rubberduck can&apos;t resolve..
        /// </summary>
        public static string ImplicitActiveWorkbookReferenceInspectionMeta {
            get {
                return ResourceManager.GetString("ImplicitActiveWorkbookReferenceInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implicit reference to ActiveWorkbook.
        /// </summary>
        public static string ImplicitActiveWorkbookReferenceInspectionName {
            get {
                return ResourceManager.GetString("ImplicitActiveWorkbookReferenceInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Member &apos;{0}&apos; implicitly references ActiveWorkbook.
        /// </summary>
        public static string ImplicitActiveWorkbookReferenceInspectionResultFormat {
            get {
                return ResourceManager.GetString("ImplicitActiveWorkbookReferenceInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameters are passed by reference unless specified otherwise, which can be confusing and bug-prone. Prefer passing parameters by value, and specify ByRef explicitly when passing parameters by reference..
        /// </summary>
        public static string ImplicitByRefParameterInspectionMeta {
            get {
                return ResourceManager.GetString("ImplicitByRefParameterInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implicit ByRef parameter.
        /// </summary>
        public static string ImplicitByRefParameterInspectionName {
            get {
                return ResourceManager.GetString("ImplicitByRefParameterInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter &apos;{0}&apos; is implicitly passed by reference.
        /// </summary>
        public static string ImplicitByRefParameterInspectionResultFormat {
            get {
                return ResourceManager.GetString("ImplicitByRefParameterInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Pass parameter by reference explicitly.
        /// </summary>
        public static string ImplicitByRefParameterQuickFix {
            get {
                return ResourceManager.GetString("ImplicitByRefParameterQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Such assignments look like they are assigning an object variable to a value type on the surface, but they are actually assigning that object&apos;s default member, implicitly. Consider referring to the default member explicitly, for improved readability..
        /// </summary>
        public static string ImplicitDefaultMemberAssignmentInspectionMeta {
            get {
                return ResourceManager.GetString("ImplicitDefaultMemberAssignmentInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implicit default member assignment.
        /// </summary>
        public static string ImplicitDefaultMemberAssignmentInspectionName {
            get {
                return ResourceManager.GetString("ImplicitDefaultMemberAssignmentInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Assignment to &apos;{0}&apos; implicitly assigns default member of class &apos;{1}&apos;.
        /// </summary>
        public static string ImplicitDefaultMemberAssignmentInspectionResultFormat {
            get {
                return ResourceManager.GetString("ImplicitDefaultMemberAssignmentInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Module members are public by default, which can be counter-intuitive. Consider specifying explicit access modifiers to avoid ambiguity..
        /// </summary>
        public static string ImplicitPublicMemberInspectionMeta {
            get {
                return ResourceManager.GetString("ImplicitPublicMemberInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implicitly public member.
        /// </summary>
        public static string ImplicitPublicMemberInspectionName {
            get {
                return ResourceManager.GetString("ImplicitPublicMemberInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Member &apos;{0}&apos; is implicitly public.
        /// </summary>
        public static string ImplicitPublicMemberInspectionResultFormat {
            get {
                return ResourceManager.GetString("ImplicitPublicMemberInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} &apos;{1}&apos; is implicitly Variant.
        /// </summary>
        public static string ImplicitVariantDeclarationInspectionResultFormat {
            get {
                return ResourceManager.GetString("ImplicitVariantDeclarationInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Members with a return value implicitly return a &apos;Variant&apos; unless specified otherwise. Consider returning an explicit &apos;Variant&apos; when the return type isn&apos;t known, or specify it explicitly..
        /// </summary>
        public static string ImplicitVariantReturnTypeInspectionMeta {
            get {
                return ResourceManager.GetString("ImplicitVariantReturnTypeInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Member return type is implicitly &apos;Variant&apos;.
        /// </summary>
        public static string ImplicitVariantReturnTypeInspectionName {
            get {
                return ResourceManager.GetString("ImplicitVariantReturnTypeInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Return type of member &apos;{0}&apos; is implicitly &apos;Variant&apos;.
        /// </summary>
        public static string ImplicitVariantReturnTypeInspectionResultFormat {
            get {
                return ResourceManager.GetString("ImplicitVariantReturnTypeInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Declaration.
        /// </summary>
        public static string Inspections_Declaration {
            get {
                return ResourceManager.GetString("Inspections_Declaration", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to TODO.
        /// </summary>
        public static string Inspections_UnassignedVariableTodo {
            get {
                return ResourceManager.GetString("Inspections_UnassignedVariableTodo", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Usage.
        /// </summary>
        public static string Inspections_Usage {
            get {
                return ResourceManager.GetString("Inspections_Usage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Introduce local variable.
        /// </summary>
        public static string IntroduceLocalVariableQuickFix {
            get {
                return ResourceManager.GetString("IntroduceLocalVariableQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Context type &apos;{0}&apos; is not valid for {1}..
        /// </summary>
        public static string InvalidContextTypeInspectionFix {
            get {
                return ResourceManager.GetString("InvalidContextTypeInspectionFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Language opportunities.
        /// </summary>
        public static string LanguageOpportunities {
            get {
                return ResourceManager.GetString("LanguageOpportunities", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Maintainability &amp; readability issues.
        /// </summary>
        public static string MaintainabilityAndReadabilityIssues {
            get {
                return ResourceManager.GetString("MaintainabilityAndReadabilityIssues", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Write variable on one line.
        /// </summary>
        public static string MakeSingleLineParameterQuickFix {
            get {
                return ResourceManager.GetString("MakeSingleLineParameterQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A member access is being used that is not declared on the object&apos;s interface. This is most likely an error. If the member access is using the object&apos;s extensible interface, consider using a non-extensible equivalent to allow compile time checks that will avoid the possibility of a run-time error 438..
        /// </summary>
        public static string MemberNotOnInterfaceInspectionMeta {
            get {
                return ResourceManager.GetString("MemberNotOnInterfaceInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Member does not exist on interface.
        /// </summary>
        public static string MemberNotOnInterfaceInspectionName {
            get {
                return ResourceManager.GetString("MemberNotOnInterfaceInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Member &apos;{0}&apos; is not declared on the interface for type &apos;{1}&apos;..
        /// </summary>
        public static string MemberNotOnInterfaceInspectionResultFormat {
            get {
                return ResourceManager.GetString("MemberNotOnInterfaceInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An annotation parameter is missing or incorrectly specified. The correct syntax is : &apos;@Annotation([parameter])\nExample: &apos;@Folder(&quot;Parent.Child&quot;).
        /// </summary>
        public static string MissingAnnotationArgumentInspectionMeta {
            get {
                return ResourceManager.GetString("MissingAnnotationArgumentInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Missing annotation parameter.
        /// </summary>
        public static string MissingAnnotationArgumentInspectionName {
            get {
                return ResourceManager.GetString("MissingAnnotationArgumentInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Expression &apos;{0}&apos; was expected to contain a parameter, but none was specified..
        /// </summary>
        public static string MissingAnnotationArgumentInspectionResultFormat {
            get {
                return ResourceManager.GetString("MissingAnnotationArgumentInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The &apos;Public&apos; keyword can only be used at module level; its counterpart &apos;Private&apos; can also only be used at module level. &apos;Dim&apos; however, can be used to declare both procedure and module scope variables. For consistency, it would be preferable to reserve &apos;Dim&apos; for locals, and thus to use &apos;Private&apos; instead of &apos;Dim&apos; at module level..
        /// </summary>
        public static string ModuleScopeDimKeywordInspectionMeta {
            get {
                return ResourceManager.GetString("ModuleScopeDimKeywordInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use of &apos;Dim&apos; keyword at module level.
        /// </summary>
        public static string ModuleScopeDimKeywordInspectionName {
            get {
                return ResourceManager.GetString("ModuleScopeDimKeywordInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Module-level variable &apos;{0}&apos; is declared with the &apos;Dim&apos; keyword..
        /// </summary>
        public static string ModuleScopeDimKeywordInspectionResultFormat {
            get {
                return ResourceManager.GetString("ModuleScopeDimKeywordInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A module-level variable used only in one procedure should be declared in that procedure..
        /// </summary>
        public static string MoveFieldCloserToUsageInspectionMeta {
            get {
                return ResourceManager.GetString("MoveFieldCloserToUsageInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Scope of variable is broader than it needs to be.
        /// </summary>
        public static string MoveFieldCloserToUsageInspectionName {
            get {
                return ResourceManager.GetString("MoveFieldCloserToUsageInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Move module-level variable &apos;{0}&apos; to a smaller scope..
        /// </summary>
        public static string MoveFieldCloserToUsageInspectionResultFormat {
            get {
                return ResourceManager.GetString("MoveFieldCloserToUsageInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider continuing long signatures between parameters. Splitting a parameter declaration across multiple lines arguably hurts readability..
        /// </summary>
        public static string MultilineParameterInspectionMeta {
            get {
                return ResourceManager.GetString("MultilineParameterInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter declaration is split on multiple lines.
        /// </summary>
        public static string MultilineParameterInspectionName {
            get {
                return ResourceManager.GetString("MultilineParameterInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter &apos;{0}&apos; is specified on multiple lines.
        /// </summary>
        public static string MultilineParameterInspectionResultFormat {
            get {
                return ResourceManager.GetString("MultilineParameterInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Declaring multiple variables in the same instruction is legal, but should be used sparingly. Consider declaring variables closer to their usage, in a single instruction per declaration..
        /// </summary>
        public static string MultipleDeclarationsInspectionMeta {
            get {
                return ResourceManager.GetString("MultipleDeclarationsInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Multiple declarations in single instruction.
        /// </summary>
        public static string MultipleDeclarationsInspectionName {
            get {
                return ResourceManager.GetString("MultipleDeclarationsInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Instruction contains multiple declarations.
        /// </summary>
        public static string MultipleDeclarationsInspectionResultFormat {
            get {
                return ResourceManager.GetString("MultipleDeclarationsInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rubberduck only uses the first &apos;@Folder&apos; annotation in a code module; consider removing extraneous ones..
        /// </summary>
        public static string MultipleFolderAnnotationsInspectionMeta {
            get {
                return ResourceManager.GetString("MultipleFolderAnnotationsInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Module has more than one folder annotation..
        /// </summary>
        public static string MultipleFolderAnnotationsInspectionName {
            get {
                return ResourceManager.GetString("MultipleFolderAnnotationsInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; has more than one &apos;@Folder&apos; annotation..
        /// </summary>
        public static string MultipleFolderAnnotationsInspectionResultFormat {
            get {
                return ResourceManager.GetString("MultipleFolderAnnotationsInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This is likely a bug. The return value of a function or property getter must be assigned before exiting, otherwise the program will not be working with expected results. If a function has no meaningful return value, consider declaring it as a &apos;Sub&apos; procedure instead..
        /// </summary>
        public static string NonReturningFunctionInspectionMeta {
            get {
                return ResourceManager.GetString("NonReturningFunctionInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Non-returning function or property getter.
        /// </summary>
        public static string NonReturningFunctionInspectionName {
            get {
                return ResourceManager.GetString("NonReturningFunctionInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Return value for member &apos;{0}&apos; is never assigned.
        /// </summary>
        public static string NonReturningFunctionInspectionResultFormat {
            get {
                return ResourceManager.GetString("NonReturningFunctionInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to As far as Rubberduck can tell, this variable is an object variable, assigned without the &apos;Set&apos; keyword. This causes run-time error 91 &apos;Object or With block variable not set&apos;..
        /// </summary>
        public static string ObjectVariableNotSetInspectionMeta {
            get {
                return ResourceManager.GetString("ObjectVariableNotSetInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Object variable assignment requires &apos;Set&apos; keyword.
        /// </summary>
        public static string ObjectVariableNotSetInspectionName {
            get {
                return ResourceManager.GetString("ObjectVariableNotSetInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Object variable &apos;{0}&apos; is assigned without the &apos;Set&apos; keyword.
        /// </summary>
        public static string ObjectVariableNotSetInspectionResultFormat {
            get {
                return ResourceManager.GetString("ObjectVariableNotSetInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The &apos;Call&apos; statement is no longer required to call procedures, and only exists in the language to support legacy code that required it; it can be safely rewritten to an implicit call..
        /// </summary>
        public static string ObsoleteCallStatementInspectionMeta {
            get {
                return ResourceManager.GetString("ObsoleteCallStatementInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use of &apos;Call&apos; statement.
        /// </summary>
        public static string ObsoleteCallStatementInspectionName {
            get {
                return ResourceManager.GetString("ObsoleteCallStatementInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Assignment uses obsolete &apos;Call&apos; modifier.
        /// </summary>
        public static string ObsoleteCallStatementInspectionResultFormat {
            get {
                return ResourceManager.GetString("ObsoleteCallStatementInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The &apos;Rem&apos; statement only exists in the language to support legacy code that required it; it can be safely replaced with an apostrophe / single-quote comment..
        /// </summary>
        public static string ObsoleteCommentSyntaxInspectionMeta {
            get {
                return ResourceManager.GetString("ObsoleteCommentSyntaxInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use of &apos;Rem&apos; statement.
        /// </summary>
        public static string ObsoleteCommentSyntaxInspectionName {
            get {
                return ResourceManager.GetString("ObsoleteCommentSyntaxInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Comment uses obsolete &apos;Rem&apos; marker.
        /// </summary>
        public static string ObsoleteCommentSyntaxInspectionResultFormat {
            get {
                return ResourceManager.GetString("ObsoleteCommentSyntaxInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The &apos;Global&apos; keyword only exists in the language to support legacy code that required it; it can be safely replaced with the &apos;Public&apos; modifier..
        /// </summary>
        public static string ObsoleteGlobalInspectionMeta {
            get {
                return ResourceManager.GetString("ObsoleteGlobalInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use of &apos;Global&apos; access modifier.
        /// </summary>
        public static string ObsoleteGlobalInspectionName {
            get {
                return ResourceManager.GetString("ObsoleteGlobalInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Replace &apos;Global&apos; access modifier with &apos;Public&apos;.
        /// </summary>
        public static string ObsoleteGlobalInspectionQuickFix {
            get {
                return ResourceManager.GetString("ObsoleteGlobalInspectionQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} &apos;{1}&apos; uses obsolete &apos;Global&apos; access modifier.
        /// </summary>
        public static string ObsoleteGlobalInspectionResultFormat {
            get {
                return ResourceManager.GetString("ObsoleteGlobalInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The &apos;Let&apos; statement only exists in the language to support legacy code that required it; it can be safely removed, since modern VBA does not require that keyword for value assignments..
        /// </summary>
        public static string ObsoleteLetStatementInspectionMeta {
            get {
                return ResourceManager.GetString("ObsoleteLetStatementInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use of explicit &apos;Let&apos; statement.
        /// </summary>
        public static string ObsoleteLetStatementInspectionName {
            get {
                return ResourceManager.GetString("ObsoleteLetStatementInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Assignment uses obsolete &apos;Let&apos; modifier.
        /// </summary>
        public static string ObsoleteLetStatementInspectionResultFormat {
            get {
                return ResourceManager.GetString("ObsoleteLetStatementInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type hint characters only exist in the language to support legacy code that required it; they can be safely replaced in declarations with an &quot;As&quot; type clause that specifies the type explicitly, and they can be omitted in other identifier references..
        /// </summary>
        public static string ObsoleteTypeHintInspectionMeta {
            get {
                return ResourceManager.GetString("ObsoleteTypeHintInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type hint usage.
        /// </summary>
        public static string ObsoleteTypeHintInspectionName {
            get {
                return ResourceManager.GetString("ObsoleteTypeHintInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} of {1} &apos;{2}&apos; uses an obsolete type hint.
        /// </summary>
        public static string ObsoleteTypeHintInspectionResultFormat {
            get {
                return ResourceManager.GetString("ObsoleteTypeHintInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Arrays are typically zero-based. This option changes the default lower boundary for implicitly-sized arrays, which can introduce off-by-one errors if one isn&apos;t cautious..
        /// </summary>
        public static string OptionBaseInspectionMeta {
            get {
                return ResourceManager.GetString("OptionBaseInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;Option Base 1&apos; is specified.
        /// </summary>
        public static string OptionBaseInspectionName {
            get {
                return ResourceManager.GetString("OptionBaseInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Component &apos;{0}&apos; uses &apos;Option Base 1&apos;.
        /// </summary>
        public static string OptionBaseInspectionResultFormat {
            get {
                return ResourceManager.GetString("OptionBaseInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This is the default setting, it does not need to be specified..
        /// </summary>
        public static string OptionBaseZeroInspectionMeta {
            get {
                return ResourceManager.GetString("OptionBaseZeroInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;Option Base 0&apos; is redundant.
        /// </summary>
        public static string OptionBaseZeroInspectionName {
            get {
                return ResourceManager.GetString("OptionBaseZeroInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Component &apos;{0}&apos; uses &apos;Option Base 0&apos;.
        /// </summary>
        public static string OptionBaseZeroInspectionResultFormat {
            get {
                return ResourceManager.GetString("OptionBaseZeroInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to VBA will happily compile a typo: use &apos;Option Explicit&apos; to prevent successfully compiling an erroneous program..
        /// </summary>
        public static string OptionExplicitInspectionMeta {
            get {
                return ResourceManager.GetString("OptionExplicitInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;Option Explicit&apos; is not specified.
        /// </summary>
        public static string OptionExplicitInspectionName {
            get {
                return ResourceManager.GetString("OptionExplicitInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Option Explicit is not specified in &apos;{0}&apos;.
        /// </summary>
        public static string OptionExplicitInspectionResultFormat {
            get {
                return ResourceManager.GetString("OptionExplicitInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Specify &apos;Option Explicit&apos;.
        /// </summary>
        public static string OptionExplicitQuickFix {
            get {
                return ResourceManager.GetString("OptionExplicitQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A parameter that is passed by reference and isn&apos;t assigned a new value/reference, could be passed by value instead..
        /// </summary>
        public static string ParameterCanBeByValInspectionMeta {
            get {
                return ResourceManager.GetString("ParameterCanBeByValInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter can be passed by value.
        /// </summary>
        public static string ParameterCanBeByValInspectionName {
            get {
                return ResourceManager.GetString("ParameterCanBeByValInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter &apos;{0}&apos; can be passed by value.
        /// </summary>
        public static string ParameterCanBeByValInspectionResultFormat {
            get {
                return ResourceManager.GetString("ParameterCanBeByValInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A parameter is passed into a member that does not use it. Consider removing that parameter..
        /// </summary>
        public static string ParameterNotUsedInspectionMeta {
            get {
                return ResourceManager.GetString("ParameterNotUsedInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter is not referred to.
        /// </summary>
        public static string ParameterNotUsedInspectionName {
            get {
                return ResourceManager.GetString("ParameterNotUsedInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter &apos;{0}&apos; is never used.
        /// </summary>
        public static string ParameterNotUsedInspectionResultFormat {
            get {
                return ResourceManager.GetString("ParameterNotUsedInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Pass parameter by reference.
        /// </summary>
        public static string PassParameterByReferenceQuickFix {
            get {
                return ResourceManager.GetString("PassParameterByReferenceQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Pass parameter by value.
        /// </summary>
        public static string PassParameterByValueQuickFix {
            get {
                return ResourceManager.GetString("PassParameterByValueQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A procedure that only has one parameter passed by reference that is assigned a new value/reference before the procedure exits, is using a ByRef parameter as a return value: consider making it a function instead..
        /// </summary>
        public static string ProcedureCanBeWrittenAsFunctionInspectionMeta {
            get {
                return ResourceManager.GetString("ProcedureCanBeWrittenAsFunctionInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Procedure can be written as a function.
        /// </summary>
        public static string ProcedureCanBeWrittenAsFunctionInspectionName {
            get {
                return ResourceManager.GetString("ProcedureCanBeWrittenAsFunctionInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Procedure &apos;{0}&apos; can be written as a function..
        /// </summary>
        public static string ProcedureCanBeWrittenAsFunctionInspectionResultFormat {
            get {
                return ResourceManager.GetString("ProcedureCanBeWrittenAsFunctionInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rubberduck could not find any caller for a procedure. If the procedure is hooked to a macro-button, used as a user-defined function (UDF) or handles an application event that Rubberduck didn&apos;t know of you can safely ignore this inspection result; otherwise, consider removing it..
        /// </summary>
        public static string ProcedureNotUsedInspectionMeta {
            get {
                return ResourceManager.GetString("ProcedureNotUsedInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Procedure is not referred to.
        /// </summary>
        public static string ProcedureNotUsedInspectionName {
            get {
                return ResourceManager.GetString("ProcedureNotUsedInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implement as function and update usages..
        /// </summary>
        public static string ProcedureShouldBeFunctionInspectionQuickFix {
            get {
                return ResourceManager.GetString("ProcedureShouldBeFunctionInspectionQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Procedure &apos;{0}&apos; can be written as a function.
        /// </summary>
        public static string ProcedureShouldBeFunctionInspectionResultFormat {
            get {
                return ResourceManager.GetString("ProcedureShouldBeFunctionInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0}: {1} - {2} {3}.{4}, line {5}.
        /// </summary>
        public static string QualifiedSelectionInspection {
            get {
                return ResourceManager.GetString("QualifiedSelectionInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Fix all occurences.
        /// </summary>
        public static string QuickFix_All {
            get {
                return ResourceManager.GetString("QuickFix_All", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Fix all occurrences in module.
        /// </summary>
        public static string QuickFix_ThisModule {
            get {
                return ResourceManager.GetString("QuickFix_ThisModule", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Fix all occurrences in procedure.
        /// </summary>
        public static string QuickFix_ThisProcedure {
            get {
                return ResourceManager.GetString("QuickFix_ThisProcedure", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Fix all occurrences in project.
        /// </summary>
        public static string QuickFix_ThisProject {
            get {
                return ResourceManager.GetString("QuickFix_ThisProject", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Change &apos;{0}&apos; to &apos;{1}&apos;.
        /// </summary>
        public static string QuickFixUseTypedFunction_ {
            get {
                return ResourceManager.GetString("QuickFixUseTypedFunction_", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove comment.
        /// </summary>
        public static string RemoveCommentQuickFix {
            get {
                return ResourceManager.GetString("RemoveCommentQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove empty If block.
        /// </summary>
        public static string RemoveEmptyIfBlockQuickFix {
            get {
                return ResourceManager.GetString("RemoveEmptyIfBlockQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove obsolete statement.
        /// </summary>
        public static string RemoveObsoleteStatementQuickFix {
            get {
                return ResourceManager.GetString("RemoveObsoleteStatementQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove &apos;Option Base&apos; statement.
        /// </summary>
        public static string RemoveOptionBaseStatementQuickFix {
            get {
                return ResourceManager.GetString("RemoveOptionBaseStatementQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove type hints.
        /// </summary>
        public static string RemoveTypeHintsQuickFix {
            get {
                return ResourceManager.GetString("RemoveTypeHintsQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove unassigned variable.
        /// </summary>
        public static string RemoveUnassignedIdentifierQuickFix {
            get {
                return ResourceManager.GetString("RemoveUnassignedIdentifierQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove usage (breaks code).
        /// </summary>
        public static string RemoveUnassignedVariableUsageQuickFix {
            get {
                return ResourceManager.GetString("RemoveUnassignedVariableUsageQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove unused declaration.
        /// </summary>
        public static string RemoveUnusedDeclarationQuickFix {
            get {
                return ResourceManager.GetString("RemoveUnusedDeclarationQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove unused parameter.
        /// </summary>
        public static string RemoveUnusedParameterQuickFix {
            get {
                return ResourceManager.GetString("RemoveUnusedParameterQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Replace &apos;Rem&apos; usage with a single-quote comment marker.
        /// </summary>
        public static string ReplaceCommentMarkerQuickFix {
            get {
                return ResourceManager.GetString("ReplaceCommentMarkerQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A self-assigned object variable declaration at procedure scope changes how nulling the reference works, which can lead to unexpected behavior..
        /// </summary>
        public static string SelfAssignedDeclarationInspectionMeta {
            get {
                return ResourceManager.GetString("SelfAssignedDeclarationInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Object variable reference is self-assigned.
        /// </summary>
        public static string SelfAssignedDeclarationInspectionName {
            get {
                return ResourceManager.GetString("SelfAssignedDeclarationInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Object reference &apos;{0}&apos; is self-assigned.
        /// </summary>
        public static string SelfAssignedDeclarationInspectionResultFormat {
            get {
                return ResourceManager.GetString("SelfAssignedDeclarationInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Return explicit Variant.
        /// </summary>
        public static string SetExplicitVariantReturnTypeQuickFix {
            get {
                return ResourceManager.GetString("SetExplicitVariantReturnTypeQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use &apos;Set&apos; keyword.
        /// </summary>
        public static string SetObjectVariableQuickFix {
            get {
                return ResourceManager.GetString("SetObjectVariableQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Specify Public access modifier explicitly.
        /// </summary>
        public static string SpecifyExplicitPublicModifierQuickFix {
            get {
                return ResourceManager.GetString("SpecifyExplicitPublicModifierQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Separate multiple declarations into multiple instructions.
        /// </summary>
        public static string SplitMultipleDeclarationsQuickFix {
            get {
                return ResourceManager.GetString("SplitMultipleDeclarationsQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This is likely a bug. A variable is being referred to, but is never assigned..
        /// </summary>
        public static string UnassignedVariableUsageInspectionMeta {
            get {
                return ResourceManager.GetString("UnassignedVariableUsageInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Variable is used but not assigned.
        /// </summary>
        public static string UnassignedVariableUsageInspectionName {
            get {
                return ResourceManager.GetString("UnassignedVariableUsageInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Variable &apos;{0}&apos; is used but not assigned.
        /// </summary>
        public static string UnassignedVariableUsageInspectionResultFormat {
            get {
                return ResourceManager.GetString("UnassignedVariableUsageInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Code that uses undeclared variables does not compile when Option Explicit is specified. Undeclared variables are always Variant, a data type that incurs unnecessary overhead and storage..
        /// </summary>
        public static string UndeclaredVariableInspectionMeta {
            get {
                return ResourceManager.GetString("UndeclaredVariableInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Undeclared variable.
        /// </summary>
        public static string UndeclaredVariableInspectionName {
            get {
                return ResourceManager.GetString("UndeclaredVariableInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Local variable &apos;{0}&apos; is not declared.
        /// </summary>
        public static string UndeclaredVariableInspectionResultFormat {
            get {
                return ResourceManager.GetString("UndeclaredVariableInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A string-returning equivalent function exists and should preferably be used to avoid implicit type conversions. 
        ///If the parameter can be null, ignore this inspection result; passing a null value to a function expecting a string would raise a type mismatch runtime error..
        /// </summary>
        public static string UntypedFunctionUsageInspectionMeta {
            get {
                return ResourceManager.GetString("UntypedFunctionUsageInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use of variant-returning string function.
        /// </summary>
        public static string UntypedFunctionUsageInspectionName {
            get {
                return ResourceManager.GetString("UntypedFunctionUsageInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Replace function `{0}` with existing typed function.
        /// </summary>
        public static string UntypedFunctionUsageInspectionResultFormat {
            get {
                return ResourceManager.GetString("UntypedFunctionUsageInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identifier names should indicate what they&apos;re used for and should be readable; avoid disemvoweling, numeric suffixes, and 1-2 character names..
        /// </summary>
        public static string UseMeaningfulNameInspectionMeta {
            get {
                return ResourceManager.GetString("UseMeaningfulNameInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use meaningful names.
        /// </summary>
        public static string UseMeaningfulNameInspectionName {
            get {
                return ResourceManager.GetString("UseMeaningfulNameInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Variable does not seem to be assigned. If Rubberduck is correct, the variable could probably be safely removed..
        /// </summary>
        public static string VariableNotAssignedInspectionMeta {
            get {
                return ResourceManager.GetString("VariableNotAssignedInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Variable is not assigned.
        /// </summary>
        public static string VariableNotAssignedInspectionName {
            get {
                return ResourceManager.GetString("VariableNotAssignedInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Variable &apos;{0}&apos; is not assigned.
        /// </summary>
        public static string VariableNotAssignedInspectionResultFormat {
            get {
                return ResourceManager.GetString("VariableNotAssignedInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Variable is not referred to.
        /// </summary>
        public static string VariableNotUsedInspectionMeta {
            get {
                return ResourceManager.GetString("VariableNotUsedInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Variable is not referred to.
        /// </summary>
        public static string VariableNotUsedInspectionName {
            get {
                return ResourceManager.GetString("VariableNotUsedInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A variable whose type isn&apos;t explicitly declared, is implicitly &apos;Variant&apos;. Consider making it an explicit &apos;Variant&apos; if that&apos;s intended, or declare a more specific type..
        /// </summary>
        public static string VariableTypeNotDeclaredInspectionMeta {
            get {
                return ResourceManager.GetString("VariableTypeNotDeclaredInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implicitly &apos;Variant&apos; variable.
        /// </summary>
        public static string VariableTypeNotDeclaredInspectionName {
            get {
                return ResourceManager.GetString("VariableTypeNotDeclaredInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} &apos;{1}&apos; is implicitly &apos;Variant&apos;.
        /// </summary>
        public static string VariableTypeNotDeclaredInspectionResultFormat {
            get {
                return ResourceManager.GetString("VariableTypeNotDeclaredInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Add to whitelist.
        /// </summary>
        public static string WhiteListIdentifierQuickFix {
            get {
                return ResourceManager.GetString("WhiteListIdentifierQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A property that exposes a mutator but no accessor is a design smell and makes a confusing API. Consider exposing a getter, or converting the mutator to a method..
        /// </summary>
        public static string WriteOnlyPropertyInspectionMeta {
            get {
                return ResourceManager.GetString("WriteOnlyPropertyInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Write-only property.
        /// </summary>
        public static string WriteOnlyPropertyInspectionName {
            get {
                return ResourceManager.GetString("WriteOnlyPropertyInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Property &apos;{0}&apos; has no getter.
        /// </summary>
        public static string WriteOnlyPropertyInspectionResultFormat {
            get {
                return ResourceManager.GetString("WriteOnlyPropertyInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Add property get accessor.
        /// </summary>
        public static string WriteOnlyPropertyQuickFix {
            get {
                return ResourceManager.GetString("WriteOnlyPropertyQuickFix", resourceCulture);
            }
        }
    }
}
