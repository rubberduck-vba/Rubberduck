//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Rubberduck.Parsing.Inspections.Resources {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public class InspectionsUI {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal InspectionsUI() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Rubberduck.Parsing.Inspections.Resources.InspectionsUI", typeof(InspectionsUI).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} ({1} results).
        /// </summary>
        public static string AggregateInspectionResultFormat {
            get {
                return ResourceManager.GetString("AggregateInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Excel Application object does not implement the WorksheetFunction interface directly. All calls made to WorksheetFunction members are handled as late bound and errors in the called member will be returned wrapped in a Variant of VbVarType.vbError. This makes errors un-trappable with error handlers and adds a performance penalty in comparison to early bound calls. Consider calling Application.WorksheetFunction explicitly. Note: If this call generated errors in the past, those errors were ignored. If appl [rest of string was truncated]&quot;;.
        /// </summary>
        public static string ApplicationWorksheetFunctionInspectionMeta {
            get {
                return ResourceManager.GetString("ApplicationWorksheetFunctionInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Late bound WorksheetFunction call..
        /// </summary>
        public static string ApplicationWorksheetFunctionInspectionName {
            get {
                return ResourceManager.GetString("ApplicationWorksheetFunctionInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use of late bound Application.{0} member..
        /// </summary>
        public static string ApplicationWorksheetFunctionInspectionResultFormat {
            get {
                return ResourceManager.GetString("ApplicationWorksheetFunctionInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use Application.WorksheetFunction explicitly..
        /// </summary>
        public static string ApplicationWorksheetFunctionQuickFix {
            get {
                return ResourceManager.GetString("ApplicationWorksheetFunctionQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter is passed by value, but is assigned a new value/reference. Consider making a local copy instead if the caller isn&apos;t supposed to know the new value. If the caller should see the new value, the parameter should be passed ByRef instead, and you have a bug..
        /// </summary>
        public static string AssignedByValParameterInspectionMeta {
            get {
                return ResourceManager.GetString("AssignedByValParameterInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to ByVal parameter is assigned.
        /// </summary>
        public static string AssignedByValParameterInspectionName {
            get {
                return ResourceManager.GetString("AssignedByValParameterInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter &apos;{0}&apos; is passed ByVal and assigned a value.
        /// </summary>
        public static string AssignedByValParameterInspectionResultFormat {
            get {
                return ResourceManager.GetString("AssignedByValParameterInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Create and use a local copy of the parameter.
        /// </summary>
        public static string AssignedByValParameterMakeLocalCopyQuickFix {
            get {
                return ResourceManager.GetString("AssignedByValParameterMakeLocalCopyQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A member is assigned True/False in different branches of an if statement with no other statements in the conditional. Use the condition directly to the member instead..
        /// </summary>
        public static string BooleanAssignedInIfElseInspectionMeta {
            get {
                return ResourceManager.GetString("BooleanAssignedInIfElseInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Boolean literal assignment in conditional.
        /// </summary>
        public static string BooleanAssignedInIfElseInspectionName {
            get {
                return ResourceManager.GetString("BooleanAssignedInIfElseInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Boolean literal &apos;{0}&apos; assigned in conditional.
        /// </summary>
        public static string BooleanAssignedInIfElseInspectionResultFormat {
            get {
                return ResourceManager.GetString("BooleanAssignedInIfElseInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Replace &apos;Dim&apos; with &apos;Private&apos;.
        /// </summary>
        public static string ChangeDimToPrivateQuickFix {
            get {
                return ResourceManager.GetString("ChangeDimToPrivateQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Code Quality Issues.
        /// </summary>
        public static string CodeInspectionSettings_CodeQualityIssues {
            get {
                return ResourceManager.GetString("CodeInspectionSettings_CodeQualityIssues", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Language Opportunities.
        /// </summary>
        public static string CodeInspectionSettings_LanguageOpportunities {
            get {
                return ResourceManager.GetString("CodeInspectionSettings_LanguageOpportunities", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Maintainability and Readability Issues.
        /// </summary>
        public static string CodeInspectionSettings_MaintainabilityAndReadabilityIssues {
            get {
                return ResourceManager.GetString("CodeInspectionSettings_MaintainabilityAndReadabilityIssues", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Performance.
        /// </summary>
        public static string CodeInspectionSettings_Performance {
            get {
                return ResourceManager.GetString("CodeInspectionSettings_Performance", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rubberduck Opportunities.
        /// </summary>
        public static string CodeInspectionSettings_RubberduckOpportunities {
            get {
                return ResourceManager.GetString("CodeInspectionSettings_RubberduckOpportunities", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do Not Show.
        /// </summary>
        public static string CodeInspectionSeverity_DoNotShow {
            get {
                return ResourceManager.GetString("CodeInspectionSeverity_DoNotShow", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Error.
        /// </summary>
        public static string CodeInspectionSeverity_Error {
            get {
                return ResourceManager.GetString("CodeInspectionSeverity_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Hint.
        /// </summary>
        public static string CodeInspectionSeverity_Hint {
            get {
                return ResourceManager.GetString("CodeInspectionSeverity_Hint", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Suggestion.
        /// </summary>
        public static string CodeInspectionSeverity_Suggestion {
            get {
                return ResourceManager.GetString("CodeInspectionSeverity_Suggestion", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Warning.
        /// </summary>
        public static string CodeInspectionSeverity_Warning {
            get {
                return ResourceManager.GetString("CodeInspectionSeverity_Warning", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rubberduck could not find any reference to constant. Consider removing the unused declaration..
        /// </summary>
        public static string ConstantNotUsedInspectionMeta {
            get {
                return ResourceManager.GetString("ConstantNotUsedInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Constant is not used.
        /// </summary>
        public static string ConstantNotUsedInspectionName {
            get {
                return ResourceManager.GetString("ConstantNotUsedInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Convert function to procedure.
        /// </summary>
        public static string ConvertFunctionToProcedureQuickFix {
            get {
                return ResourceManager.GetString("ConvertFunctionToProcedureQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Declare as explicit Variant.
        /// </summary>
        public static string DeclareAsExplicitVariantQuickFix {
            get {
                return ResourceManager.GetString("DeclareAsExplicitVariantQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider naming your VBA project..
        /// </summary>
        public static string DefaultProjectNameInspectionMeta {
            get {
                return ResourceManager.GetString("DefaultProjectNameInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Project name is not specified.
        /// </summary>
        public static string DefaultProjectNameInspectionName {
            get {
                return ResourceManager.GetString("DefaultProjectNameInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Project &apos;{0}&apos; has default name.
        /// </summary>
        public static string DefaultProjectNameInspectionResultFormat {
            get {
                return ResourceManager.GetString("DefaultProjectNameInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Disable this inspection.
        /// </summary>
        public static string DisableThisInspection {
            get {
                return ResourceManager.GetString("DisableThisInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An empty &apos;Case&apos; block without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn&apos;t need to be written..
        /// </summary>
        public static string EmptyCaseBlockInspectionMeta {
            get {
                return ResourceManager.GetString("EmptyCaseBlockInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Empty &apos;Case&apos; block.
        /// </summary>
        public static string EmptyCaseBlockInspectionName {
            get {
                return ResourceManager.GetString("EmptyCaseBlockInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;Case&apos; block contains no executable statements.
        /// </summary>
        public static string EmptyCaseBlockInspectionResultFormat {
            get {
                return ResourceManager.GetString("EmptyCaseBlockInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An empty &apos;Do...While&apos; loop without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn&apos;t need to be written..
        /// </summary>
        public static string EmptyDoWhileBlockInspectionMeta {
            get {
                return ResourceManager.GetString("EmptyDoWhileBlockInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Empty &apos;Do...While&apos; Loop.
        /// </summary>
        public static string EmptyDoWhileBlockInspectionName {
            get {
                return ResourceManager.GetString("EmptyDoWhileBlockInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;Do...While&apos; loop contains no executable statements.
        /// </summary>
        public static string EmptyDoWhileBlockInspectionResultFormat {
            get {
                return ResourceManager.GetString("EmptyDoWhileBlockInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An empty &apos;Else&apos; loop without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn&apos;t need to be written..
        /// </summary>
        public static string EmptyElseBlockInspectionMeta {
            get {
                return ResourceManager.GetString("EmptyElseBlockInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Empty &apos;Else&apos; block.
        /// </summary>
        public static string EmptyElseBlockInspectionName {
            get {
                return ResourceManager.GetString("EmptyElseBlockInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;Else&apos; block contains no executable statements.
        /// </summary>
        public static string EmptyElseBlockInspectionResultFormat {
            get {
                return ResourceManager.GetString("EmptyElseBlockInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An empty &apos;For Each...Next&apos; loop without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn&apos;t need to be written..
        /// </summary>
        public static string EmptyForEachBlockInspectionMeta {
            get {
                return ResourceManager.GetString("EmptyForEachBlockInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Empty &apos;For Each...Next&apos; Loop.
        /// </summary>
        public static string EmptyForEachBlockInspectionName {
            get {
                return ResourceManager.GetString("EmptyForEachBlockInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;For-Each loop contains no executable statements.
        /// </summary>
        public static string EmptyForEachBlockInspectionResultFormat {
            get {
                return ResourceManager.GetString("EmptyForEachBlockInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An empty &apos;For...Next&apos; loop without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn&apos;t need to be written..
        /// </summary>
        public static string EmptyForLoopBlockInspectionMeta {
            get {
                return ResourceManager.GetString("EmptyForLoopBlockInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Empty &apos;For...Next&apos; Loop.
        /// </summary>
        public static string EmptyForLoopBlockInspectionName {
            get {
                return ResourceManager.GetString("EmptyForLoopBlockInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;For...Next&apos; loop contains no executable statements..
        /// </summary>
        public static string EmptyForLoopBlockInspectionResultFormat {
            get {
                return ResourceManager.GetString("EmptyForLoopBlockInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An empty conditional branch without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn&apos;t need to be written..
        /// </summary>
        public static string EmptyIfBlockInspectionMeta {
            get {
                return ResourceManager.GetString("EmptyIfBlockInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Empty conditional branch.
        /// </summary>
        public static string EmptyIfBlockInspectionName {
            get {
                return ResourceManager.GetString("EmptyIfBlockInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;If&apos; block contains no executable statements..
        /// </summary>
        public static string EmptyIfBlockInspectionResultFormat {
            get {
                return ResourceManager.GetString("EmptyIfBlockInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Empty modules and classes either point to not yet implemented functionality or represent unnecessary baggage that can hurt the maintainability of a project..
        /// </summary>
        public static string EmptyModuleInspectionMeta {
            get {
                return ResourceManager.GetString("EmptyModuleInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Empty module.
        /// </summary>
        public static string EmptyModuleInspectionName {
            get {
                return ResourceManager.GetString("EmptyModuleInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Module/class {0} is empty..
        /// </summary>
        public static string EmptyModuleInspectionResultFormat {
            get {
                return ResourceManager.GetString("EmptyModuleInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Prefer &apos;vbNullString&apos; to an empty string literal.
        /// </summary>
        public static string EmptyStringLiteralInspection {
            get {
                return ResourceManager.GetString("EmptyStringLiteralInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The built-in constant &apos;vbNullString&apos; is a null string pointer taking up 0 bytes of memory, that unambiguously conveys the intent of an empty string..
        /// </summary>
        public static string EmptyStringLiteralInspectionMeta {
            get {
                return ResourceManager.GetString("EmptyStringLiteralInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Empty string literal.
        /// </summary>
        public static string EmptyStringLiteralInspectionName {
            get {
                return ResourceManager.GetString("EmptyStringLiteralInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Replace empty string with the &apos;vbNullString&apos; constant.
        /// </summary>
        public static string EmptyStringLiteralInspectionQuickFix {
            get {
                return ResourceManager.GetString("EmptyStringLiteralInspectionQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;vbNullString&apos; preferred to empty string literals.
        /// </summary>
        public static string EmptyStringLiteralInspectionResultFormat {
            get {
                return ResourceManager.GetString("EmptyStringLiteralInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An empty &apos;Loop&apos; block without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn&apos;t need to be written..
        /// </summary>
        public static string EmptyWhileWendBlockInspectionMeta {
            get {
                return ResourceManager.GetString("EmptyWhileWendBlockInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Empty &apos;While...Wend&apos; loop.
        /// </summary>
        public static string EmptyWhileWendBlockInspectionName {
            get {
                return ResourceManager.GetString("EmptyWhileWendBlockInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;While...Wend&apos; loop contains no executable statements..
        /// </summary>
        public static string EmptyWhileWendBlockInspectionResultFormat {
            get {
                return ResourceManager.GetString("EmptyWhileWendBlockInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider exposing a property instead..
        /// </summary>
        public static string EncapsulatePublicFieldInspectionMeta {
            get {
                return ResourceManager.GetString("EncapsulatePublicFieldInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Public field breaks encapsulation.
        /// </summary>
        public static string EncapsulatePublicFieldInspectionName {
            get {
                return ResourceManager.GetString("EncapsulatePublicFieldInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Encapsulate field &apos;{0}&apos; with a property.
        /// </summary>
        public static string EncapsulatePublicFieldInspectionQuickFix {
            get {
                return ResourceManager.GetString("EncapsulatePublicFieldInspectionQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Public field &apos;{0}&apos; breaks encapsulation.
        /// </summary>
        public static string EncapsulatePublicFieldInspectionResultFormat {
            get {
                return ResourceManager.GetString("EncapsulatePublicFieldInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A member is written as a function, but used as a procedure. Unless the function is recursive, consider converting the &apos;Function&apos; into a &apos;Sub&apos;. If the function is recursive, none of its external callers are using the returned value..
        /// </summary>
        public static string FunctionReturnValueNotUsedInspectionMeta {
            get {
                return ResourceManager.GetString("FunctionReturnValueNotUsedInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Function return value is never used.
        /// </summary>
        public static string FunctionReturnValueNotUsedInspectionName {
            get {
                return ResourceManager.GetString("FunctionReturnValueNotUsedInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Return value of function &apos;{0}&apos; is never used..
        /// </summary>
        public static string FunctionReturnValueNotUsedInspectionResultFormat {
            get {
                return ResourceManager.GetString("FunctionReturnValueNotUsedInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bracketed expressions are evaluated by the host application at runtime, which means VBA can&apos;t validate the expression at compile-time. Consider using the host application&apos;s object model instead..
        /// </summary>
        public static string HostSpecificExpressionInspectionMeta {
            get {
                return ResourceManager.GetString("HostSpecificExpressionInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Host-specific bracketed expression is only evaluated at runtime.
        /// </summary>
        public static string HostSpecificExpressionInspectionName {
            get {
                return ResourceManager.GetString("HostSpecificExpressionInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Expression &apos;{0}&apos; cannot be validated at compile-time..
        /// </summary>
        public static string HostSpecificExpressionInspectionResultFormat {
            get {
                return ResourceManager.GetString("HostSpecificExpressionInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Hungarian notation makes code less readable, and is redundant when strongly typed variables and meaningful names are used..
        /// </summary>
        public static string HungarianNotationInspectionMeta {
            get {
                return ResourceManager.GetString("HungarianNotationInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Variable uses Hungarian notation..
        /// </summary>
        public static string HungarianNotationInspectionName {
            get {
                return ResourceManager.GetString("HungarianNotationInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider renaming {0} &apos;{1}&apos;.
        /// </summary>
        public static string IdentifierNameInspectionResultFormat {
            get {
                return ResourceManager.GetString("IdentifierNameInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} &apos;{1}&apos; is not used.
        /// </summary>
        public static string IdentifierNotUsedInspectionResultFormat {
            get {
                return ResourceManager.GetString("IdentifierNotUsedInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ignore once.
        /// </summary>
        public static string IgnoreOnce {
            get {
                return ResourceManager.GetString("IgnoreOnce", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An annotation meant to be specified at module level cannot be used to annotate members; annotations meant to be annotate members cannot be used at module level; module and member annotations should only be specified once..
        /// </summary>
        public static string IllegalAnnotationInspectionMeta {
            get {
                return ResourceManager.GetString("IllegalAnnotationInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Illegal annotation.
        /// </summary>
        public static string IllegalAnnotationInspectionName {
            get {
                return ResourceManager.GetString("IllegalAnnotationInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Annotation &apos;{0}&apos; is illegal in this context..
        /// </summary>
        public static string IllegalAnnotationInspectionResultFormat {
            get {
                return ResourceManager.GetString("IllegalAnnotationInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implicit references to the active sheet make the code frail and harder to debug. Consider making these references explicit when they&apos;re intended, and prefer working off object references. Ignore if the member call is referring to a type Rubberduck can&apos;t resolve..
        /// </summary>
        public static string ImplicitActiveSheetReferenceInspectionMeta {
            get {
                return ResourceManager.GetString("ImplicitActiveSheetReferenceInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implicit reference to ActiveSheet.
        /// </summary>
        public static string ImplicitActiveSheetReferenceInspectionName {
            get {
                return ResourceManager.GetString("ImplicitActiveSheetReferenceInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Member &apos;{0}&apos; implicitly references ActiveSheet.
        /// </summary>
        public static string ImplicitActiveSheetReferenceInspectionResultFormat {
            get {
                return ResourceManager.GetString("ImplicitActiveSheetReferenceInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implicit references to the active workbook make the code frail and harder to debug. Consider making these references explicit when they&apos;re intended, and prefer working off object references. Ignore if the member call is referring to a type Rubberduck can&apos;t resolve..
        /// </summary>
        public static string ImplicitActiveWorkbookReferenceInspectionMeta {
            get {
                return ResourceManager.GetString("ImplicitActiveWorkbookReferenceInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implicit reference to ActiveWorkbook.
        /// </summary>
        public static string ImplicitActiveWorkbookReferenceInspectionName {
            get {
                return ResourceManager.GetString("ImplicitActiveWorkbookReferenceInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Member &apos;{0}&apos; implicitly references ActiveWorkbook.
        /// </summary>
        public static string ImplicitActiveWorkbookReferenceInspectionResultFormat {
            get {
                return ResourceManager.GetString("ImplicitActiveWorkbookReferenceInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameters are passed by reference unless specified otherwise, which can be confusing and bug-prone. Prefer passing parameters by value, and specify ByRef explicitly when passing parameters by reference..
        /// </summary>
        public static string ImplicitByRefModifierInspectionMeta {
            get {
                return ResourceManager.GetString("ImplicitByRefModifierInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implicit ByRef parameter.
        /// </summary>
        public static string ImplicitByRefModifierInspectionName {
            get {
                return ResourceManager.GetString("ImplicitByRefModifierInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter &apos;{0}&apos; is implicitly passed by reference.
        /// </summary>
        public static string ImplicitByRefModifierInspectionResultFormat {
            get {
                return ResourceManager.GetString("ImplicitByRefModifierInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Pass parameter by reference explicitly.
        /// </summary>
        public static string ImplicitByRefModifierQuickFix {
            get {
                return ResourceManager.GetString("ImplicitByRefModifierQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Such assignments look like they are assigning an object variable to a value type on the surface, but they are actually assigning that object&apos;s default member, implicitly. Consider referring to the default member explicitly, for improved readability..
        /// </summary>
        public static string ImplicitDefaultMemberAssignmentInspectionMeta {
            get {
                return ResourceManager.GetString("ImplicitDefaultMemberAssignmentInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implicit default member assignment.
        /// </summary>
        public static string ImplicitDefaultMemberAssignmentInspectionName {
            get {
                return ResourceManager.GetString("ImplicitDefaultMemberAssignmentInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Assignment to &apos;{0}&apos; implicitly assigns default member of class &apos;{1}&apos;.
        /// </summary>
        public static string ImplicitDefaultMemberAssignmentInspectionResultFormat {
            get {
                return ResourceManager.GetString("ImplicitDefaultMemberAssignmentInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Module members are public by default, which can be counter-intuitive. Consider specifying explicit access modifiers to avoid ambiguity..
        /// </summary>
        public static string ImplicitPublicMemberInspectionMeta {
            get {
                return ResourceManager.GetString("ImplicitPublicMemberInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implicitly public member.
        /// </summary>
        public static string ImplicitPublicMemberInspectionName {
            get {
                return ResourceManager.GetString("ImplicitPublicMemberInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Member &apos;{0}&apos; is implicitly public.
        /// </summary>
        public static string ImplicitPublicMemberInspectionResultFormat {
            get {
                return ResourceManager.GetString("ImplicitPublicMemberInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} &apos;{1}&apos; is implicitly Variant.
        /// </summary>
        public static string ImplicitVariantDeclarationInspectionResultFormat {
            get {
                return ResourceManager.GetString("ImplicitVariantDeclarationInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Members with a return value implicitly return a &apos;Variant&apos; unless specified otherwise. Consider returning an explicit &apos;Variant&apos; when the return type isn&apos;t known, or specify it explicitly..
        /// </summary>
        public static string ImplicitVariantReturnTypeInspectionMeta {
            get {
                return ResourceManager.GetString("ImplicitVariantReturnTypeInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Member return type is implicitly &apos;Variant&apos;.
        /// </summary>
        public static string ImplicitVariantReturnTypeInspectionName {
            get {
                return ResourceManager.GetString("ImplicitVariantReturnTypeInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Return type of member &apos;{0}&apos; is implicitly &apos;Variant&apos;.
        /// </summary>
        public static string ImplicitVariantReturnTypeInspectionResultFormat {
            get {
                return ResourceManager.GetString("ImplicitVariantReturnTypeInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Declaration.
        /// </summary>
        public static string Inspections_Declaration {
            get {
                return ResourceManager.GetString("Inspections_Declaration", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to TODO.
        /// </summary>
        public static string Inspections_UnassignedVariableTodo {
            get {
                return ResourceManager.GetString("Inspections_UnassignedVariableTodo", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Usage.
        /// </summary>
        public static string Inspections_Usage {
            get {
                return ResourceManager.GetString("Inspections_Usage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The maximum value of a 16-bit signed integer is 32,767 - using a 32-bit (Long) integer data type where possible can help prevent &apos;Overflow&apos; run-time errors, and is better handled by modern CPUs..
        /// </summary>
        public static string IntegerDataTypeInspectionMeta {
            get {
                return ResourceManager.GetString("IntegerDataTypeInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use of 16-bit integer type.
        /// </summary>
        public static string IntegerDataTypeInspectionName {
            get {
                return ResourceManager.GetString("IntegerDataTypeInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} &apos;{1}&apos; is declared as Integer.
        /// </summary>
        public static string IntegerDataTypeInspectionResultFormat {
            get {
                return ResourceManager.GetString("IntegerDataTypeInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Change type to &apos;Long&apos;.
        /// </summary>
        public static string IntegerDataTypeQuickFix {
            get {
                return ResourceManager.GetString("IntegerDataTypeQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Introduce local variable.
        /// </summary>
        public static string IntroduceLocalVariableQuickFix {
            get {
                return ResourceManager.GetString("IntroduceLocalVariableQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Context type &apos;{0}&apos; is not valid for {1}..
        /// </summary>
        public static string InvalidContextTypeInspectionFix {
            get {
                return ResourceManager.GetString("InvalidContextTypeInspectionFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A line label that is never jumpted to (&apos;GoTo&apos;, &apos;Resume&apos;, ...), serves no purpose. Consider removing it..
        /// </summary>
        public static string LineLabelNotUsedInspectionMeta {
            get {
                return ResourceManager.GetString("LineLabelNotUsedInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Line label is not used.
        /// </summary>
        public static string LineLabelNotUsedInspectionName {
            get {
                return ResourceManager.GetString("LineLabelNotUsedInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Line label &apos;{0}&apos; is not used.
        /// </summary>
        public static string LineLabelNotUsedInspectionResultFormat {
            get {
                return ResourceManager.GetString("LineLabelNotUsedInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Write variable on one line.
        /// </summary>
        public static string MakeSingleLineParameterQuickFix {
            get {
                return ResourceManager.GetString("MakeSingleLineParameterQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A member access call is made against an extended interface that Rubberduck couldn&apos;t resolve, or the member couldn&apos;t be found. If VBA cannot resolve the type at run-time, error 438 will be raised. If an equivalent, non-extended interface that Rubberduck can resolve is available, consider using it instead..
        /// </summary>
        public static string MemberNotOnInterfaceInspectionMeta {
            get {
                return ResourceManager.GetString("MemberNotOnInterfaceInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Member not found.
        /// </summary>
        public static string MemberNotOnInterfaceInspectionName {
            get {
                return ResourceManager.GetString("MemberNotOnInterfaceInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Member &apos;{0}&apos; was not found on the compile-time interface for type &apos;{1}&apos;..
        /// </summary>
        public static string MemberNotOnInterfaceInspectionResultFormat {
            get {
                return ResourceManager.GetString("MemberNotOnInterfaceInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An annotation parameter is missing or incorrectly specified. The correct syntax is : &apos;@Annotation([parameter])\nExample: &apos;@Folder(&quot;Parent.Child&quot;).
        /// </summary>
        public static string MissingAnnotationArgumentInspectionMeta {
            get {
                return ResourceManager.GetString("MissingAnnotationArgumentInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Missing annotation parameter.
        /// </summary>
        public static string MissingAnnotationArgumentInspectionName {
            get {
                return ResourceManager.GetString("MissingAnnotationArgumentInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Expression &apos;{0}&apos; was expected to contain a parameter, but none was specified..
        /// </summary>
        public static string MissingAnnotationArgumentInspectionResultFormat {
            get {
                return ResourceManager.GetString("MissingAnnotationArgumentInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Module and member attributes are not displayed in the VBE. By adding an annotation, you make these attributes more explicit, and Rubberduck can keep annotations and attributes synchronized..
        /// </summary>
        public static string MissingAnnotationInspectionMeta {
            get {
                return ResourceManager.GetString("MissingAnnotationInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Missing annotation.
        /// </summary>
        public static string MissingAnnotationInspectionName {
            get {
                return ResourceManager.GetString("MissingAnnotationInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Module or member &apos;{0}&apos; has a &apos;{1}&apos; attribute, but no corresponding annotation.
        /// </summary>
        public static string MissingAnnotationInspectionResultFormat {
            get {
                return ResourceManager.GetString("MissingAnnotationInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A Rubberduck annotation is specified for a module or member, but the corresponding attribute isn&apos;t present. Module attributes and annotations need to be synchronized..
        /// </summary>
        public static string MissingAttributeInspectionMeta {
            get {
                return ResourceManager.GetString("MissingAttributeInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Missing attribute.
        /// </summary>
        public static string MissingAttributeInspectionName {
            get {
                return ResourceManager.GetString("MissingAttributeInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Module or member &apos;{0}&apos; has a &apos;{1}&apos; annotation, but no corresponding attribute.
        /// </summary>
        public static string MissingAttributeInspectionResultFormat {
            get {
                return ResourceManager.GetString("MissingAttributeInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The &apos;Public&apos; keyword can only be used at module level; its counterpart &apos;Private&apos; can also only be used at module level. &apos;Dim&apos; however, can be used to declare both procedure and module scope variables. For consistency, it would be preferable to reserve &apos;Dim&apos; for locals, and thus to use &apos;Private&apos; instead of &apos;Dim&apos; at module level..
        /// </summary>
        public static string ModuleScopeDimKeywordInspectionMeta {
            get {
                return ResourceManager.GetString("ModuleScopeDimKeywordInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use of &apos;Dim&apos; keyword at module level.
        /// </summary>
        public static string ModuleScopeDimKeywordInspectionName {
            get {
                return ResourceManager.GetString("ModuleScopeDimKeywordInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Module-level variable &apos;{0}&apos; is declared with the &apos;Dim&apos; keyword..
        /// </summary>
        public static string ModuleScopeDimKeywordInspectionResultFormat {
            get {
                return ResourceManager.GetString("ModuleScopeDimKeywordInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A module-level variable used only in one procedure should be declared in that procedure..
        /// </summary>
        public static string MoveFieldCloserToUsageInspectionMeta {
            get {
                return ResourceManager.GetString("MoveFieldCloserToUsageInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Scope of variable is broader than it needs to be.
        /// </summary>
        public static string MoveFieldCloserToUsageInspectionName {
            get {
                return ResourceManager.GetString("MoveFieldCloserToUsageInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Move module-level variable &apos;{0}&apos; to a smaller scope..
        /// </summary>
        public static string MoveFieldCloserToUsageInspectionResultFormat {
            get {
                return ResourceManager.GetString("MoveFieldCloserToUsageInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider continuing long signatures between parameters. Splitting a parameter declaration across multiple lines arguably hurts readability..
        /// </summary>
        public static string MultilineParameterInspectionMeta {
            get {
                return ResourceManager.GetString("MultilineParameterInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter declaration is split on multiple lines.
        /// </summary>
        public static string MultilineParameterInspectionName {
            get {
                return ResourceManager.GetString("MultilineParameterInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter &apos;{0}&apos; is specified on multiple lines.
        /// </summary>
        public static string MultilineParameterInspectionResultFormat {
            get {
                return ResourceManager.GetString("MultilineParameterInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Declaring multiple variables in the same instruction is legal, but should be used sparingly. Consider declaring variables closer to their usage, in a single instruction per declaration..
        /// </summary>
        public static string MultipleDeclarationsInspectionMeta {
            get {
                return ResourceManager.GetString("MultipleDeclarationsInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Multiple declarations in single instruction.
        /// </summary>
        public static string MultipleDeclarationsInspectionName {
            get {
                return ResourceManager.GetString("MultipleDeclarationsInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Instruction contains multiple declarations.
        /// </summary>
        public static string MultipleDeclarationsInspectionResultFormat {
            get {
                return ResourceManager.GetString("MultipleDeclarationsInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rubberduck only uses the first &apos;@Folder&apos; annotation in a code module; consider removing extraneous ones..
        /// </summary>
        public static string MultipleFolderAnnotationsInspectionMeta {
            get {
                return ResourceManager.GetString("MultipleFolderAnnotationsInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Module has more than one folder annotation..
        /// </summary>
        public static string MultipleFolderAnnotationsInspectionName {
            get {
                return ResourceManager.GetString("MultipleFolderAnnotationsInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; has more than one &apos;@Folder&apos; annotation..
        /// </summary>
        public static string MultipleFolderAnnotationsInspectionResultFormat {
            get {
                return ResourceManager.GetString("MultipleFolderAnnotationsInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This is likely a bug. The return value of a function or property getter must be assigned before exiting, otherwise the program will not be working with expected results. If a function has no meaningful return value, consider declaring it as a &apos;Sub&apos; procedure instead..
        /// </summary>
        public static string NonReturningFunctionInspectionMeta {
            get {
                return ResourceManager.GetString("NonReturningFunctionInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Non-returning function or property getter.
        /// </summary>
        public static string NonReturningFunctionInspectionName {
            get {
                return ResourceManager.GetString("NonReturningFunctionInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Return value for member &apos;{0}&apos; is never assigned.
        /// </summary>
        public static string NonReturningFunctionInspectionResultFormat {
            get {
                return ResourceManager.GetString("NonReturningFunctionInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to As far as Rubberduck can tell, this variable is an object variable, assigned without the &apos;Set&apos; keyword. This causes run-time error 91 &apos;Object or With block variable not set&apos;..
        /// </summary>
        public static string ObjectVariableNotSetInspectionMeta {
            get {
                return ResourceManager.GetString("ObjectVariableNotSetInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Object variable assignment requires &apos;Set&apos; keyword.
        /// </summary>
        public static string ObjectVariableNotSetInspectionName {
            get {
                return ResourceManager.GetString("ObjectVariableNotSetInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Object variable &apos;{0}&apos; is assigned without the &apos;Set&apos; keyword.
        /// </summary>
        public static string ObjectVariableNotSetInspectionResultFormat {
            get {
                return ResourceManager.GetString("ObjectVariableNotSetInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The &apos;Call&apos; statement is no longer required to call procedures, and only exists in the language to support legacy code that required it; it can be safely rewritten to an implicit call..
        /// </summary>
        public static string ObsoleteCallStatementInspectionMeta {
            get {
                return ResourceManager.GetString("ObsoleteCallStatementInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use of obsolete &apos;Call&apos; statement.
        /// </summary>
        public static string ObsoleteCallStatementInspectionName {
            get {
                return ResourceManager.GetString("ObsoleteCallStatementInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Assignment uses obsolete &apos;Call&apos; modifier.
        /// </summary>
        public static string ObsoleteCallStatementInspectionResultFormat {
            get {
                return ResourceManager.GetString("ObsoleteCallStatementInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The &apos;Rem&apos; statement only exists in the language to support legacy code that required it; it can be safely replaced with an apostrophe / single-quote comment..
        /// </summary>
        public static string ObsoleteCommentSyntaxInspectionMeta {
            get {
                return ResourceManager.GetString("ObsoleteCommentSyntaxInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use of obsolete &apos;Rem&apos; statement.
        /// </summary>
        public static string ObsoleteCommentSyntaxInspectionName {
            get {
                return ResourceManager.GetString("ObsoleteCommentSyntaxInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Comment uses obsolete &apos;Rem&apos; marker.
        /// </summary>
        public static string ObsoleteCommentSyntaxInspectionResultFormat {
            get {
                return ResourceManager.GetString("ObsoleteCommentSyntaxInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The &apos;Error&apos; statement only exists in the language to support legacy code that required it; prefer using &apos;Err.Raise&apos; instead..
        /// </summary>
        public static string ObsoleteErrorSyntaxInspectionMeta {
            get {
                return ResourceManager.GetString("ObsoleteErrorSyntaxInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use of obsolete &apos;Error&apos; statement.
        /// </summary>
        public static string ObsoleteErrorSyntaxInspectionName {
            get {
                return ResourceManager.GetString("ObsoleteErrorSyntaxInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A run-time error is raised using the obsolete &apos;Error&apos; statement.
        /// </summary>
        public static string ObsoleteErrorSyntaxInspectionResultFormat {
            get {
                return ResourceManager.GetString("ObsoleteErrorSyntaxInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The &apos;Global&apos; keyword only exists in the language to support legacy code that required it; it can be safely replaced with the &apos;Public&apos; modifier..
        /// </summary>
        public static string ObsoleteGlobalInspectionMeta {
            get {
                return ResourceManager.GetString("ObsoleteGlobalInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use of obsolete &apos;Global&apos; access modifier.
        /// </summary>
        public static string ObsoleteGlobalInspectionName {
            get {
                return ResourceManager.GetString("ObsoleteGlobalInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Replace &apos;Global&apos; access modifier with &apos;Public&apos;.
        /// </summary>
        public static string ObsoleteGlobalInspectionQuickFix {
            get {
                return ResourceManager.GetString("ObsoleteGlobalInspectionQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} &apos;{1}&apos; uses obsolete &apos;Global&apos; access modifier.
        /// </summary>
        public static string ObsoleteGlobalInspectionResultFormat {
            get {
                return ResourceManager.GetString("ObsoleteGlobalInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The &apos;Let&apos; statement only exists in the language to support legacy code that required it; it can be safely removed, since modern VBA does not require that keyword for value assignments..
        /// </summary>
        public static string ObsoleteLetStatementInspectionMeta {
            get {
                return ResourceManager.GetString("ObsoleteLetStatementInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use of obsolete explicit &apos;Let&apos; statement.
        /// </summary>
        public static string ObsoleteLetStatementInspectionName {
            get {
                return ResourceManager.GetString("ObsoleteLetStatementInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Assignment uses obsolete &apos;Let&apos; modifier.
        /// </summary>
        public static string ObsoleteLetStatementInspectionResultFormat {
            get {
                return ResourceManager.GetString("ObsoleteLetStatementInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type hint characters only exist in the language to support legacy code that required it; they can be safely replaced in declarations with an &quot;As&quot; type clause that specifies the type explicitly, and they can be omitted in other identifier references..
        /// </summary>
        public static string ObsoleteTypeHintInspectionMeta {
            get {
                return ResourceManager.GetString("ObsoleteTypeHintInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Obsolete Type hint usage.
        /// </summary>
        public static string ObsoleteTypeHintInspectionName {
            get {
                return ResourceManager.GetString("ObsoleteTypeHintInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} of {1} &apos;{2}&apos; uses an obsolete type hint.
        /// </summary>
        public static string ObsoleteTypeHintInspectionResultFormat {
            get {
                return ResourceManager.GetString("ObsoleteTypeHintInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Arrays are typically zero-based. This option changes the default lower boundary for implicitly-sized arrays, which can introduce off-by-one errors if one isn&apos;t cautious..
        /// </summary>
        public static string OptionBaseInspectionMeta {
            get {
                return ResourceManager.GetString("OptionBaseInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;Option Base 1&apos; is specified.
        /// </summary>
        public static string OptionBaseInspectionName {
            get {
                return ResourceManager.GetString("OptionBaseInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Component &apos;{0}&apos; uses &apos;Option Base 1&apos;.
        /// </summary>
        public static string OptionBaseInspectionResultFormat {
            get {
                return ResourceManager.GetString("OptionBaseInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This is the default setting, it does not need to be specified..
        /// </summary>
        public static string OptionBaseZeroInspectionMeta {
            get {
                return ResourceManager.GetString("OptionBaseZeroInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;Option Base 0&apos; is redundant.
        /// </summary>
        public static string OptionBaseZeroInspectionName {
            get {
                return ResourceManager.GetString("OptionBaseZeroInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Component &apos;{0}&apos; uses &apos;Option Base 0&apos;.
        /// </summary>
        public static string OptionBaseZeroInspectionResultFormat {
            get {
                return ResourceManager.GetString("OptionBaseZeroInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to VBA will happily compile a typo: use &apos;Option Explicit&apos; to prevent successfully compiling an erroneous program..
        /// </summary>
        public static string OptionExplicitInspectionMeta {
            get {
                return ResourceManager.GetString("OptionExplicitInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;Option Explicit&apos; is not specified.
        /// </summary>
        public static string OptionExplicitInspectionName {
            get {
                return ResourceManager.GetString("OptionExplicitInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Option Explicit is not specified in &apos;{0}&apos;.
        /// </summary>
        public static string OptionExplicitInspectionResultFormat {
            get {
                return ResourceManager.GetString("OptionExplicitInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Specify &apos;Option Explicit&apos;.
        /// </summary>
        public static string OptionExplicitQuickFix {
            get {
                return ResourceManager.GetString("OptionExplicitQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A parameter that is passed by reference and isn&apos;t assigned a new value/reference, could be passed by value instead..
        /// </summary>
        public static string ParameterCanBeByValInspectionMeta {
            get {
                return ResourceManager.GetString("ParameterCanBeByValInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter can be passed by value.
        /// </summary>
        public static string ParameterCanBeByValInspectionName {
            get {
                return ResourceManager.GetString("ParameterCanBeByValInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter &apos;{0}&apos; can be passed by value.
        /// </summary>
        public static string ParameterCanBeByValInspectionResultFormat {
            get {
                return ResourceManager.GetString("ParameterCanBeByValInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A parameter is passed into a member that does not use it. Consider removing that parameter..
        /// </summary>
        public static string ParameterNotUsedInspectionMeta {
            get {
                return ResourceManager.GetString("ParameterNotUsedInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter is not referred to.
        /// </summary>
        public static string ParameterNotUsedInspectionName {
            get {
                return ResourceManager.GetString("ParameterNotUsedInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter &apos;{0}&apos; is never used.
        /// </summary>
        public static string ParameterNotUsedInspectionResultFormat {
            get {
                return ResourceManager.GetString("ParameterNotUsedInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Pass parameter by reference.
        /// </summary>
        public static string PassParameterByReferenceQuickFix {
            get {
                return ResourceManager.GetString("PassParameterByReferenceQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Pass parameter by value.
        /// </summary>
        public static string PassParameterByValueQuickFix {
            get {
                return ResourceManager.GetString("PassParameterByValueQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A procedure that only has one parameter passed by reference that is assigned a new value/reference before the procedure exits, is using a ByRef parameter as a return value: consider making it a function instead..
        /// </summary>
        public static string ProcedureCanBeWrittenAsFunctionInspectionMeta {
            get {
                return ResourceManager.GetString("ProcedureCanBeWrittenAsFunctionInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Procedure can be written as a function.
        /// </summary>
        public static string ProcedureCanBeWrittenAsFunctionInspectionName {
            get {
                return ResourceManager.GetString("ProcedureCanBeWrittenAsFunctionInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Procedure &apos;{0}&apos; can be written as a function..
        /// </summary>
        public static string ProcedureCanBeWrittenAsFunctionInspectionResultFormat {
            get {
                return ResourceManager.GetString("ProcedureCanBeWrittenAsFunctionInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rubberduck could not find any caller for a procedure. If the procedure is hooked to a macro-button, used as a user-defined function (UDF) or handles an application event that Rubberduck didn&apos;t know of you can safely ignore this inspection result; otherwise, consider removing it..
        /// </summary>
        public static string ProcedureNotUsedInspectionMeta {
            get {
                return ResourceManager.GetString("ProcedureNotUsedInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Procedure is not referred to.
        /// </summary>
        public static string ProcedureNotUsedInspectionName {
            get {
                return ResourceManager.GetString("ProcedureNotUsedInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implement as function and update usages..
        /// </summary>
        public static string ProcedureShouldBeFunctionInspectionQuickFix {
            get {
                return ResourceManager.GetString("ProcedureShouldBeFunctionInspectionQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Procedure &apos;{0}&apos; can be written as a function.
        /// </summary>
        public static string ProcedureShouldBeFunctionInspectionResultFormat {
            get {
                return ResourceManager.GetString("ProcedureShouldBeFunctionInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0}: {1} - {2} {3}.{4}, line {5}.
        /// </summary>
        public static string QualifiedSelectionInspection {
            get {
                return ResourceManager.GetString("QualifiedSelectionInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Fix all occurences.
        /// </summary>
        public static string QuickFix_All {
            get {
                return ResourceManager.GetString("QuickFix_All", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Fix all occurrences in module.
        /// </summary>
        public static string QuickFix_ThisModule {
            get {
                return ResourceManager.GetString("QuickFix_ThisModule", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Fix all occurrences in procedure.
        /// </summary>
        public static string QuickFix_ThisProcedure {
            get {
                return ResourceManager.GetString("QuickFix_ThisProcedure", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Fix all occurrences in project.
        /// </summary>
        public static string QuickFix_ThisProject {
            get {
                return ResourceManager.GetString("QuickFix_ThisProject", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Change &apos;{0}&apos; to &apos;{1}&apos;.
        /// </summary>
        public static string QuickFixUseTypedFunction_ {
            get {
                return ResourceManager.GetString("QuickFixUseTypedFunction_", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to By default, all parameters are passed by reference, so it is not necessary to include the &apos;ByRef&apos; modifier..
        /// </summary>
        public static string RedundantByRefModifierInspectionMeta {
            get {
                return ResourceManager.GetString("RedundantByRefModifierInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Redundant &apos;ByRef&apos; modifier.
        /// </summary>
        public static string RedundantByRefModifierInspectionName {
            get {
                return ResourceManager.GetString("RedundantByRefModifierInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter &apos;{0}&apos; has a redundant ByRef modifier.
        /// </summary>
        public static string RedundantByRefModifierInspectionResultFormat {
            get {
                return ResourceManager.GetString("RedundantByRefModifierInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove &apos;ByRef&apos; modifier.
        /// </summary>
        public static string RedundantByRefModifierQuickFix {
            get {
                return ResourceManager.GetString("RedundantByRefModifierQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Being the default/implicit setting for this option, this instruction can be safely omitted..
        /// </summary>
        public static string RedundantOptionInspectionMeta {
            get {
                return ResourceManager.GetString("RedundantOptionInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Redundant module option.
        /// </summary>
        public static string RedundantOptionInspectionName {
            get {
                return ResourceManager.GetString("RedundantOptionInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; has no effect.
        /// </summary>
        public static string RedundantOptionInspectionResultFormat {
            get {
                return ResourceManager.GetString("RedundantOptionInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove comment.
        /// </summary>
        public static string RemoveCommentQuickFix {
            get {
                return ResourceManager.GetString("RemoveCommentQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove empty &apos;Else&apos; block.
        /// </summary>
        public static string RemoveEmptyElseBlockQuickFix {
            get {
                return ResourceManager.GetString("RemoveEmptyElseBlockQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove empty If block.
        /// </summary>
        public static string RemoveEmptyIfBlockQuickFix {
            get {
                return ResourceManager.GetString("RemoveEmptyIfBlockQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove obsolete statement.
        /// </summary>
        public static string RemoveObsoleteStatementQuickFix {
            get {
                return ResourceManager.GetString("RemoveObsoleteStatementQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove &apos;Option Base&apos; statement.
        /// </summary>
        public static string RemoveOptionBaseStatementQuickFix {
            get {
                return ResourceManager.GetString("RemoveOptionBaseStatementQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove usage of the &apos;Stop&apos; keyword.
        /// </summary>
        public static string RemoveStopKeywordQuickFix {
            get {
                return ResourceManager.GetString("RemoveStopKeywordQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove type hints.
        /// </summary>
        public static string RemoveTypeHintsQuickFix {
            get {
                return ResourceManager.GetString("RemoveTypeHintsQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove unassigned variable.
        /// </summary>
        public static string RemoveUnassignedIdentifierQuickFix {
            get {
                return ResourceManager.GetString("RemoveUnassignedIdentifierQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove usage (breaks code).
        /// </summary>
        public static string RemoveUnassignedVariableUsageQuickFix {
            get {
                return ResourceManager.GetString("RemoveUnassignedVariableUsageQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove unused declaration.
        /// </summary>
        public static string RemoveUnusedDeclarationQuickFix {
            get {
                return ResourceManager.GetString("RemoveUnusedDeclarationQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove unused parameter.
        /// </summary>
        public static string RemoveUnusedParameterQuickFix {
            get {
                return ResourceManager.GetString("RemoveUnusedParameterQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Replace &apos;Rem&apos; usage with a single-quote comment marker.
        /// </summary>
        public static string ReplaceCommentMarkerQuickFix {
            get {
                return ResourceManager.GetString("ReplaceCommentMarkerQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Replace If/Else with single assignment.
        /// </summary>
        public static string ReplaceIfElseWithConditionalStatementQuickFix {
            get {
                return ResourceManager.GetString("ReplaceIfElseWithConditionalStatementQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Replace &apos;Error&apos; with &apos;Err.Raise&apos;.
        /// </summary>
        public static string ReplaceObsoleteErrorStatementQuickFix {
            get {
                return ResourceManager.GetString("ReplaceObsoleteErrorStatementQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An auto-instantiated object variable declaration at procedure scope changes how nulling the reference works, which can lead to unexpected behavior..
        /// </summary>
        public static string SelfAssignedDeclarationInspectionMeta {
            get {
                return ResourceManager.GetString("SelfAssignedDeclarationInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Object variable reference is auto-instantiated.
        /// </summary>
        public static string SelfAssignedDeclarationInspectionName {
            get {
                return ResourceManager.GetString("SelfAssignedDeclarationInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Object reference &apos;{0}&apos; is auto-instantiated.
        /// </summary>
        public static string SelfAssignedDeclarationInspectionResultFormat {
            get {
                return ResourceManager.GetString("SelfAssignedDeclarationInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Return explicit Variant.
        /// </summary>
        public static string SetExplicitVariantReturnTypeQuickFix {
            get {
                return ResourceManager.GetString("SetExplicitVariantReturnTypeQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use &apos;Set&apos; keyword.
        /// </summary>
        public static string SetObjectVariableQuickFix {
            get {
                return ResourceManager.GetString("SetObjectVariableQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Two declarations are in scope and have the same identifier name. This means that only one of them will be available to use..
        /// </summary>
        public static string ShadowedDeclarationInspectionMeta {
            get {
                return ResourceManager.GetString("ShadowedDeclarationInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Shadowed declaration.
        /// </summary>
        public static string ShadowedDeclarationInspectionName {
            get {
                return ResourceManager.GetString("ShadowedDeclarationInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} &apos;{1}&apos; hides {2} &apos;{3}&apos;.
        /// </summary>
        public static string ShadowedDeclarationInspectionResultFormat {
            get {
                return ResourceManager.GetString("ShadowedDeclarationInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Specify Public access modifier explicitly.
        /// </summary>
        public static string SpecifyExplicitPublicModifierQuickFix {
            get {
                return ResourceManager.GetString("SpecifyExplicitPublicModifierQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Separate multiple declarations into multiple instructions.
        /// </summary>
        public static string SplitMultipleDeclarationsQuickFix {
            get {
                return ResourceManager.GetString("SplitMultipleDeclarationsQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The &apos;Stop&apos; keyword halts execution and brings up the debugger. Avoid its use in distributed code..
        /// </summary>
        public static string StopKeywordInspectionMeta {
            get {
                return ResourceManager.GetString("StopKeywordInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;Stop&apos; keyword.
        /// </summary>
        public static string StopKeywordInspectionName {
            get {
                return ResourceManager.GetString("StopKeywordInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;Stop&apos; keyword halts execution.
        /// </summary>
        public static string StopKeywordInspectionResultFormat {
            get {
                return ResourceManager.GetString("StopKeywordInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Synchronize attributes/annotations in module.
        /// </summary>
        public static string SynchronizeAttributesQuickFix {
            get {
                return ResourceManager.GetString("SynchronizeAttributesQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This is likely a bug. A variable is being referred to, but is never assigned..
        /// </summary>
        public static string UnassignedVariableUsageInspectionMeta {
            get {
                return ResourceManager.GetString("UnassignedVariableUsageInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Variable is used but not assigned.
        /// </summary>
        public static string UnassignedVariableUsageInspectionName {
            get {
                return ResourceManager.GetString("UnassignedVariableUsageInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Variable &apos;{0}&apos; is used but not assigned.
        /// </summary>
        public static string UnassignedVariableUsageInspectionResultFormat {
            get {
                return ResourceManager.GetString("UnassignedVariableUsageInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Code that uses undeclared variables does not compile when Option Explicit is specified. Undeclared variables are always Variant, a data type that incurs unnecessary overhead and storage..
        /// </summary>
        public static string UndeclaredVariableInspectionMeta {
            get {
                return ResourceManager.GetString("UndeclaredVariableInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Undeclared variable.
        /// </summary>
        public static string UndeclaredVariableInspectionName {
            get {
                return ResourceManager.GetString("UndeclaredVariableInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Local variable &apos;{0}&apos; is not declared.
        /// </summary>
        public static string UndeclaredVariableInspectionResultFormat {
            get {
                return ResourceManager.GetString("UndeclaredVariableInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Error handling should be restored after using &apos;On Error Resume Next&apos;..
        /// </summary>
        public static string UnhandledOnErrorResumeNextInspectionMeta {
            get {
                return ResourceManager.GetString("UnhandledOnErrorResumeNextInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unhandled &apos;On Error Resume Next&apos;.
        /// </summary>
        public static string UnhandledOnErrorResumeNextInspectionName {
            get {
                return ResourceManager.GetString("UnhandledOnErrorResumeNextInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Introduce error handling subroutine.
        /// </summary>
        public static string UnhandledOnErrorResumeNextInspectionQuickFix {
            get {
                return ResourceManager.GetString("UnhandledOnErrorResumeNextInspectionQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Errors are ignored but never handled again.
        /// </summary>
        public static string UnhandledOnErrorResumeNextInspectionResultFormat {
            get {
                return ResourceManager.GetString("UnhandledOnErrorResumeNextInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A string-returning equivalent function exists and should preferably be used to avoid implicit type conversions. 
        ///If the parameter can be null, ignore this inspection result; passing a null value to a function expecting a string would raise a type mismatch runtime error..
        /// </summary>
        public static string UntypedFunctionUsageInspectionMeta {
            get {
                return ResourceManager.GetString("UntypedFunctionUsageInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use of variant-returning string function.
        /// </summary>
        public static string UntypedFunctionUsageInspectionName {
            get {
                return ResourceManager.GetString("UntypedFunctionUsageInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Replace function &apos;{0}&apos; with existing typed function.
        /// </summary>
        public static string UntypedFunctionUsageInspectionResultFormat {
            get {
                return ResourceManager.GetString("UntypedFunctionUsageInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identifier names should indicate what they&apos;re used for and should be readable; avoid disemvoweling, numeric suffixes, and 1-2 character names..
        /// </summary>
        public static string UseMeaningfulNameInspectionMeta {
            get {
                return ResourceManager.GetString("UseMeaningfulNameInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use meaningful names.
        /// </summary>
        public static string UseMeaningfulNameInspectionName {
            get {
                return ResourceManager.GetString("UseMeaningfulNameInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Variable is not assigned. If this isn&apos;t intended, there&apos;s probably a bug. Ignore this inspection result if the variable is assigned in another procedure via a ByRef parameter..
        /// </summary>
        public static string VariableNotAssignedInspectionMeta {
            get {
                return ResourceManager.GetString("VariableNotAssignedInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Variable is not assigned.
        /// </summary>
        public static string VariableNotAssignedInspectionName {
            get {
                return ResourceManager.GetString("VariableNotAssignedInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Variable &apos;{0}&apos; is not assigned.
        /// </summary>
        public static string VariableNotAssignedInspectionResultFormat {
            get {
                return ResourceManager.GetString("VariableNotAssignedInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Variable is not referred to.
        /// </summary>
        public static string VariableNotUsedInspectionMeta {
            get {
                return ResourceManager.GetString("VariableNotUsedInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Variable is not referred to.
        /// </summary>
        public static string VariableNotUsedInspectionName {
            get {
                return ResourceManager.GetString("VariableNotUsedInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A variable whose type isn&apos;t explicitly declared, is implicitly &apos;Variant&apos;. Consider making it an explicit &apos;Variant&apos; if that&apos;s intended, or declare a more specific type..
        /// </summary>
        public static string VariableTypeNotDeclaredInspectionMeta {
            get {
                return ResourceManager.GetString("VariableTypeNotDeclaredInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implicitly &apos;Variant&apos; variable.
        /// </summary>
        public static string VariableTypeNotDeclaredInspectionName {
            get {
                return ResourceManager.GetString("VariableTypeNotDeclaredInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} &apos;{1}&apos; is implicitly &apos;Variant&apos;.
        /// </summary>
        public static string VariableTypeNotDeclaredInspectionResultFormat {
            get {
                return ResourceManager.GetString("VariableTypeNotDeclaredInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Add to whitelist.
        /// </summary>
        public static string WhiteListIdentifierQuickFix {
            get {
                return ResourceManager.GetString("WhiteListIdentifierQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A property that exposes a mutator but no accessor is a design smell and makes a confusing API. Consider exposing a getter, or converting the mutator to a method..
        /// </summary>
        public static string WriteOnlyPropertyInspectionMeta {
            get {
                return ResourceManager.GetString("WriteOnlyPropertyInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Write-only property.
        /// </summary>
        public static string WriteOnlyPropertyInspectionName {
            get {
                return ResourceManager.GetString("WriteOnlyPropertyInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Property &apos;{0}&apos; has no getter.
        /// </summary>
        public static string WriteOnlyPropertyInspectionResultFormat {
            get {
                return ResourceManager.GetString("WriteOnlyPropertyInspectionResultFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Add property get accessor.
        /// </summary>
        public static string WriteOnlyPropertyQuickFix {
            get {
                return ResourceManager.GetString("WriteOnlyPropertyQuickFix", resourceCulture);
            }
        }
    }
}
