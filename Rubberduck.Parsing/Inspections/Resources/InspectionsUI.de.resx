<?xml version="1.0" encoding="UTF-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" id="root">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AssignedByValParameterInspectionMeta" xml:space="preserve">
    <value>Parameter wird als Wert übergeben</value>
  </data>
  <data name="AssignedByValParameterInspectionName" xml:space="preserve">
    <value>ByVal Parameter ist zugewiesen</value>
  </data>
  <data name="ConstantNotUsedInspectionMeta" xml:space="preserve">
    <value>Rubberduck konnte keine Referenz auf eine Konstante finden. Überlegen Sie eine Entfernung der nicht verwendeten Deklaration.</value>
  </data>
  <data name="ConstantNotUsedInspectionName" xml:space="preserve">
    <value>Konstante wird nicht verwendet</value>
  </data>
  <data name="DefaultProjectNameInspectionMeta" xml:space="preserve">
    <value>Erwäge Sie dem VBA-Projekt einen Namen zu geben.</value>
  </data>
  <data name="DefaultProjectNameInspectionName" xml:space="preserve">
    <value>Das Projekt hat den Standard-Projektnamen.</value>
  </data>
  <data name="EmptyStringLiteralInspection" xml:space="preserve">
    <value>Man sollte bevorzugt 'vbNullString' gegenüber einem leeren String verwenden.</value>
  </data>
  <data name="EmptyStringLiteralInspectionMeta" xml:space="preserve">
    <value>Die eingebaute Konstante 'vbNullString' ist ein Null-String Zeiger, der 0 bytes Arbeitsspeicher benötigt. Dies ist das beabsichtigte Verhalten eines leeren Strings.</value>
  </data>
  <data name="EmptyStringLiteralInspectionName" xml:space="preserve">
    <value>Leeres 'String Literal'</value>
  </data>
  <data name="EmptyStringLiteralInspectionQuickFix" xml:space="preserve">
    <value>Leeren String durch die Konstante 'vbNullString' ersetzen</value>
  </data>
  <data name="EncapsulatePublicFieldInspectionResultFormat" xml:space="preserve">
    <value>Das öffentliche Feld '{0}' bricht die Kapselung</value>
  </data>
  <data name="EncapsulatePublicFieldInspectionMeta" xml:space="preserve">
    <value>Erwägen Sie stattdessen, eine Eigenschaft verfügbar zu machen.</value>
  </data>
  <data name="EncapsulatePublicFieldInspectionName" xml:space="preserve">
    <value>Öffentliches Feld bricht die Kapselung</value>
  </data>
  <data name="EncapsulatePublicFieldInspectionQuickFix" xml:space="preserve">
    <value>Das Feld '{0}' mit einer Eigenschaft kapselen</value>
  </data>
  <data name="IgnoreOnce" xml:space="preserve">
    <value>Einmal ignorieren</value>
  </data>
  <data name="ImplicitActiveSheetReferenceInspectionMeta" xml:space="preserve">
    <value>Implizite Referenzen zum aktuellen Tabellenblatt macht den Code anfällig und schwieriger zu debuggen. Erwäge die Referenz explizit anzugeben oder vorzugsweise mit Objektreferenzen zu arbeiten. Ignoriere wenn der Methodenaufruf sich auf einen Typ bezieht, den Rubberduck nicht auflösen kann.</value>
  </data>
  <data name="ImplicitActiveSheetReferenceInspectionName" xml:space="preserve">
    <value>Implizite Referenz zum 'ActiveSheet'</value>
  </data>
  <data name="ImplicitActiveWorkbookReferenceInspectionMeta" xml:space="preserve">
    <value>Implizite Referenzen zur aktuellen Arbeitsmappe macht den Code anfällig und schwieriger zu debuggen. Erwäge die Referenz explizit anzugeben oder vorzugsweise mit Objektreferenzen zu arbeiten. Ignoriere wenn der Methodenaufruf sich auf einen Typ bezieht, den Rubberduck nicht auflösen kann.</value>
  </data>
  <data name="ImplicitActiveWorkbookReferenceInspectionName" xml:space="preserve">
    <value>Implizite Referenz zum 'ActiveWorkbook'</value>
  </data>
  <data name="ImplicitPublicMemberInspectionMeta" xml:space="preserve">
    <value>Die Methoden eines Moduls sind standardmäßig öffentlich, was irreführend sein kann. Besser ist es, den Gültigkeitsbereich der Methoden explizit zu definieren.</value>
  </data>
  <data name="ImplicitPublicMemberInspectionName" xml:space="preserve">
    <value>Implizite öffentliche Methode</value>
  </data>
  <data name="ImplicitVariantReturnTypeInspectionMeta" xml:space="preserve">
    <value>Methoden mit einem Rückgabewert geben, wenn nicht anders angegeben, implizit 'Variant' zurück. Überlege, ob es nicht besser ist, den Rückgabewert explizit als 'Variant' zu definieren, wenn der Typ des Rückgabewertes nicht bekannt ist.</value>
  </data>
  <data name="ImplicitVariantReturnTypeInspectionName" xml:space="preserve">
    <value>Rückgabewert der Methode ist implizit 'Variant'</value>
  </data>
  <data name="MoveFieldCloserToUsageInspectionMeta" xml:space="preserve">
    <value>Eine Variable, die im Modulkopf deklariert wurde aber nur in einer Prozedur verwendet wird, sollte in der Prozedur deklariert werden.</value>
  </data>
  <data name="MoveFieldCloserToUsageInspectionName" xml:space="preserve">
    <value>Der Geltungsbereich der Variable ist größer als notwendig.</value>
  </data>
  <data name="MoveFieldCloserToUsageInspectionResultFormat" xml:space="preserve">
    <value>Veringere die den Geltungsbereich der Modulvariable '{0}'.</value>
  </data>
  <data name="MultilineParameterInspectionMeta" xml:space="preserve">
    <value>Überlege lange Parameterdeklarationen zusammenzuhalten. Das Aufteilen einer Parameterdeklaration über mehrere Zeilen sollte zugunsten der besseren Lesbarkeit vermieden werden.</value>
  </data>
  <data name="MultilineParameterInspectionName" xml:space="preserve">
    <value>Die Parameterdeklaration ist über mehrere Zeilen verteilt.</value>
  </data>
  <data name="MultipleDeclarationsInspectionMeta" xml:space="preserve">
    <value>Die Deklaration von mehren Variablen in der gleichen Codezeile ist erlaubt, sollte aber sparsam eingesetzt werden. Erwäge die Variablendeklartion in der Nähe der Nutzung als separate Anweisung pro Deklaration.</value>
  </data>
  <data name="MultipleDeclarationsInspectionName" xml:space="preserve">
    <value>Anweisung enthält Mehrfachdeklarationen</value>
  </data>
  <data name="MultipleFolderAnnotationsInspectionResultFormat" xml:space="preserve">
    <value>'{0}' hat mehr als eine '@Folder'-Annotation</value>
  </data>
  <data name="MultipleFolderAnnotationsInspectionMeta" xml:space="preserve">
    <value>Rubberduck nutzt nur die erste '@Folder'-Annotation innerhalb eines Code-Moduls. Entferne die Überzähligen.</value>
  </data>
  <data name="MultipleFolderAnnotationsInspectionName" xml:space="preserve">
    <value>Das Modul hat mehr als eine Ordner Annotation.</value>
  </data>
  <data name="NonReturningFunctionInspectionMeta" xml:space="preserve">
    <value>Hier könnte ein Fehler vorliegen. Der Rückgabewert einer Funktion oder Eigenschaft wird nicht zugewiesen. Dies kann zu unvorhersehbaren Verhalten des Codes führen. Wenn die Funktion keinen sinnvollen Rückgabewert hat, sollte sie in eine 'Sub'-Routine umgeschrieben werden.</value>
  </data>
  <data name="NonReturningFunctionInspectionName" xml:space="preserve">
    <value>Funktion oder Eigenschaft ohne Rückgabewert</value>
  </data>
  <data name="ObsoleteCallStatementInspectionMeta" xml:space="preserve">
    <value>Die 'Call'-Anweisung ist nicht mehr zum Aufruf einer Anweisung notwendig. Sie existiert aus Gründen der Abwärtskompatibilität. Sie kann problemlos durch einen impliziten Anweisungsaufruf ersetzt werden.</value>
  </data>
  <data name="ObsoleteCallStatementInspectionName" xml:space="preserve">
    <value>Nutzung des 'Call'-Aufrufes</value>
  </data>
  <data name="ObsoleteCommentSyntaxInspectionMeta" xml:space="preserve">
    <value>Die 'REM'-Anweisung existiert aus Gründen der Abwärtskompatibilität. Sie kann gefahrlos durch ein einfaches Anführungszeichen ersetzt werden.</value>
  </data>
  <data name="ObsoleteCommentSyntaxInspectionName" xml:space="preserve">
    <value>Nutzung der 'REM'-Anweisung</value>
  </data>
  <data name="ObsoleteGlobalInspectionMeta" xml:space="preserve">
    <value>Das Schlüsselwort 'Global' existiert aus Gründen der Abwärtskompatibilität. Es kann gefahrlos durch 'Public' ersetzt werden.</value>
  </data>
  <data name="ObsoleteGlobalInspectionName" xml:space="preserve">
    <value>Nutzung der 'Global'-Zugriffsdeklaration</value>
  </data>
  <data name="ObsoleteLetStatementInspectionMeta" xml:space="preserve">
    <value>Die 'Let'-Anweisung  existiert aus Gründen der Abwärtskompatibilität. Sie kann gefahrlos entfernt werden, da das moderne VBA dieses Schlüsselwort nicht mehr zur Werte-Zuweisung benötigt.</value>
  </data>
  <data name="ObsoleteLetStatementInspectionName" xml:space="preserve">
    <value>Nutzung des 'Let'-Ausdrucks</value>
  </data>
  <data name="ObsoleteTypeHintInspectionMeta" xml:space="preserve">
    <value>Die Verwendung der Typ-Buchstaben (z.B. $)  existiert aus Gründen der Abwärtskompatibilität. Sie kann gefahrlos durch eine 'As'-Typdeklaration ersetzt werden.</value>
  </data>
  <data name="ObsoleteTypeHintInspectionName" xml:space="preserve">
    <value>Verwendungshinweis für Typ</value>
  </data>
  <data name="OptionBaseInspectionMeta" xml:space="preserve">
    <value>Arrays sind normalerweise null-basiert. Diese Option ändert die untere Standardgrenze für impliziert erzeugte Arrays. Dies kann einen 'off-by-one' Fehler erzeugen, wenn sie nicht sorgsam eingesetzt wird.</value>
  </data>
  <data name="OptionBaseInspectionName" xml:space="preserve">
    <value>'Option Base 1' ist angegeben.</value>
  </data>
  <data name="OptionExplicitInspectionMeta" xml:space="preserve">
    <value>VBA kompiliert ohne ohne 'Option Explicit` auch Tippfehlern erfolgreich: Verwenden Sie 'Option Explicit', um zu verhindern, dass ein fehlerhaftes Programm erfolgreich kompiliert wird.</value>
  </data>
  <data name="OptionExplicitInspectionName" xml:space="preserve">
    <value>'Option Explicit' ist nicht angegeben.</value>
  </data>
  <data name="ParameterCanBeByValInspectionMeta" xml:space="preserve">
    <value>Ein Parameter der als Referenz übergeben wird, aber keine neue Wert- oder Referenzzuweisung erhält, sollte als Wert übergeben werden.</value>
  </data>
  <data name="ParameterCanBeByValInspectionName" xml:space="preserve">
    <value>Parameter kann als Wert übergeben werden.</value>
  </data>
  <data name="ParameterNotUsedInspectionMeta" xml:space="preserve">
    <value>Ein Parameter, der der Methode übergeben wird, wird nicht verwendet. Erwäge diesen zu entfernen.</value>
  </data>
  <data name="ParameterNotUsedInspectionName" xml:space="preserve">
    <value>Der Parameter wird nicht genutzt.</value>
  </data>
  <data name="ProcedureNotUsedInspectionMeta" xml:space="preserve">
    <value>Rubberduck kann keinen Aufruf für die Prozedur finden. Falls diese über eine Markro-Schaltfläche, als benutzerdefinierte Funktion oder als Event-Handler genutzt wird, den Rubberduck nicht kennt, kann dieser Hinweis ignoriert werden. Ansonsten sollte sie entfernt werden.</value>
  </data>
  <data name="ProcedureNotUsedInspectionName" xml:space="preserve">
    <value>Die Prozedur wird nicht genutzt.</value>
  </data>
  <data name="UnassignedVariableUsageInspectionMeta" xml:space="preserve">
    <value>Hier könnte ein Fehler vorliegen. Eine Variable wird referenziert aber ihr wird kein Wert zugewiesen.</value>
  </data>
  <data name="UnassignedVariableUsageInspectionName" xml:space="preserve">
    <value>Variable wird genutzt ohne das ihr ein Wert zugewiesen wurde.</value>
  </data>
  <data name="UntypedFunctionUsageInspectionMeta" xml:space="preserve">
    <value>Es gibt eine äquivalente Funktion, die einen String zurückgibt. Diese sollte bevorzugt genutzt werden, um implitizite Typumwandlungen zu vermeiden.
Falls der Parameter 'null' sein kann, bitte dieses Auftreten ignorieren. 'null' an die Funktion zu übergeben, die einen String erwartet würde zu einem "Type Mismatch"-Laufzeitfehler führen.</value>
  </data>
  <data name="UntypedFunctionUsageInspectionName" xml:space="preserve">
    <value>Verwendung einer 'Variant' zurückgebenden String-Funktion</value>
  </data>
  <data name="ProcedureCanBeWrittenAsFunctionInspectionResultFormat" xml:space="preserve">
    <value>Prozedur '{0}' kann als Funktion geschrieben werden.</value>
    <comment>{0} Procedure name</comment>
  </data>
  <data name="ProcedureShouldBeFunctionInspectionQuickFix" xml:space="preserve">
    <value>Als Funktion implementieren und Aufrufe anpassen.</value>
  </data>
  <data name="IdentifierNameInspectionResultFormat" xml:space="preserve">
    <value>Übelege die Umbenennung {0} '{1}'</value>
  </data>
  <data name="UseMeaningfulNameInspectionMeta" xml:space="preserve">
    <value>Bezeicher sollten lesbar sein und ihren Verwendungszweck widerspiegeln. Bezeichner ohne Vokale, mit nummerischem Suffix oder nur 1-2 Buchstaben sollten vermieden werden.</value>
  </data>
  <data name="UseMeaningfulNameInspectionName" xml:space="preserve">
    <value>Aussagekräftige Namen nutzen</value>
  </data>
  <data name="VariableNotAssignedInspectionMeta" xml:space="preserve">
    <value>Einer Variable wird kein Wert zugewiesen. Falls das nicht beabsichtigt ist, kann das zu einem Fehler führen. Ignorieren Sie diese Warnung, falls die Variable in einer anderen Prozedur durch einen 'ByRef'-Parameter zugewiesen wird.</value>
  </data>
  <data name="VariableNotAssignedInspectionName" xml:space="preserve">
    <value>Der Variable wird kein Wert zugewiesen.</value>
  </data>
  <data name="VariableNotUsedInspectionMeta" xml:space="preserve">
    <value>Variable wird nicht gelesen</value>
  </data>
  <data name="VariableNotUsedInspectionName" xml:space="preserve">
    <value>Die Variable wird nicht referenziert.</value>
  </data>
  <data name="VariableTypeNotDeclaredInspectionMeta" xml:space="preserve">
    <value>Variable, deren Typ nicht explizit deklariert wurde, erhält implizit den Typ 'Variant'. Überlege die Variable explizit als 'Variant' zu definieren oder eine besseren Typ zu zuweisen.</value>
  </data>
  <data name="VariableTypeNotDeclaredInspectionName" xml:space="preserve">
    <value>Variable ist implizit 'Variant'</value>
  </data>
  <data name="WriteOnlyPropertyInspectionMeta" xml:space="preserve">
    <value>Eine Eigenschaft, die eine Änderungsfunktion, aber keine Zugriffsfunktion bereitstellt, führt zu einer unklaren API. Enweder erstelle einen öffentlichen getter oder ändere die Änderungsfunktion in eine Methode ab.</value>
  </data>
  <data name="WriteOnlyPropertyInspectionName" xml:space="preserve">
    <value>Nur-Schreib Eigenschaft</value>
  </data>
  <data name="ProcedureCanBeWrittenAsFunctionInspectionMeta" xml:space="preserve">
    <value>Eine Prozedur, die nur einen Parameter als Referenz übergibt, der vor dem Verlassen der Prozedur einen neuen Wert oder Referenz erhält, sollte als Funktion umgeschrieben werden.</value>
  </data>
  <data name="ProcedureCanBeWrittenAsFunctionInspectionName" xml:space="preserve">
    <value>Prozedur kann als Funktion geschrieben werden.</value>
  </data>
  <data name="WriteOnlyPropertyInspectionResultFormat" xml:space="preserve">
    <value>Eigenschaft '{0}' hat keinen Getter.</value>
    <comment>{0} Property name</comment>
  </data>
  <data name="SelfAssignedDeclarationInspectionResultFormat" xml:space="preserve">
    <value>Objekt-Referenz '{0}' ist sebstzugewiesen.</value>
  </data>
  <data name="SelfAssignedDeclarationInspectionMeta" xml:space="preserve">
    <value>Eine selbstzugewiesene Objektvariablendeklaration in einer Prozedur kann das Verhalten beim Nulling verändern. Dies kann zu unvorhergesehen Verhalten des Codes führen.</value>
  </data>
  <data name="SelfAssignedDeclarationInspectionName" xml:space="preserve">
    <value>Objektvariable ist selbstzugewiesen.</value>
  </data>
  <data name="FunctionReturnValueNotUsedInspectionName" xml:space="preserve">
    <value>Der Rückgabewert der Funktion wird nicht genutzt.</value>
  </data>
  <data name="FunctionReturnValueNotUsedInspectionResultFormat" xml:space="preserve">
    <value>Der Rückgabewert der Funktion '{0}' wird nicht verwendet.</value>
  </data>
  <data name="AssignedByValParameterInspectionResultFormat" xml:space="preserve">
    <value>Der Parameter '{0}' wird als byVal übergeben und bekommt ienen Wert zugesiesen.</value>
  </data>
  <data name="IdentifierNotUsedInspectionResultFormat" xml:space="preserve">
    <value>{0} '{1}' wird nicht genutzt</value>
  </data>
  <data name="ImplicitPublicMemberInspectionResultFormat" xml:space="preserve">
    <value>Methode '{0}' ist implizit 'Public'</value>
  </data>
  <data name="ImplicitVariantDeclarationInspectionResultFormat" xml:space="preserve">
    <value>{0} '{1}' ist implizit 'Variant'</value>
  </data>
  <data name="ImplicitVariantReturnTypeInspectionResultFormat" xml:space="preserve">
    <value>Der Rückgabewert der Methode '{0}' ist implizit 'Variant'.</value>
  </data>
  <data name="MultilineParameterInspectionResultFormat" xml:space="preserve">
    <value>Der Parameter '{0}' wird über mehrere Zeilen angegeben</value>
  </data>
  <data name="NonReturningFunctionInspectionResultFormat" xml:space="preserve">
    <value>Der Rückgabewert der Methode '{0}' wird nicht zugewiesen</value>
  </data>
  <data name="ObsoleteGlobalInspectionResultFormat" xml:space="preserve">
    <value>{0} '{1}' verwendet die veraltete 'Global' Zugriffsdeklaration</value>
  </data>
  <data name="ParameterCanBeByValInspectionResultFormat" xml:space="preserve">
    <value>Der Parameter '{0}' kann als Wert übergeben werden</value>
  </data>
  <data name="ParameterNotUsedInspectionResultFormat" xml:space="preserve">
    <value>Der Parameter '{0}' wird nicht verwendet.</value>
  </data>
  <data name="ProcedureShouldBeFunctionInspectionResultFormat" xml:space="preserve">
    <value>Die Prozedur '{0}' kann als Funktion geschrieben werden.</value>
  </data>
  <data name="UnassignedVariableUsageInspectionResultFormat" xml:space="preserve">
    <value>Die Variable '{0}' wird verwendet ohne ihr einen Wert zuzuweisen</value>
  </data>
  <data name="ConvertFunctionToProcedureQuickFix" xml:space="preserve">
    <value>Funktion zu Prozedur konvertieren</value>
  </data>
  <data name="DeclareAsExplicitVariantQuickFix" xml:space="preserve">
    <value>Als explizit 'Variant' deklarieren</value>
  </data>
  <data name="Inspections_UnassignedVariableTodo" xml:space="preserve">
    <value>TODO</value>
  </data>
  <data name="MakeSingleLineParameterQuickFix" xml:space="preserve">
    <value>Variable in einer Zeile schreiben </value>
  </data>
  <data name="ObsoleteGlobalInspectionQuickFix" xml:space="preserve">
    <value>'Global' durch 'Public' ersetzen</value>
  </data>
  <data name="OptionExplicitInspectionResultFormat" xml:space="preserve">
    <value>'Option Explicit' ist für '{0}' nicht angegeben.</value>
  </data>
  <data name="OptionExplicitQuickFix" xml:space="preserve">
    <value>'Option Explicit' setzen</value>
  </data>
  <data name="PassParameterByReferenceQuickFix" xml:space="preserve">
    <value>Parameter als Referenz übergeben</value>
  </data>
  <data name="PassParameterByValueQuickFix" xml:space="preserve">
    <value>Parameter als Wert übergeben</value>
  </data>
  <data name="QuickFixUseTypedFunction_" xml:space="preserve">
    <value>'{0}' zu '{1}' ändern</value>
  </data>
  <data name="QuickFix_ThisModule" xml:space="preserve">
    <value>Alle Vorkommnisse im Modul beheben</value>
  </data>
  <data name="QuickFix_ThisProject" xml:space="preserve">
    <value>Alle Vorkommnisse im Projekt beheben</value>
  </data>
  <data name="RemoveCommentQuickFix" xml:space="preserve">
    <value>Kommentar entfernen</value>
  </data>
  <data name="RemoveObsoleteStatementQuickFix" xml:space="preserve">
    <value>Überflüssige Anweisungen entfernen</value>
  </data>
  <data name="RemoveTypeHintsQuickFix" xml:space="preserve">
    <value>Typ-Hinweise entfernen</value>
  </data>
  <data name="RemoveUnassignedIdentifierQuickFix" xml:space="preserve">
    <value>Nicht verwendete Variablen entfernen</value>
  </data>
  <data name="RemoveUnassignedVariableUsageQuickFix" xml:space="preserve">
    <value>Nutzung enfernen (unterbricht den Code)</value>
  </data>
  <data name="RemoveUnusedDeclarationQuickFix" xml:space="preserve">
    <value>Unbenutze Deklaration enfernen</value>
  </data>
  <data name="RemoveUnusedParameterQuickFix" xml:space="preserve">
    <value>Nicht genutzte Parameter entfernen</value>
  </data>
  <data name="ReplaceCommentMarkerQuickFix" xml:space="preserve">
    <value>'REM' durch einfaches Anführungszeichen als Kommentarzeichen ersetzen</value>
  </data>
  <data name="SetExplicitVariantReturnTypeQuickFix" xml:space="preserve">
    <value>Explizit 'Variant' zurückgeben</value>
  </data>
  <data name="SpecifyExplicitPublicModifierQuickFix" xml:space="preserve">
    <value>Gültigkeitsbereich 'Public' explizit definieren</value>
  </data>
  <data name="SplitMultipleDeclarationsQuickFix" xml:space="preserve">
    <value>Mehrfach-Deklarationen in einer Zeile durch Deklaration in getrennten Zeilen ersetzen</value>
  </data>
  <data name="VariableNotAssignedInspectionResultFormat" xml:space="preserve">
    <value>Der Variable '{0}' wird kein Wert zugewiesen.</value>
  </data>
  <data name="DisableThisInspection" xml:space="preserve">
    <value>Deaktiviere diese Überprüfung</value>
  </data>
  <data name="EmptyStringLiteralInspectionResultFormat" xml:space="preserve">
    <value>vbNullString' sollte statt einem leeren String-Literal verwendet werden.</value>
  </data>
  <data name="InvalidContextTypeInspectionFix" xml:space="preserve">
    <value>Kontexttyp '{0}' ist nicht gültig für {1}.</value>
  </data>
  <data name="QualifiedSelectionInspection" xml:space="preserve">
    <value>{0}: {1} - {2} {3}.{4}, Zeile {5}</value>
  </data>
  <data name="SetObjectVariableQuickFix" xml:space="preserve">
    <value>Das Schlüsselwort 'Set' benutzen</value>
  </data>
  <data name="ObjectVariableNotSetInspectionResultFormat" xml:space="preserve">
    <value>Objektvariable '{0}' wird ohne das 'Set'-Schlüsselwort zugewiesen</value>
  </data>
  <data name="ObjectVariableNotSetInspectionMeta" xml:space="preserve">
    <value>Rubberduck hat festgestellt, dass die Variable eine Objektvariable ist, die ohne 'Set'-Schlüsselwort zugewiesen wird. Dies führt zu dem Laufzeitfehler '91': Objektvariable oder With-Blockvariable nicht festgelegt</value>
  </data>
  <data name="ObjectVariableNotSetInspectionName" xml:space="preserve">
    <value>Zuweisung in eine Objektvariable benötigt das 'Set'-Schlüsselwort.</value>
  </data>
  <data name="Inspections_Usage" xml:space="preserve">
    <value>Verwendung</value>
  </data>
  <data name="Inspections_Declaration" xml:space="preserve">
    <value>Deklaration</value>
  </data>
  <data name="VariableTypeNotDeclaredInspectionResultFormat" xml:space="preserve">
    <value>{0} '{1}' ist implizit 'Variant'</value>
  </data>
  <data name="ObsoleteCommentSyntaxInspectionResultFormat" xml:space="preserve">
    <value>Kommentar verwendet die obsolete 'REM'-Markierung</value>
  </data>
  <data name="DefaultProjectNameInspectionResultFormat" xml:space="preserve">
    <value>Projekt '{0}' hat den Standardnamen</value>
  </data>
  <data name="ObsoleteCallStatementInspectionResultFormat" xml:space="preserve">
    <value>Zuweisung verwendet obsolete 'Call'-Anweisung</value>
  </data>
  <data name="ObsoleteLetStatementInspectionResultFormat" xml:space="preserve">
    <value>Zuweisung verwendet obsolete 'Let'-Anweisung</value>
  </data>
  <data name="ImplicitActiveSheetReferenceInspectionResultFormat" xml:space="preserve">
    <value>Member '{0}' referenziert implizit auf 'ActiveSheet'</value>
  </data>
  <data name="ImplicitActiveWorkbookReferenceInspectionResultFormat" xml:space="preserve">
    <value>Member '{0}' referenziert implizit auf 'ActiveWorkbook'</value>
  </data>
  <data name="UntypedFunctionUsageInspectionResultFormat" xml:space="preserve">
    <value>Ersetze Funktion {0} mit der existierenden typisierten Funktion</value>
  </data>
  <data name="OptionBaseInspectionResultFormat" xml:space="preserve">
    <value>Komponente '{0}' verwendet 'Option Base 1'</value>
  </data>
  <data name="ObsoleteTypeHintInspectionResultFormat" xml:space="preserve">
    <value>{0}  von {1} '{2}' verwendet einen obsoleten Typenhinweis</value>
  </data>
  <data name="MultipleDeclarationsInspectionResultFormat" xml:space="preserve">
    <value>Instruktion enthält Mehrfachdeklaration</value>
  </data>
  <data name="MissingAnnotationArgumentInspectionName" xml:space="preserve">
    <value>Fehlender Annotationsparameter</value>
  </data>
  <data name="MissingAnnotationArgumentInspectionResultFormat" xml:space="preserve">
    <value>Ausdruck '{0}' sollte einen Parameter enthalten, es wurde aber keiner angegeben.</value>
  </data>
  <data name="MissingAnnotationArgumentInspectionMeta" xml:space="preserve">
    <value>Eine Annotation in einem Kommentar konnte nicht gelesen werden. Die korrekte Syntax ist: '@Annotation([parameter])'\nBeispiel: '@Folder("Parent.Child")'</value>
  </data>
  <data name="IntroduceLocalVariableQuickFix" xml:space="preserve">
    <value>Lokale Variable einführen</value>
  </data>
  <data name="UndeclaredVariableInspectionMeta" xml:space="preserve">
    <value>Code, der undeklarierte Variablen verwendet, kompiliert nicht wenn 'Option Explicit' spezifiziert wird. Undeklarierte Variablen sind immer vom Typ 'Variant', was unnötige Zusatzkosten in Ausführungszeit und Speicherverbauch verursacht.</value>
  </data>
  <data name="WriteOnlyPropertyQuickFix" xml:space="preserve">
    <value>'Property Get' Zugriff hinzufügen</value>
  </data>
  <data name="ModuleScopeDimKeywordInspectionMeta" xml:space="preserve">
    <value>Das Schlüsselwort 'Public' kann nur auf Modulebene verwendet werden; Sein Konterpart 'Private' kann auch nur auf Modulebene verwendet werden. 'Dim' jedoch kann verwendet werden, um sowohl modulweite als auch prozedurweite Variablen zu deklarieren. Um der Konsistenz Willen ist es besser, 'Dim' nur für lokale Variablen zu verwenden, also 'Private' statt 'Dim' auf Modulebene zu verwenden.</value>
  </data>
  <data name="ChangeDimToPrivateQuickFix" xml:space="preserve">
    <value>'Dim' durch 'Private' ersetzen</value>
  </data>
  <data name="UndeclaredVariableInspectionName" xml:space="preserve">
    <value>Nicht deklarierte Variable</value>
  </data>
  <data name="ModuleScopeDimKeywordInspectionName" xml:space="preserve">
    <value>Verwendung von 'Dim' auf Modulebene</value>
  </data>
  <data name="UndeclaredVariableInspectionResultFormat" xml:space="preserve">
    <value>Die lokale Variable '{0}' wurde nicht deklariert</value>
  </data>
  <data name="ModuleScopeDimKeywordInspectionResultFormat" xml:space="preserve">
    <value>Die Modulvariable '{0}' ist mit dem 'Dim'-Schlüsselwort deklariert.</value>
  </data>
  <data name="FunctionReturnValueNotUsedInspectionMeta" xml:space="preserve">
    <value>Ein Member ist als Funktion geschrieben, aber wird wie eine Prozedur verwendet. Falls die Funktion nicht rekursiv ist, sollten Sie in Erwägung ziehen, die 'Function' in ein 'Sub' zu konvertieren. Falls die Funktion rekursiv ist, verwendet keiner der externen Aufrufer den Rückgabewert.</value>
  </data>
  <data name="AggregateInspectionResultFormat" xml:space="preserve">
    <value>{0} ({1} Ergebnisse)</value>
  </data>
  <data name="ApplicationWorksheetFunctionQuickFix">
    <value>Application.WorksheetFunction explizit verwenden.</value>
  </data>
  <data name="ApplicationWorksheetFunctionInspectionName">
    <value>Laufzeitgebundener Aufruf an WorksheetFunction</value>
  </data>
  <data name="ApplicationWorksheetFunctionInspectionResultFormat">
    <value>Laufzeitgebundene Nutzung des Application.{0} Members.</value>
  </data>
  <data name="ImplicitDefaultMemberAssignmentInspectionName">
    <value>Implizite Zuweisung an Standard-Member</value>
  </data>
  <data name="HostSpecificExpressionInspectionName">
    <value>Hostspezifischer geklammerter Ausdruck wird nur zur Laufzeit ausgewertet</value>
  </data>
  <data name="ImplicitDefaultMemberAssignmentInspectionResultFormat">
    <value>Zuweisung zu '{0}' weist implizit den Standard-Member von Klasse  '{1}' zu</value>
  </data>
  <data name="HungarianNotationInspectionName">
    <value>Variable verwendet 'Ungarische Notation'</value>
  </data>
  <data name="MemberNotOnInterfaceInspectionMeta">
    <value>Es wird ein Memberzugriff verwendet, der vom Interface des Objektes nicht deklariert wird. Dies ist höchstwahrscheinlich ein Fehler. Falls der Memberzugriff das erweiterbare Interface des Objektes verwendet, erwägen Sie ein nicht erweiterbares Äquivalent zu verwenden um Prüfungen zur Kompilierzeit zu ermöglichen und das Auftreten von Laufzeitfehler 438 zu verhindern.</value>
  </data>
  <data name="HungarianNotationInspectionMeta">
    <value>'Ungarische Notation' macht Code weniger lesbar und ist redundant, sobald stark typisierte Variablen und aussagekräftige Namen verwendet werden.</value>
  </data>
  <data name="ApplicationWorksheetFunctionInspectionMeta">
    <value>Das Excel Application-Objekt implementiert das WorksheetFunction interface direkt. Alle Aufrufe an WorksheetFunction-Member werden als laufzeitgebunden behandelt und Fehler im aufgerufenen Member werden in ein Variant des Typs VbVarType.Error gekapselt. Dadurch können Fehler nicht mit Fehleranweisungen behandelt werden und gegenüber skriptzeitgebundenen Aufrufen sinkt die Performanz. Ziehen Sie in Erwägung Application.WorksheetFunction explizit aufzurufen. Bedenken Sie: Falls dieser Aufruf in der Vergangenheit Fehler erzeugt hat, wurden diese ignoriert. Es sollte eine Fehlerbehandlung vorhanden sein, bevor Sie die schnelle Korrektur anwenden.</value>
  </data>
  <data name="WhiteListIdentifierQuickFix">
    <value>Zur Whitelist hinzufügen</value>
  </data>
  <data name="HostSpecificExpressionInspectionResultFormat">
    <value>Ausdruck '{0}' kann zur Kompilierzeit nicht validiert werden.</value>
  </data>
  <data name="MemberNotOnInterfaceInspectionName">
    <value>Member existiert auf dem Interface nicht</value>
  </data>
  <data name="MemberNotOnInterfaceInspectionResultFormat">
    <value>Member '{0}' ist auf dem Interface für '{1}' nicht deklariert.</value>
  </data>
  <data name="ImplicitDefaultMemberAssignmentInspectionMeta">
    <value>Solche Zuweisungen sehen aus als wiesen sie einer Objektvariable an einen Werttyp zu, aber tatsächlich wird der Standardmember des Objekts implizit zugewiesen. Um die Lesbarkeit zu verbessern, erwägen Sie explizit auf den Standardmember zuzugreifen.</value>
  </data>
  <data name="HostSpecificExpressionInspectionMeta">
    <value>Geklammerte Ausdrücke werden von der Hostanwendung zur Laufzeit ausgewertet, was bedeutet, dass VBA den Ausdruck nicht zur Kompilierzeit validieren kann. Erwägen sie, das hostspezifische Objektmodell zu verwenden.</value>
  </data>
  <data name="AssignedByValParameterMakeLocalCopyQuickFix">
    <value>Eine lokale Kopie des Parameters erstellen und verwenden</value>
  </data>
  <data name="OptionBaseZeroInspectionName">
    <value>'Option Base 0' ist redundant</value>
  </data>
  <data name="OptionBaseZeroInspectionResultFormat">
    <value>Komponente '{0}' verwendet 'Option Base 0'</value>
  </data>
  <data name="QuickFix_All">
    <value>Alle Vorkommnisse beheben</value>
  </data>
  <data name="QuickFix_ThisProcedure">
    <value>Alle Vorkommnisse in der Prozedur beheben</value>
  </data>
  <data name="OptionBaseZeroInspectionMeta">
    <value>Dies ist die Standardeinstellung, sie muss nicht spezifiziert werden.</value>
  </data>
  <data name="RemoveOptionBaseStatementQuickFix">
    <value>'Option Base'-Anweisung entfernen</value>
  </data>
  <data name="SynchronizeAttributesQuickFix">
    <value>Attribute/Annotationen im Modul synchronisieren</value>
  </data>
  <data name="CodeInspectionSettings_RubberduckOpportunities">
    <value>Optimalere Ausnutzung von Rubberduck</value>
  </data>
  <data name="LineLabelNotUsedInspectionName">
    <value>Zeilenbezeichnung wird nicht referenziert</value>
  </data>
  <data name="EmptyIfBlockInspectionName">
    <value>Leerer 'If'-Block</value>
  </data>
  <data name="MissingAnnotationInspectionMeta">
    <value>Modul- und Elementattribute werden von der VBE nicht angezeigt. Durch das hinzufügen einer Annotation werden diese Attribute deutlicher. Außerdem kann Rubberduck die Annotationen und Attribute synchronisieren.</value>
  </data>
  <data name="IllegalAnnotationInspectionMeta">
    <value>Eine Annotation für die Modulebene kann nicht verwendet werden, um Elemente zu annotieren; Eine Annotation für Elemente kann auf Modulebene nicht verwendet werden; Modul- und Elementannotationen sollten nur einmal spezifiziert werden.</value>
  </data>
  <data name="CodeInspectionSettings_Performance">
    <value>Performanz</value>
  </data>
  <data name="RedundantByRefModifierQuickFix">
    <value>Redundante 'ByRef'-Markierung entfernen</value>
  </data>
  <data name="RedundantByRefModifierInspectionName">
    <value>Redundante 'ByRef'-Markierung</value>
  </data>
  <data name="CodeInspectionSeverity_DoNotShow">
    <value>Nicht Anzeigen</value>
  </data>
  <data name="ImplicitByRefModifierInspectionResultFormat">
    <value>Der Parameter '{0}' wird implizit als Referenz übergeben.</value>
  </data>
  <data name="RedundantOptionInspectionMeta">
    <value>Da dies die Standardeinstellung für diese Option ist, kann die Anweisung ohne Nebeneffekte entfernt werden.</value>
  </data>
  <data name="ImplicitByRefModifierInspectionName">
    <value>Implizite Referenzübergabe</value>
  </data>
  <data name="CodeInspectionSettings_MaintainabilityAndReadabilityIssues">
    <value>Wartbarkeits- und Leserlichkeitsprobleme</value>
  </data>
  <data name="LineLabelNotUsedInspectionResultFormat">
    <value>Die Zeilenbezeichnung '{0}' wird nicht verwendet</value>
  </data>
  <data name="CodeInspectionSeverity_Warning">
    <value>Warnung</value>
  </data>
  <data name="RedundantByRefModifierInspectionResultFormat">
    <value>Der Parameter '{0}' hat eine redundante 'ByRef'-Markierung</value>
  </data>
  <data name="MissingAnnotationInspectionName">
    <value>Fehlende Annotation</value>
  </data>
  <data name="RedundantByRefModifierInspectionMeta">
    <value>Alle Parameter werden, falls nicht anders spezifiziert als Referenz übergeben. Es ist also nicht nötig, die 'ByRef'-Markierung zu verwenden.</value>
  </data>
  <data name="IllegalAnnotationInspectionName">
    <value>Illegale Annotation</value>
  </data>
  <data name="RemoveEmptyIfBlockQuickFix">
    <value>Leeren 'If'-Block entfernen</value>
  </data>
  <data name="ImplicitByRefModifierInspectionMeta">
    <value>Parameter werden, falls nicht anders spezifiziert, als Referenz übergeben. Dies kann verwirrend sein und Bugs hervorrufen. Bevorzugen Sie die Übergabe von Parametern als Werte und spezifizieren Sie eine Referenzübergabe explizit als ByRef.</value>
  </data>
  <data name="ImplicitByRefModifierQuickFix">
    <value>Parameter explizit als Referenz übergeben.</value>
  </data>
  <data name="MissingAttributeInspectionMeta">
    <value>Eine Rubberduck-Annotation wurde für ein Modul oder Element festgelegt, aber das zugehörige Attribut fehlt. Die Modul-Attribute und Annotationen sollten synchronisiert werden.</value>
  </data>
  <data name="CodeInspectionSeverity_Hint">
    <value>Tipp</value>
  </data>
  <data name="EmptyIfBlockInspectionMeta">
    <value>Ein leerer 'If'-Block ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="EmptyIfBlockInspectionResultFormat">
    <value>'If'-Block enthält keine ausführbaren Anweisungen</value>
  </data>
  <data name="CodeInspectionSettings_LanguageOpportunities">
    <value>Optimalere Ausnutzung der Sprache</value>
  </data>
  <data name="CodeInspectionSeverity_Suggestion">
    <value>Vorschlag</value>
  </data>
  <data name="LineLabelNotUsedInspectionMeta">
    <value>Rubberduck konnte keine Resume oder GoTo Anweisung zu einer Zeilenbezeichnung finden. Erwägen Sie eine Entfernung der Bezeichnung.</value>
  </data>
  <data name="MissingAttributeInspectionName">
    <value>Fehlendes Attribut</value>
  </data>
  <data name="RedundantOptionInspectionName">
    <value>Redundante Moduloption</value>
  </data>
  <data name="CodeInspectionSettings_CodeQualityIssues">
    <value>Codequalitätsprobleme</value>
  </data>
  <data name="IllegalAnnotationInspectionResultFormat">
    <value>Die Annotation '{0}' ist in diesem Kontext nicht erlaubt.</value>
  </data>
  <data name="RedundantOptionInspectionResultFormat">
    <value>'{0}' hat keine Auswirkung.</value>
  </data>
  <data name="CodeInspectionSeverity_Error">
    <value>Fehler</value>
  </data>
  <data name="MissingAnnotationInspectionResultFormat">
    <value>Modul oder Element '{0}' hat ein '{1}' Attribut, aber keine zugehörige Annotation.</value>
  </data>
  <data name="MissingAttributeInspectionResultFormat">
    <value>Modul oder Element '{0}' hat eine '{1}' Annotation, aber das zugehörige Attribut fehlt.</value>
  </data>
  <data name="EmptyCaseBlockInspectionResultFormat">
    <value>'Case'-Block enthält keine ausführbaren Anweisungen</value>
  </data>
  <data name="IntegerDataTypeInspectionName">
    <value>Verwendung von 16-bit Ganzzahl</value>
  </data>
  <data name="EmptyForLoopBlockInspectionMeta">
    <value>Eine leere 'For…Next'-Schleife ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="EmptyCaseBlockInspectionName">
    <value>Leerer 'Case'-Block</value>
  </data>
  <data name="ShadowedDeclarationInspectionMeta">
    <value>Zwei Deklarationen sind aktiv und haben denselben Namen. Dies bedeutet, dass nur eine von ihnen zur Verwendung verfügbar ist.</value>
  </data>
  <data name="StopKeywordInspectionMeta">
    <value>Das Schlüsselwort 'Stop' unterbricht die Ausführung und ruft den Debugger auf. Vermeiden Sie die Verwendung in verteiltem Code.</value>
  </data>
  <data name="EmptyForLoopBlockInspectionName">
    <value>Leere 'For…Next'-Schleife</value>
  </data>
  <data name="ReplaceObsoleteErrorStatementQuickFix">
    <value>'Error' durch 'Err.Raise' ersetzen</value>
  </data>
  <data name="EmptyCaseBlockInspectionMeta">
    <value>Ein leerer 'Case'-Block ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="StopKeywordInspectionResultFormat">
    <value>Das Schlüsselwort 'Stop' unterbricht die Ausführung</value>
  </data>
  <data name="EmptyForEachBlockInspectionMeta">
    <value>Eine leere 'For Each…Next'-Schleife ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="EmptyElseBlockInspectionMeta">
    <value>Ein leerer 'Else'-Block ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="RemoveEmptyElseBlockQuickFix">
    <value>Leeren 'Else'-Block entfernen</value>
  </data>
  <data name="ShadowedDeclarationInspectionResultFormat">
    <value>{0} '{1}' überschattet {2} '{3}'</value>
  </data>
  <data name="RemoveStopKeywordQuickFix">
    <value>'Stop'-Schlüsselwort entfernen</value>
  </data>
  <data name="ObsoleteErrorSyntaxInspectionResultFormat">
    <value>Ein Laufzeitfehler wird mit der veralteten 'Error'-Anweisung ausgelöst</value>
  </data>
  <data name="EmptyForEachBlockInspectionResultFormat">
    <value>'For Each…Next'-Schleife enthält keine ausführbaren Anweisungen</value>
  </data>
  <data name="EmptyElseBlockInspectionResultFormat">
    <value>'Else'-Block enthält keine ausführbaren Anweisungen</value>
  </data>
  <data name="IntegerDataTypeQuickFix">
    <value>Typ zu 'Long' änderen</value>
  </data>
  <data name="EmptyForEachBlockInspectionName">
    <value>Leere 'For Each…Next'-Schleife</value>
  </data>
  <data name="EmptyDoWhileBlockInspectionName">
    <value>Leere 'Do…While'-Schleife</value>
  </data>
  <data name="EmptyElseBlockInspectionName">
    <value>Leerer 'Else'-Block</value>
  </data>
  <data name="EmptyForLoopBlockInspectionResultFormat">
    <value>'For…Next'-Schleife enthält keine ausführbaren Anweisungen.</value>
  </data>
  <data name="EmptyWhileWendBlockInspectionMeta">
    <value>Eine leere 'While…Wend'-Schleife ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="ObsoleteErrorSyntaxInspectionMeta">
    <value>Die 'Error'-Anweisung existiert in der Sprache nur um Legacy-Programme zu unterstützen, die sie benötigten; Bevorzugen Sie stattdessen 'Err.Raise'.</value>
  </data>
  <data name="IntegerDataTypeInspectionMeta">
    <value>Der größte Wert einer vorzeichenbehafteten 16-bit Ganzzahl ist 32.767 - Eine 32-bit Ganzzahl (Long) zu verwenden, wo es möglich ist, kann Überlauffehler zur Laufzeit verhindern und ist für moderne CPUs einfacher.</value>
  </data>
  <data name="IntegerDataTypeInspectionResultFormat">
    <value>{0} '{1}' ist als Integer deklariert</value>
  </data>
  <data name="EmptyWhileWendBlockInspectionResultFormat">
    <value>'While…Wend'-Schleife enthält keine ausführbaren Anweisungen</value>
  </data>
  <data name="EmptyDoWhileBlockInspectionResultFormat">
    <value>'Do…While'-Schleife enthält keine ausführbaren Anweisungen</value>
  </data>
  <data name="EmptyWhileWendBlockInspectionName">
    <value>Leere 'While…Wend'-Schleife</value>
  </data>
  <data name="ShadowedDeclarationInspectionName">
    <value>Überschattete Deklaration</value>
  </data>
  <data name="EmptyDoWhileBlockInspectionMeta">
    <value>Eine leere 'Do…While'-Schleife ohne ausführbare Anweisungen lässt andere Entwickler über die Absicht des Codes im unklaren. Vermeiden Sie das Schreiben von unnötigem Code.</value>
  </data>
  <data name="StopKeywordInspectionName">
    <value>'Stop'-Schlüsselwort</value>
  </data>
  <data name="BooleanAssignedInIfElseInspectionMeta">
    <value>Ein Mitglied wird in verschiedenen Zweigen einer if-Anweisung mit True / False zugewiesen, wobei keine anderen Anweisungen in der Bedingung enthalten sind. Verwenden Sie die Bedingung stattdessen direkt für das Mitglied.</value>
  </data>
  <data name="BooleanAssignedInIfElseInspectionName">
    <value>Boolsche Zeichenkette wird in Bedingung zugewiesen</value>
  </data>
  <data name="ReplaceIfElseWithConditionalStatementQuickFix" xml:space="preserve">
    <value>'If/Else' mit einer einfachen Zuordnung ersetzen</value>
  </data>
  <data name="BooleanAssignedInIfElseInspectionResultFormat" xml:space="preserve">
    <value>Boolean Ausdruck '{0}' wurde in einer trivialen If/Else-Verzweigung zugewiesen</value>
  </data>
  <data name="EmptyModuleInspectionName" xml:space="preserve">
    <value>Leeres Modul</value>
  </data>
  <data name="EmptyModuleInspectionMeta" xml:space="preserve">
    <value>Leere Module und Klassen weisen entweder auf noch nicht implementierte Funktionalitäten hin oder stellen unnötigen Ballast dar, der die Wartbarkeit eines Projekts behindern kann.</value>
  </data>
  <data name="EmptyModuleInspectionResultFormat" xml:space="preserve">
    <value>Modul/Klasse {0} ist leer.</value>
  </data>
</root>
