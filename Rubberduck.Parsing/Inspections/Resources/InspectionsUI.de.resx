<?xml version="1.0" encoding="UTF-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" id="root">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AssignedByValParameterInspectionMeta" xml:space="preserve">
    <value>Parameter wird als Wert übergeben</value>
  </data>
  <data name="AssignedByValParameterInspectionName" xml:space="preserve">
    <value>ByVal Parameter ist zugewiesen</value>
  </data>
  <data name="CodeQualityIssues" xml:space="preserve">
    <value>Code Qualitätsproblem</value>
  </data>
  <data name="ConstantNotUsedInspectionMeta" xml:space="preserve">
    <value>Rubberduck konnte keine Referenz auf eine Konstante finden. Überlegen Sie eine Entfernung der nicht verwendeten Deklaration.</value>
  </data>
  <data name="ConstantNotUsedInspectionName" xml:space="preserve">
    <value>Konstante wird nicht verwendet</value>
  </data>
  <data name="DefaultProjectNameInspectionMeta" xml:space="preserve">
    <value>Erwäge dem VBAProjekt einen Namen zu egeben.</value>
  </data>
  <data name="DefaultProjectNameInspectionName" xml:space="preserve">
    <value>Das Projekt hat den Standard-Projektnamen.</value>
  </data>
  <data name="EmptyStringLiteralInspection" xml:space="preserve">
    <value>Man sollte bevorzugt 'vbNullString' gegenüber einem leeren String verwenden.</value>
  </data>
  <data name="EmptyStringLiteralInspectionMeta" xml:space="preserve">
    <value>Die eingbaute Konstante 'vbNullString' ist ein Null String Zeiger, der 0 bytes Arbeitsspeicher benötigt. Dies ist das beabsichtigete Verhalten eines leeren Strings.</value>
  </data>
  <data name="EmptyStringLiteralInspectionName" xml:space="preserve">
    <value>Leeres 'String Literal'</value>
  </data>
  <data name="EmptyStringLiteralInspectionQuickFix" xml:space="preserve">
    <value>Ersetze leeren String durch die Konstante 'vbNullString'</value>
  </data>
  <data name="EncapsulatePublicFieldInspectionResultFormat" xml:space="preserve">
    <value>Das öffentliche Feld '{0}' bricht die Kapselung</value>
  </data>
  <data name="EncapsulatePublicFieldInspectionMeta" xml:space="preserve">
    <value>Besser nutze eine öffentlich sichtbare Eigenschaft</value>
  </data>
  <data name="EncapsulatePublicFieldInspectionName" xml:space="preserve">
    <value>Öffentliche Feld bricht die Kapselung</value>
  </data>
  <data name="EncapsulatePublicFieldInspectionQuickFix" xml:space="preserve">
    <value>Kapsele das Feld '{0}' mit einere 'Property'</value>
  </data>
  <data name="IgnoreOnce" xml:space="preserve">
    <value>Einmal ignorieren</value>
  </data>
  <data name="ImplicitActiveSheetReferenceInspectionMeta" xml:space="preserve">
    <value>Implizierte Referenzen zum aktuellen Tabellenblatt macht den Code anfällig und schwieriger zu Debuggen. Erwäge die Referenz explizit anzugeben oder vorzugsweise mit Objektreferenzen zu arbeiten. Ignoriere wenn der Methodenaufruf sich auf einen Typ bezieht, den Rubberduck nicht auflösen kann.</value>
  </data>
  <data name="ImplicitActiveSheetReferenceInspectionName" xml:space="preserve">
    <value>Implizierte Referenz zum 'ActiveSheet'</value>
  </data>
  <data name="ImplicitActiveWorkbookReferenceInspectionMeta" xml:space="preserve">
    <value>Implizierte Referenzen zur aktuellen Arbeitsmappe macht den Code anfällig und schwieriger zu Debuggen. Erwäge die Referenz explizit anzugeben oder vorzugsweise mit Objektreferenzen zu arbeiten. Ignoriere wenn der Methodenaufruf sich auf einen Typ bezieht, den Rubberduck nicht auflösen kann.</value>
  </data>
  <data name="ImplicitActiveWorkbookReferenceInspectionName" xml:space="preserve">
    <value>Impliziete Referenz zum ' ActiveWorkbook'</value>
  </data>
  <data name="ImplicitByRefParameterInspectionMeta" xml:space="preserve">
    <value>Parameter werden als Referenz übergeben, wenn diese speziell übergene werden. Dies ist verwirrend und fehleranfällig. Deshalb sollten Parameter als Wert übergeben werden und nur in speziellen Fällen als Referenz.</value>
  </data>
  <data name="ImplicitByRefParameterInspectionName" xml:space="preserve">
    <value>Implizierter ByRef Parameter</value>
  </data>
  <data name="ImplicitPublicMemberInspectionMeta" xml:space="preserve">
    <value>Die Methoden eines Moduls sind standardmäßig öffentlich, was irreführend sein kann. Besser ist es, den Gültigkeitsbereich der Methoden explizit zu definieren.</value>
  </data>
  <data name="ImplicitPublicMemberInspectionName" xml:space="preserve">
    <value>Implizierte öffentliche Methode</value>
  </data>
  <data name="ImplicitVariantReturnTypeInspectionMeta" xml:space="preserve">
    <value>Methoden mit einem Rückgabewet geben, wenn nicht nanders angegeben, implizit 'Variant' zurück. Überlege ob es nicht besser ist, den Rückgabewert explizit als 'Variant' zu definieren, wenn der Typ des Rückgabewertes nicht bekannt ist.</value>
  </data>
  <data name="ImplicitVariantReturnTypeInspectionName" xml:space="preserve">
    <value>Rückgabewert der Methode ist implizit 'Variant'</value>
  </data>
  <data name="MoveFieldCloserToUsageInspectionMeta" xml:space="preserve">
    <value>Eine Variable, die im Modulkopf deklariert wurde aber nur in einer Prozedur verwendet wird, sollte in der Prozedur deklariert werden.</value>
  </data>
  <data name="MoveFieldCloserToUsageInspectionName" xml:space="preserve">
    <value>Die Größe der Variable ist größer als benötigt.</value>
  </data>
  <data name="MoveFieldCloserToUsageInspectionResultFormat" xml:space="preserve">
    <value>Veringere die Größe der Modulvariable '{0}'.</value>
  </data>
  <data name="LanguageOpportunities" xml:space="preserve">
    <value>Sprachmöglichkeiten</value>
  </data>
  <data name="MaintainabilityAndReadabilityIssues" xml:space="preserve">
    <value>Wartungs- und Lesbarkeitsproblem</value>
  </data>
  <data name="MultilineParameterInspectionMeta" xml:space="preserve">
    <value>Überlege lange Parameterdeklarationen zusammenzuhalten. Das Aufteilen einer Parameterdeklaration über mehrere Zeilen sollte zugunsten der besseren Lesbarkeit vermieden werden.</value>
  </data>
  <data name="MultilineParameterInspectionName" xml:space="preserve">
    <value>Die Parameterdefinition ist über mehrere Zeilen verteilt.</value>
  </data>
  <data name="MultipleDeclarationsInspectionMeta" xml:space="preserve">
    <value>Die Deklaration von mehren Variablen in der gleichen Codezeile ist erlaubt, sollte aber sparsam eingesetzt werden. Erwäge die Variablendeklartion in der Nähe der Nutzung als separate Anweisung pro Deklaration.</value>
  </data>
  <data name="MultipleDeclarationsInspectionName" xml:space="preserve">
    <value>Anweisung enthält Mehrfachdeklarationen</value>
  </data>
  <data name="MultipleFolderAnnotationsInspectionResultFormat" xml:space="preserve">
    <value>'{0}' hat mehr als eine '@Folder' Notierung.</value>
  </data>
  <data name="MultipleFolderAnnotationsInspectionMeta" xml:space="preserve">
    <value>Rubberduck nutzt nur die erste '@Folder' Annotation innerhalb eines Code-Moduls. Entferne die überzähligen.</value>
  </data>
  <data name="MultipleFolderAnnotationsInspectionName" xml:space="preserve">
    <value>Das Modul hat mehr als eine Ordner Annotation.</value>
  </data>
  <data name="NonReturningFunctionInspectionMeta" xml:space="preserve">
    <value>Hier könnte ein Fahler vorliegen. Der Rückgabewert einer Funktion oder Eigenschaft wird nicht zugewiesen. Dies kann zu unvorhersehbaren Verhalten des Codes führen. Sollte die Funktion keinen sinnvollen Rückgabewert haben, sollte sie in eine 'Sub'-Routine um geschrieben werden.</value>
  </data>
  <data name="NonReturningFunctionInspectionName" xml:space="preserve">
    <value>Ein Funktion oder Eigenschaftt ohne Rückgabewert</value>
  </data>
  <data name="ObsoleteCallStatementInspectionMeta" xml:space="preserve">
    <value>Die 'Call' Anweisung ist nicht mehr zum Aufruf einer Anweisung notwendig. Sie existiert aus Gründen der abwärtskompatibilität. Sie kann problemlos durch einen impliziten Anweisungsaufruf ersetzt werden.</value>
  </data>
  <data name="ObsoleteCallStatementInspectionName" xml:space="preserve">
    <value>Nutzung des 'Call' Aufrufes</value>
  </data>
  <data name="ObsoleteCommentSyntaxInspectionMeta" xml:space="preserve">
    <value>Die 'REM'-Anweisung existiert aus Gründen der Abwärtskompatibilität. Sie kann gefahrlos durch ein einfaches Anführungszeichen ersetzt werden.</value>
  </data>
  <data name="ObsoleteCommentSyntaxInspectionName" xml:space="preserve">
    <value>Nutzung der 'REM'-Anweisung</value>
  </data>
  <data name="ObsoleteGlobalInspectionMeta" xml:space="preserve">
    <value>Das Schlüsselwort 'Global' existiert aus Gründen der Abwärtskompatibilität. Es kann gefahrlos mit 'Public' ersetzt werden.</value>
  </data>
  <data name="ObsoleteGlobalInspectionName" xml:space="preserve">
    <value>Nutzung des 'Global'Ausdrucks</value>
  </data>
  <data name="ObsoleteLetStatementInspectionMeta" xml:space="preserve">
    <value>Die 'Let'-Anweisung  existiert aus Gründen der Abwärtskompatibilität. Sie kann gefahrlos entfernt werden, das moderne VBA dieses Schlüsselwort nicht mehr benötigt.</value>
  </data>
  <data name="ObsoleteLetStatementInspectionName" xml:space="preserve">
    <value>Nutzung des 'Let' Ausdrucks</value>
  </data>
  <data name="ObsoleteTypeHintInspectionMeta" xml:space="preserve">
    <value>Die Verwendung der Typ-Buchstaben (z.B. $)  existiert aus Gründen der Abwärtskompatibilität. Sie kann gefahrlos in der Deklaration durch 'as' ersetzt werden.</value>
  </data>
  <data name="ObsoleteTypeHintInspectionName" xml:space="preserve">
    <value>Verwendungshinweis für Typ</value>
  </data>
  <data name="OptionBaseInspectionMeta" xml:space="preserve">
    <value>Arrays sind normalerweise null-basiert. Diese Option ändert die untere Standardgrenze für impliziert erzeugte Arrays. Dies kann einen 'off-by-one' Fehler erzeugen, wenn sie nicht sorgsam eingesetzt wird.</value>
  </data>
  <data name="OptionBaseInspectionName" xml:space="preserve">
    <value>'Option Base 1' ist angegeben.</value>
  </data>
  <data name="OptionExplicitInspectionMeta" xml:space="preserve">
    <value>Nutze am besten 'Option Explicit' um fehleranfällige Programme zu erstellen.</value>
  </data>
  <data name="OptionExplicitInspectionName" xml:space="preserve">
    <value>'Option Explicit' ist nicht angegeben.</value>
  </data>
  <data name="ParameterCanBeByValInspectionMeta" xml:space="preserve">
    <value>Ein Parameter der als Referenz übergeben wird, aber keine neue Wert- oder Referenzzuweisung erhält, sollte als Wert übergeben werden.</value>
  </data>
  <data name="ParameterCanBeByValInspectionName" xml:space="preserve">
    <value>Parameter kann als Wert übergeben werden.</value>
  </data>
  <data name="ParameterNotUsedInspectionMeta" xml:space="preserve">
    <value>Ein Parameter, der der Methode übergeben wird, wird nicht verwendet. Erwäge diesen zu entfernen.</value>
  </data>
  <data name="ParameterNotUsedInspectionName" xml:space="preserve">
    <value>Der Parameter wird nicht genutzt.</value>
  </data>
  <data name="ProcedureNotUsedInspectionMeta" xml:space="preserve">
    <value>Rubberduck kann keine Aufruf für die Prozedur finden. Falls diese über eine Markro-Schaltfläche, als benutzer definierte Funktion oder als Programm Event Handler genutzt werde, kann dieser Rubberduck Hinweis ignoriert werden. Ansonsten sollte sie entfernt werden.</value>
  </data>
  <data name="ProcedureNotUsedInspectionName" xml:space="preserve">
    <value>Die Prozedur wird nicht genutzt.</value>
  </data>
  <data name="UnassignedVariableUsageInspectionMeta" xml:space="preserve">
    <value>Hier könnte ein Fehler vorliegen. Eine Variable wird referenziert aber ihr wird kein Wert zugewiesen.</value>
  </data>
  <data name="UnassignedVariableUsageInspectionName" xml:space="preserve">
    <value>Variable wird genutzt ohne das ihr ein Wert zugewiesen wurde.</value>
  </data>
  <data name="UntypedFunctionUsageInspectionMeta" xml:space="preserve">
    <value>Eine gibt eine Funktion, die einen String Äquivalent zurückgibt. Diese sollte bevorzugt genutzt werden, um implitizite Typumwandlungen zu vermeiden.
Falls der Parameter 'null' sein kann, bitte dieses Auftreten ignorieren. 'null' an die Funktion zu übergeben, die einen String erwartet würde zu einem "Type Mismatch"-Laufzeitfehler führen.</value>
  </data>
  <data name="UntypedFunctionUsageInspectionName" xml:space="preserve">
    <value>Nutzung einer Funktion, die einen 'String Variant' zurückgibt.</value>
  </data>
  <data name="ProcedureCanBeWrittenAsFunctionInspectionResultFormat" xml:space="preserve">
    <value>Prozedur '{0}' kann als Funktion geschrieben  werden.</value>
    <comment>{0} Procedure name</comment>
  </data>
  <data name="ProcedureShouldBeFunctionInspectionQuickFix" xml:space="preserve">
    <value>Implementiere als Funktion und passe die Aufrufe an</value>
  </data>
  <data name="IdentifierNameInspectionResultFormat" xml:space="preserve">
    <value>Übelege die Umbenennung {0} '{1}'</value>
  </data>
  <data name="UseMeaningfulNameInspectionMeta" xml:space="preserve">
    <value>Die Bezeicher sollte lesbar sein und ihren Verwendungszweck wiederspiegeln. Bezeichner ohne Vokale, mit nummerischem Suffix und 1-2 Buchstaben sollten vermieden werden.</value>
  </data>
  <data name="UseMeaningfulNameInspectionName" xml:space="preserve">
    <value>Nutze aussagekräftige Namen.</value>
  </data>
  <data name="VariableNotAssignedInspectionMeta" xml:space="preserve">
    <value>Einer Variable wird kein Wert zugewiesen. Falls Rubberduck recht hat, kann diese wahrscheinlich gefahrlos gelöscht werden.</value>
  </data>
  <data name="VariableNotAssignedInspectionName" xml:space="preserve">
    <value>Variable wird nicht beschrieben.</value>
  </data>
  <data name="VariableNotUsedInspectionMeta" xml:space="preserve">
    <value>Variable wird nicht gelesen</value>
  </data>
  <data name="VariableNotUsedInspectionName" xml:space="preserve">
    <value>Die Variable wird nicht referenziert.</value>
  </data>
  <data name="VariableTypeNotDeclaredInspectionMeta" xml:space="preserve">
    <value>Variable, deren Typ nicht explizit deklariert wurde, erhält implizit den Typ 'Variant'. Überlege die Variable explizit als 'Variant' zu definieren oder eine besseren Typ zu zuweisen.</value>
  </data>
  <data name="VariableTypeNotDeclaredInspectionName" xml:space="preserve">
    <value>Variable ist implizit 'Variant'</value>
  </data>
  <data name="WriteOnlyPropertyInspectionMeta" xml:space="preserve">
    <value>Eine Eigenschaft, die eine Änderungsfunktion, aber keine Zugriffsfunktion bereitstellt, führt zu einer unklaren API. Enweder erstelle einen öffentlichen getter oder ändere die Änderungsfunktion in eine Methode ab.</value>
  </data>
  <data name="WriteOnlyPropertyInspectionName" xml:space="preserve">
    <value>Nur-Lese Eigenschaft</value>
  </data>
  <data name="ProcedureCanBeWrittenAsFunctionInspectionMeta" xml:space="preserve">
    <value>Eine Prozedur, die nur einen Parameter als Referenz übergibt, der vor dem Verlassen der Prozedur einen neuen Wert oder Referenz erhält, sollte als Funktion umgeschrieben werden.</value>
  </data>
  <data name="ProcedureCanBeWrittenAsFunctionInspectionName" xml:space="preserve">
    <value>Prozedur kann als Funktion geschrieben werden.</value>
  </data>
  <data name="WriteOnlyPropertyInspectionResultFormat" xml:space="preserve">
    <value>Eigenschaft '{0}' hat keinen Getter.</value>
    <comment>{0} Property name</comment>
  </data>
  <data name="SelfAssignedDeclarationInspectionResultFormat" xml:space="preserve">
    <value>Objekt-Referenz '{0}' ist sebstzugewiesen.</value>
  </data>
  <data name="SelfAssignedDeclarationInspectionMeta" xml:space="preserve">
    <value>Eine selbstzugewiesene Objektvariablendeklaration in einer Prozedur kann das Verhalten beim Nulling verändern. Dies kann zu unvorhergesehen Verhalten des Codes führen.</value>
  </data>
  <data name="SelfAssignedDeclarationInspectionName" xml:space="preserve">
    <value>Objektvariable ist selbstzugewiesen.</value>
  </data>
  <data name="FunctionReturnValueNotUsedInspectionName" xml:space="preserve">
    <value>Der Rückgabewert der Funktion wird nicht genutzt.</value>
  </data>
  <data name="FunctionReturnValueNotUsedInspectionResultFormat" xml:space="preserve">
    <value>Der Rückgabewert der Funnktio '{0}' wird nicht verwendet.</value>
  </data>
  <data name="AssignedByValParameterInspectionResultFormat" xml:space="preserve">
    <value>Der Parameter '{0}' wird als byVal übergeben und bekommt ienen Wert zugesiesen.</value>
  </data>
  <data name="IdentifierNotUsedInspectionResultFormat" xml:space="preserve">
    <value>{0} '{1}' wird nicht genutzt</value>
  </data>
  <data name="ImplicitByRefParameterInspectionResultFormat" xml:space="preserve">
    <value>Der Parameter '{0}' wird implizit als Referenz übergeben.</value>
  </data>
  <data name="ImplicitPublicMemberInspectionResultFormat" xml:space="preserve">
    <value>Methode '{0}' ist implizit 'Public'</value>
  </data>
  <data name="ImplicitVariantDeclarationInspectionResultFormat" xml:space="preserve">
    <value>{0} '{1}' ist impliziert 'Variant'</value>
  </data>
  <data name="ImplicitVariantReturnTypeInspectionResultFormat" xml:space="preserve">
    <value>Der Rückgabewert der Methode '{0}' ist implizit 'Variant'.</value>
  </data>
  <data name="MultilineParameterInspectionResultFormat" xml:space="preserve">
    <value>Der Parameter '{0}' wird über mehrere Zeilen angegeben</value>
  </data>
  <data name="NonReturningFunctionInspectionResultFormat" xml:space="preserve">
    <value>Der Rückgabewert der Methode '{0}' wird nicht zugwiesen</value>
  </data>
  <data name="ObsoleteGlobalInspectionResultFormat" xml:space="preserve">
    <value>{0} '{1}' verwendet die veraltete 'Global' Zugriffsdeklaration</value>
  </data>
  <data name="ParameterCanBeByValInspectionResultFormat" xml:space="preserve">
    <value>Der Parameter '{0}' kann als Wert übergeben werden</value>
  </data>
  <data name="ParameterNotUsedInspectionResultFormat" xml:space="preserve">
    <value>Der Parameter '{0}' wird nicht verwendet.</value>
  </data>
  <data name="ProcedureShouldBeFunctionInspectionResultFormat" xml:space="preserve">
    <value>Die Prozedur '{0}' kann als Funktion geschrieben werden.</value>
  </data>
  <data name="UnassignedVariableUsageInspectionResultFormat" xml:space="preserve">
    <value>Die Variable '{0}' wird werdendet ohne ihr einen Wert zuzuweisen</value>
  </data>
  <data name="ConvertFunctionToProcedureQuickFix" xml:space="preserve">
    <value>Konvertiere Funktion zu Prozedur</value>
  </data>
  <data name="DeclareAsExplicitVariantQuickFix" xml:space="preserve">
    <value>Deklariere explizit als 'Variant'</value>
  </data>
  <data name="ImplicitByRefParameterQuickFix" xml:space="preserve">
    <value>Parameter explizit als Referenz angeben</value>
  </data>
  <data name="Inspections_UnassignedVariableTodo" xml:space="preserve">
    <value>TODO</value>
  </data>
  <data name="MakeSingleLineParameterQuickFix" xml:space="preserve">
    <value>Schreibe Variable in einer Zeile</value>
  </data>
  <data name="ObsoleteGlobalInspectionQuickFix" xml:space="preserve">
    <value>Ersetze 'Global' durch 'Public'</value>
  </data>
  <data name="OptionExplicitInspectionResultFormat" xml:space="preserve">
    <value>'Option Explicit' ist für '{0}' nicht angegeben.</value>
  </data>
  <data name="OptionExplicitQuickFix" xml:space="preserve">
    <value>Setze 'Option Explicit'</value>
  </data>
  <data name="PassParameterByReferenceQuickFix" xml:space="preserve">
    <value>Übergebe Parameter als Referenz.</value>
  </data>
  <data name="PassParameterByValueQuickFix" xml:space="preserve">
    <value>Übergebe Parameter als Wert</value>
  </data>
  <data name="QuickFixUseTypedFunction_" xml:space="preserve">
    <value>Ändere '{0}' zu '{1}'</value>
  </data>
  <data name="QuickFix_ThisModule" xml:space="preserve">
    <value>Alle Vorkommnisse im Modul beheben</value>
  </data>
  <data name="QuickFix_ThisProject" xml:space="preserve">
    <value>Alle Vorkommnisse im Projekt beheben</value>
  </data>
  <data name="RemoveCommentQuickFix" xml:space="preserve">
    <value>Entferne Kommentar</value>
  </data>
  <data name="RemoveObsoleteStatementQuickFix" xml:space="preserve">
    <value>Entferne überflüssige Anweisungen</value>
  </data>
  <data name="RemoveTypeHintsQuickFix" xml:space="preserve">
    <value>Entferne Typ-Hinweise</value>
  </data>
  <data name="RemoveUnassignedIdentifierQuickFix" xml:space="preserve">
    <value>Entferne nicht verwendete Variablen</value>
  </data>
  <data name="RemoveUnassignedVariableUsageQuickFix" xml:space="preserve">
    <value>Enferne die Nutzung (bricht den Code)</value>
  </data>
  <data name="RemoveUnusedDeclarationQuickFix" xml:space="preserve">
    <value>Entferne unbenutze Deklarationen</value>
  </data>
  <data name="RemoveUnusedParameterQuickFix" xml:space="preserve">
    <value>Entferne nicht genutzte Parameter</value>
  </data>
  <data name="ReplaceCommentMarkerQuickFix" xml:space="preserve">
    <value>Ersetze 'REM' durch einfaches Anführungszeichen als Kommentarzeichen</value>
  </data>
  <data name="SetExplicitVariantReturnTypeQuickFix" xml:space="preserve">
    <value>Rückgabewert ist explizit 'Variant'</value>
  </data>
  <data name="SpecifyExplicitPublicModifierQuickFix" xml:space="preserve">
    <value>Definiere den Gültigkeitsbereich 'Public' explizit</value>
  </data>
  <data name="SplitMultipleDeclarationsQuickFix" xml:space="preserve">
    <value>Ersetze  Mehrfach-Deklarationen in einer Zeile durch Deklaration in getrennten zeilen</value>
  </data>
  <data name="VariableNotAssignedInspectionResultFormat" xml:space="preserve">
    <value>Der Variable '{0}' wird kein Wert zugewiesen.</value>
  </data>
  <data name="DisableThisInspection" xml:space="preserve">
    <value>Deaktiviere diese Überprüfung</value>
  </data>
  <data name="EmptyStringLiteralInspectionResultFormat" xml:space="preserve">
    <value>vbNullString' sollte statt einem leeren String-Literal verwendet werden.</value>
  </data>
  <data name="InvalidContextTypeInspectionFix" xml:space="preserve">
    <value>Kontexttyp '{0}' ist nicht gültig für {1}.</value>
  </data>
  <data name="QualifiedSelectionInspection" xml:space="preserve">
    <value>{0}: {1} - {2} {3}.{4}, Zeile {5}</value>
  </data>
  <data name="SetObjectVariableQuickFix" xml:space="preserve">
    <value>Benutze das Schlüsselwort 'Set'</value>
  </data>
  <data name="ObjectVariableNotSetInspectionResultFormat" xml:space="preserve">
    <value>Objektvariable '{0}' wird ohne das 'Set' Schlüsselwort zugewiesen</value>
  </data>
  <data name="ObjectVariableNotSetInspectionMeta" xml:space="preserve">
    <value>Rubberduck hat festgestellt, dass die Variable eine Objektvariable ist, die ohne 'Set' Schlüsselwort zugewiesen wird. Dies führt zu dem Laufzeitfehler 91 'Objekt oder With Block Variable wurden nicht gesetzt'.</value>
  </data>
  <data name="ObjectVariableNotSetInspectionName" xml:space="preserve">
    <value>Zuweisung in eine Objektvariable benötigt das 'Set'-Schlüsselwort.</value>
  </data>
  <data name="Inspections_Usage" xml:space="preserve">
    <value>Verwendung</value>
  </data>
  <data name="Inspections_Declaration" xml:space="preserve">
    <value>Deklaration</value>
  </data>
  <data name="VariableTypeNotDeclaredInspectionResultFormat" xml:space="preserve">
    <value>{0} '{1}' ist implizit 'Variant'</value>
  </data>
  <data name="ObsoleteCommentSyntaxInspectionResultFormat" xml:space="preserve">
    <value>Kommentar verwendet die obsolete 'REM' - Markierung</value>
  </data>
  <data name="DefaultProjectNameInspectionResultFormat" xml:space="preserve">
    <value>Projekt '{0}' hat den Standardnamen</value>
  </data>
  <data name="ObsoleteCallStatementInspectionResultFormat" xml:space="preserve">
    <value>Zuweisung verwendet obsolete 'Call' Anweisung</value>
  </data>
  <data name="ObsoleteLetStatementInspectionResultFormat" xml:space="preserve">
    <value>Zuweisung verwendet obsoleten 'Let' Anweisung</value>
  </data>
  <data name="ImplicitActiveSheetReferenceInspectionResultFormat" xml:space="preserve">
    <value>Member '{0}' referenziert implizit auf 'ActiveSheet'</value>
  </data>
  <data name="ImplicitActiveWorkbookReferenceInspectionResultFormat" xml:space="preserve">
    <value>Member '{0}' referenziert implizit auf 'ActiveWorkbook'</value>
  </data>
  <data name="UntypedFunctionUsageInspectionResultFormat" xml:space="preserve">
    <value>Ersetze Funktion {0} mit der existierenden typed function</value>
  </data>
  <data name="OptionBaseInspectionResultFormat" xml:space="preserve">
    <value>Komponente '{0}' verwendet 'Option Base 1'</value>
  </data>
  <data name="ObsoleteTypeHintInspectionResultFormat" xml:space="preserve">
    <value>{0}  von {1} '{2}' verwendet einen obsoleten Typenhinweis</value>
  </data>
  <data name="MultipleDeclarationsInspectionResultFormat" xml:space="preserve">
    <value>Instruktion enthält Mehrfachdeklaration</value>
  </data>
  <data name="MissingAnnotationArgumentInspectionName" xml:space="preserve">
    <value>Unlesbare Annotation</value>
  </data>
  <data name="MissingAnnotationArgumentInspectionResultFormat" xml:space="preserve">
    <value>Annotation '{0}' ist nicht lesbar</value>
  </data>
  <data name="MissingAnnotationArgumentInspectionMeta" xml:space="preserve">
    <value>Eine Annotation in einem Kommentar konnte nicht gelesen werden.</value>
  </data>
  <data name="IntroduceLocalVariableQuickFix" xml:space="preserve">
    <value>Lokale Variable einführen</value>
  </data>
  <data name="UndeclaredVariableInspectionMeta" xml:space="preserve">
    <value>Code, der undeklarierte Variablen verwendet, kompiliert nicht wenn 'Option Explicit' spezifiziert wird. Undeklarierte Variablen sind immer vom Typ 'Variant', was unnötige Zusatzkosten in Ausführungszeit und Speicherverbauch verursacht.</value>
  </data>
  <data name="WriteOnlyPropertyQuickFix" xml:space="preserve">
    <value>Addieren 'Property Get'</value>
  </data>
  <data name="ModuleScopeDimKeywordInspectionMeta" xml:space="preserve">
    <value>Das Schlüsselwort 'Public' kann nur auf Modulebene verwendet werden; Sein Konterpart 'Private' kann auch nur auf Modulebene verwendet werden. 'Dim' jedoch kann verwendet werden, um sowohl modulweite als auch prozedurweite Variablen zu deklarieren. Um der Konsistenz Willen ist es besser, 'Dim' nur für lokale Variablen zu verwenden, also 'Private' statt 'Dim' auf Modulebene zu verwenden.</value>
  </data>
  <data name="ChangeDimToPrivateQuickFix" xml:space="preserve">
    <value>'Dim' durch 'Private' ersetzen</value>
  </data>
  <data name="UndeclaredVariableInspectionName" xml:space="preserve">
    <value>Nicht deklarierte Variable</value>
  </data>
  <data name="ModuleScopeDimKeywordInspectionName" xml:space="preserve">
    <value>Verwendung von 'Dim' auf Modulebene</value>
  </data>
  <data name="UndeclaredVariableInspectionResultFormat" xml:space="preserve">
    <value>Die lokale Variable '{0}' wurde nicht deklariert</value>
  </data>
  <data name="ModuleScopeDimKeywordInspectionResultFormat" xml:space="preserve">
    <value>Die Modulvariable '{0}' ist mit dem 'Dim'-Schlüsselwort deklariert.</value>
  </data>
  <data name="FunctionReturnValueNotUsedInspectionMeta" xml:space="preserve">
    <value>Ein Member ist als Funktion geschrieben, aber wird wie eine Prozedur verwendet. Falls die Funktion nicht rekursiv ist, sollten Sie in Erwägung ziehen, die 'Function' in ein 'Sub' zu konvertieren. Falls die Funktion rekursiv ist, verwendet keiner der externen Aufrufer den Rückgabewert.</value>
  </data>
  <data name="AggregateInspectionResultFormat" xml:space="preserve">
    <value>{0} ({1} Ergebnisse)</value>
  </data>
  <data name="ApplicationWorksheetFunctionQuickFix">
    <value>Application.WorksheetFunction explizit verwenden.</value>
  </data>
  <data name="ApplicationWorksheetFunctionInspectionName">
    <value>Laufzeitgebundener Aufruf an WorksheetFunction</value>
  </data>
  <data name="ApplicationWorksheetFunctionInspectionResultFormat">
    <value>Laufzeitgebundene Nutzung des Application.{0} Members.</value>
  </data>
  <data name="ImplicitDefaultMemberAssignmentInspectionName">
    <value>Implizite Zuweisung an Standard-Member</value>
  </data>
  <data name="HostSpecificExpressionInspectionName">
    <value>Host-Spezifischer geklammerter ausdruck wird nur zur Laufzeit ausgewertet</value>
  </data>
  <data name="ImplicitDefaultMemberAssignmentInspectionResultFormat">
    <value>Zuweisung zu '{0}' weist implizit den Standard-Member von Klasse  '{1}' zu</value>
  </data>
  <data name="HungarianNotationInspectionName">
    <value>Variable verwendet "Hungarian notation".</value>
  </data>
  <data name="MemberNotOnInterfaceInspectionMeta">
    <value>Es wird ein Memberzugriff verwendet, der vom Interface des Objektes nicht deklariert wird. Dies ist höchstwahrscheinlich ein Fehler. Falls der Memberzugriff das erweiterbare Interface des Objektes verwendet, erwägen Sie ein nicht-erweiterbares Äquivalent zu verwenden um Prüfungen zur Kompilierzeit zu ermöglichen und das Auftreten von Laufzeitfehler 418 zu verhindern.</value>
  </data>
  <data name="HungarianNotationInspectionMeta">
    <value>"Hungarian notation" macht code weniger lesbar und ist redundant, sobald stark typisierte Variablen und aussagekräftige Namen verwendet werden.</value>
  </data>
  <data name="ApplicationWorksheetFunctionInspectionMeta">
    <value>Das Excel Application-Objekt implementiert das WorksheetFunction interface direkt. Alle Aufrufe an WorksheetFunction-Member werden als laufzeitgebunden behandelt und Fehler im aufgerufenen Member werden in ein Variant des Typs VbVarType.Error gekapselt. Dadurch können Fehler nicht mit Fehleranweisungen behandelt werden und gegenüber skriptzeitgebundenen Aufrufen sinkt die Performanz. Ziehen Sie in Erwägung Application.WorksheetFunction explizit aufzurufen. Bedenken Sie: Falls dieser Aufruf in der Vergangenheit Fehler erzeugt hat, wurden diese ignoriert. Es sollte eine Fehlerbehandlung vorhanden sein, bevor Sie die schnelle Korrektur anwenden.</value>
  </data>
  <data name="WhiteListIdentifierQuickFix">
    <value>Zur Whitelist hinzufügen</value>
  </data>
  <data name="HostSpecificExpressionInspectionResultFormat">
    <value>Ausdruck '{0}' kann zur Kompilierzeit nicht validiert werden.</value>
  </data>
  <data name="MemberNotOnInterfaceInspectionName">
    <value>Member existiert auf dem Interface nicht</value>
  </data>
  <data name="MemberNotOnInterfaceInspectionResultFormat">
    <value>Member '{0}' ist auf dem Interface für '{1}' nicht deklariert.</value>
  </data>
  <data name="ImplicitDefaultMemberAssignmentInspectionMeta">
    <value>Solche Zuweisungen sehen aus als wiesen sie eine Objektvariable an einen Werttyp zu, aber tatsächlich wird der Standardmember des Objekts implizit zugewiesen. Um die Lesbarkeit zu verbessern, erwägen Sie explizit auf den Standardmember zuzugreifen.</value>
  </data>
  <data name="HostSpecificExpressionInspectionMeta">
    <value>Geklammerte Ausdrücke werden von der Hostanwendung zur Laufzeit ausgewertet, was bedeutet, dass VBA den Ausdruck nicht zur Kompilierzeit validieren kann. Erwägen sie, das hostspezifische Objektmodell zu verwenden.</value>
  </data>
  <data name="AssignedByValParameterMakeLocalCopyQuickFix">
    <value>Eine lokale Kopie des Parameters erstellen und verwenden</value>
  </data>
  <data name="OptionBaseZeroInspectionName">
    <value>'Option Base 0' ist redundant</value>
  </data>
  <data name="OptionBaseZeroInspectionResultFormat">
    <value>Komponente '{0}' verwendet 'Option Base 0'</value>
  </data>
  <data name="QuickFix_All">
    <value>Alle Vorkommnisse beheben</value>
  </data>
  <data name="QuickFix_ThisProcedure">
    <value>Alle Vorkommnisse in der Prozedur beheben</value>
  </data>
  <data name="OptionBaseZeroInspectionMeta">
    <value>Dies ist die Standardeinstellung, sie muss nicht spezifiziert werden.</value>
  </data>
  <data name="RemoveOptionBaseStatementQuickFix">
    <value>'Option Base'-Anweisung entfernen</value>
  </data>
</root>
