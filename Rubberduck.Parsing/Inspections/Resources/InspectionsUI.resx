<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AssignedByValParameterInspectionMeta" xml:space="preserve">
    <value>Parameter is passed by value, but is assigned a new value/reference. Consider making a local copy instead if the caller isn't supposed to know the new value. If the caller should see the new value, the parameter should be passed ByRef instead, and you have a bug.</value>
  </data>
  <data name="AssignedByValParameterInspectionName" xml:space="preserve">
    <value>ByVal parameter is assigned</value>
  </data>
  <data name="ConstantNotUsedInspectionMeta" xml:space="preserve">
    <value>Rubberduck could not find any reference to constant. Consider removing the unused declaration.</value>
  </data>
  <data name="ConstantNotUsedInspectionName" xml:space="preserve">
    <value>Constant is not used</value>
  </data>
  <data name="DefaultProjectNameInspectionMeta" xml:space="preserve">
    <value>Consider naming your VBA project.</value>
  </data>
  <data name="DefaultProjectNameInspectionName" xml:space="preserve">
    <value>Project name is not specified</value>
  </data>
  <data name="EmptyStringLiteralInspection" xml:space="preserve">
    <value>Prefer 'vbNullString' to an empty string literal</value>
  </data>
  <data name="EmptyStringLiteralInspectionMeta" xml:space="preserve">
    <value>The built-in constant 'vbNullString' is a null string pointer taking up 0 bytes of memory, that unambiguously conveys the intent of an empty string.</value>
  </data>
  <data name="EmptyStringLiteralInspectionName" xml:space="preserve">
    <value>Empty string literal</value>
  </data>
  <data name="EmptyStringLiteralInspectionQuickFix" xml:space="preserve">
    <value>Replace empty string with the 'vbNullString' constant</value>
  </data>
  <data name="EncapsulatePublicFieldInspectionResultFormat" xml:space="preserve">
    <value>Public field '{0}' breaks encapsulation</value>
  </data>
  <data name="EncapsulatePublicFieldInspectionMeta" xml:space="preserve">
    <value>Consider exposing a property instead.</value>
  </data>
  <data name="EncapsulatePublicFieldInspectionName" xml:space="preserve">
    <value>Public field breaks encapsulation</value>
  </data>
  <data name="EncapsulatePublicFieldInspectionQuickFix" xml:space="preserve">
    <value>Encapsulate field '{0}' with a property</value>
  </data>
  <data name="IgnoreOnce" xml:space="preserve">
    <value>Ignore once</value>
  </data>
  <data name="ImplicitActiveSheetReferenceInspectionMeta" xml:space="preserve">
    <value>Implicit references to the active sheet make the code frail and harder to debug. Consider making these references explicit when they're intended, and prefer working off object references. Ignore if the member call is referring to a type Rubberduck can't resolve.</value>
  </data>
  <data name="ImplicitActiveSheetReferenceInspectionName" xml:space="preserve">
    <value>Implicit reference to ActiveSheet</value>
  </data>
  <data name="ImplicitActiveWorkbookReferenceInspectionMeta" xml:space="preserve">
    <value>Implicit references to the active workbook make the code frail and harder to debug. Consider making these references explicit when they're intended, and prefer working off object references. Ignore if the member call is referring to a type Rubberduck can't resolve.</value>
  </data>
  <data name="ImplicitActiveWorkbookReferenceInspectionName" xml:space="preserve">
    <value>Implicit reference to ActiveWorkbook</value>
  </data>
  <data name="ImplicitByRefModifierInspectionMeta" xml:space="preserve">
    <value>Parameters are passed by reference unless specified otherwise, which can be confusing and bug-prone. Prefer passing parameters by value, and specify ByRef explicitly when passing parameters by reference.</value>
  </data>
  <data name="ImplicitByRefModifierInspectionName" xml:space="preserve">
    <value>Implicit ByRef parameter</value>
  </data>
  <data name="ImplicitPublicMemberInspectionMeta" xml:space="preserve">
    <value>Module members are public by default, which can be counter-intuitive. Consider specifying explicit access modifiers to avoid ambiguity.</value>
  </data>
  <data name="ImplicitPublicMemberInspectionName" xml:space="preserve">
    <value>Implicitly public member</value>
  </data>
  <data name="ImplicitVariantReturnTypeInspectionMeta" xml:space="preserve">
    <value>Members with a return value implicitly return a 'Variant' unless specified otherwise. Consider returning an explicit 'Variant' when the return type isn't known, or specify it explicitly.</value>
  </data>
  <data name="ImplicitVariantReturnTypeInspectionName" xml:space="preserve">
    <value>Member return type is implicitly 'Variant'</value>
  </data>
  <data name="MoveFieldCloserToUsageInspectionMeta" xml:space="preserve">
    <value>A module-level variable used only in one procedure should be declared in that procedure.</value>
  </data>
  <data name="MoveFieldCloserToUsageInspectionName" xml:space="preserve">
    <value>Scope of variable is broader than it needs to be</value>
  </data>
  <data name="MoveFieldCloserToUsageInspectionResultFormat" xml:space="preserve">
    <value>Move module-level variable '{0}' to a smaller scope.</value>
  </data>
  <data name="MultilineParameterInspectionMeta" xml:space="preserve">
    <value>Consider continuing long signatures between parameters. Splitting a parameter declaration across multiple lines arguably hurts readability.</value>
  </data>
  <data name="MultilineParameterInspectionName" xml:space="preserve">
    <value>Parameter declaration is split on multiple lines</value>
  </data>
  <data name="MultipleDeclarationsInspectionMeta" xml:space="preserve">
    <value>Declaring multiple variables in the same instruction is legal, but should be used sparingly. Consider declaring variables closer to their usage, in a single instruction per declaration.</value>
  </data>
  <data name="MultipleDeclarationsInspectionName" xml:space="preserve">
    <value>Multiple declarations in single instruction</value>
  </data>
  <data name="MultipleFolderAnnotationsInspectionResultFormat" xml:space="preserve">
    <value>'{0}' has more than one '@Folder' annotation.</value>
  </data>
  <data name="MultipleFolderAnnotationsInspectionMeta" xml:space="preserve">
    <value>Rubberduck only uses the first '@Folder' annotation in a code module; consider removing extraneous ones.</value>
  </data>
  <data name="MultipleFolderAnnotationsInspectionName" xml:space="preserve">
    <value>Module has more than one folder annotation.</value>
  </data>
  <data name="NonReturningFunctionInspectionMeta" xml:space="preserve">
    <value>This is likely a bug. The return value of a function or property getter must be assigned before exiting, otherwise the program will not be working with expected results. If a function has no meaningful return value, consider declaring it as a 'Sub' procedure instead.</value>
  </data>
  <data name="NonReturningFunctionInspectionName" xml:space="preserve">
    <value>Non-returning function or property getter</value>
  </data>
  <data name="ObsoleteCallStatementInspectionMeta" xml:space="preserve">
    <value>The 'Call' statement is no longer required to call procedures, and only exists in the language to support legacy code that required it; it can be safely rewritten to an implicit call.</value>
  </data>
  <data name="ObsoleteCallStatementInspectionName" xml:space="preserve">
    <value>Use of obsolete 'Call' statement</value>
  </data>
  <data name="ObsoleteCommentSyntaxInspectionMeta" xml:space="preserve">
    <value>The 'Rem' statement only exists in the language to support legacy code that required it; it can be safely replaced with an apostrophe / single-quote comment.</value>
  </data>
  <data name="ObsoleteCommentSyntaxInspectionName" xml:space="preserve">
    <value>Use of obsolete 'Rem' statement</value>
  </data>
  <data name="ObsoleteGlobalInspectionMeta" xml:space="preserve">
    <value>The 'Global' keyword only exists in the language to support legacy code that required it; it can be safely replaced with the 'Public' modifier.</value>
  </data>
  <data name="ObsoleteGlobalInspectionName" xml:space="preserve">
    <value>Use of obsolete 'Global' access modifier</value>
  </data>
  <data name="ObsoleteLetStatementInspectionMeta" xml:space="preserve">
    <value>The 'Let' statement only exists in the language to support legacy code that required it; it can be safely removed, since modern VBA does not require that keyword for value assignments.</value>
  </data>
  <data name="ObsoleteLetStatementInspectionName" xml:space="preserve">
    <value>Use of obsolete explicit 'Let' statement</value>
  </data>
  <data name="ObsoleteTypeHintInspectionMeta" xml:space="preserve">
    <value>Type hint characters only exist in the language to support legacy code that required it; they can be safely replaced in declarations with an "As" type clause that specifies the type explicitly, and they can be omitted in other identifier references.</value>
  </data>
  <data name="ObsoleteTypeHintInspectionName" xml:space="preserve">
    <value>Obsolete Type hint usage</value>
  </data>
  <data name="OptionBaseInspectionMeta" xml:space="preserve">
    <value>Arrays are typically zero-based. This option changes the default lower boundary for implicitly-sized arrays, which can introduce off-by-one errors if one isn't cautious.</value>
  </data>
  <data name="OptionBaseInspectionName" xml:space="preserve">
    <value>'Option Base 1' is specified</value>
  </data>
  <data name="OptionExplicitInspectionMeta" xml:space="preserve">
    <value>VBA will happily compile a typo: use 'Option Explicit' to prevent successfully compiling an erroneous program.</value>
  </data>
  <data name="OptionExplicitInspectionName" xml:space="preserve">
    <value>'Option Explicit' is not specified</value>
  </data>
  <data name="ParameterCanBeByValInspectionMeta" xml:space="preserve">
    <value>A parameter that is passed by reference and isn't assigned a new value/reference, could be passed by value instead.</value>
  </data>
  <data name="ParameterCanBeByValInspectionName" xml:space="preserve">
    <value>Parameter can be passed by value</value>
  </data>
  <data name="ParameterNotUsedInspectionMeta" xml:space="preserve">
    <value>A parameter is passed into a member that does not use it. Consider removing that parameter.</value>
  </data>
  <data name="ParameterNotUsedInspectionName" xml:space="preserve">
    <value>Parameter is not referred to</value>
  </data>
  <data name="ProcedureNotUsedInspectionMeta" xml:space="preserve">
    <value>Rubberduck could not find any caller for a procedure. If the procedure is hooked to a macro-button, used as a user-defined function (UDF) or handles an application event that Rubberduck didn't know of you can safely ignore this inspection result; otherwise, consider removing it.</value>
  </data>
  <data name="ProcedureNotUsedInspectionName" xml:space="preserve">
    <value>Procedure is not referred to</value>
  </data>
  <data name="UnassignedVariableUsageInspectionMeta" xml:space="preserve">
    <value>This is likely a bug. A variable is being referred to, but is never assigned.</value>
  </data>
  <data name="UnassignedVariableUsageInspectionName" xml:space="preserve">
    <value>Variable is used but not assigned</value>
  </data>
  <data name="UntypedFunctionUsageInspectionMeta" xml:space="preserve">
    <value>A string-returning equivalent function exists and should preferably be used to avoid implicit type conversions. 
If the parameter can be null, ignore this inspection result; passing a null value to a function expecting a string would raise a type mismatch runtime error.</value>
  </data>
  <data name="UntypedFunctionUsageInspectionName" xml:space="preserve">
    <value>Use of variant-returning string function</value>
  </data>
  <data name="ProcedureCanBeWrittenAsFunctionInspectionResultFormat" xml:space="preserve">
    <value>Procedure '{0}' can be written as a function.</value>
    <comment>{0} Procedure name</comment>
  </data>
  <data name="ProcedureShouldBeFunctionInspectionQuickFix" xml:space="preserve">
    <value>Implement as function and update usages.</value>
  </data>
  <data name="IdentifierNameInspectionResultFormat" xml:space="preserve">
    <value>Consider renaming {0} '{1}'</value>
  </data>
  <data name="UseMeaningfulNameInspectionMeta" xml:space="preserve">
    <value>Identifier names should indicate what they're used for and should be readable; avoid disemvoweling, numeric suffixes, and 1-2 character names.</value>
  </data>
  <data name="UseMeaningfulNameInspectionName" xml:space="preserve">
    <value>Use meaningful names</value>
  </data>
  <data name="VariableNotAssignedInspectionMeta" xml:space="preserve">
    <value>Variable is not assigned. If this isn't intended, there's probably a bug. Ignore this inspection result if the variable is assigned in another procedure via a ByRef parameter.</value>
  </data>
  <data name="VariableNotAssignedInspectionName" xml:space="preserve">
    <value>Variable is not assigned</value>
  </data>
  <data name="VariableNotUsedInspectionMeta" xml:space="preserve">
    <value>Variable is not referred to</value>
  </data>
  <data name="VariableNotUsedInspectionName" xml:space="preserve">
    <value>Variable is not referred to</value>
  </data>
  <data name="VariableTypeNotDeclaredInspectionMeta" xml:space="preserve">
    <value>A variable whose type isn't explicitly declared, is implicitly 'Variant'. Consider making it an explicit 'Variant' if that's intended, or declare a more specific type.</value>
  </data>
  <data name="VariableTypeNotDeclaredInspectionName" xml:space="preserve">
    <value>Implicitly 'Variant' variable</value>
  </data>
  <data name="WriteOnlyPropertyInspectionMeta" xml:space="preserve">
    <value>A property that exposes a mutator but no accessor is a design smell and makes a confusing API. Consider exposing a getter, or converting the mutator to a method.</value>
  </data>
  <data name="WriteOnlyPropertyInspectionName" xml:space="preserve">
    <value>Write-only property</value>
  </data>
  <data name="ProcedureCanBeWrittenAsFunctionInspectionMeta" xml:space="preserve">
    <value>A procedure that only has one parameter passed by reference that is assigned a new value/reference before the procedure exits, is using a ByRef parameter as a return value: consider making it a function instead.</value>
  </data>
  <data name="ProcedureCanBeWrittenAsFunctionInspectionName" xml:space="preserve">
    <value>Procedure can be written as a function</value>
  </data>
  <data name="WriteOnlyPropertyInspectionResultFormat" xml:space="preserve">
    <value>Property '{0}' has no getter</value>
    <comment>{0} Property name</comment>
  </data>
  <data name="SelfAssignedDeclarationInspectionResultFormat" xml:space="preserve">
    <value>Object reference '{0}' is auto-instantiated</value>
  </data>
  <data name="SelfAssignedDeclarationInspectionMeta" xml:space="preserve">
    <value>An auto-instantiated object variable declaration at procedure scope changes how nulling the reference works, which can lead to unexpected behavior.</value>
  </data>
  <data name="SelfAssignedDeclarationInspectionName" xml:space="preserve">
    <value>Object variable reference is auto-instantiated</value>
  </data>
  <data name="FunctionReturnValueNotUsedInspectionName" xml:space="preserve">
    <value>Function return value is never used</value>
  </data>
  <data name="FunctionReturnValueNotUsedInspectionResultFormat" xml:space="preserve">
    <value>Return value of function '{0}' is never used.</value>
  </data>
  <data name="AssignedByValParameterInspectionResultFormat" xml:space="preserve">
    <value>Parameter '{0}' is passed ByVal and assigned a value</value>
  </data>
  <data name="FunctionReturnValueNotUsedInspectionMeta" xml:space="preserve">
    <value>A member is written as a function, but used as a procedure. Unless the function is recursive, consider converting the 'Function' into a 'Sub'. If the function is recursive, none of its external callers are using the returned value.</value>
  </data>
  <data name="IdentifierNotUsedInspectionResultFormat" xml:space="preserve">
    <value>{0} '{1}' is not used</value>
  </data>
  <data name="ImplicitByRefModifierInspectionResultFormat" xml:space="preserve">
    <value>Parameter '{0}' is implicitly passed by reference</value>
  </data>
  <data name="ImplicitPublicMemberInspectionResultFormat" xml:space="preserve">
    <value>Member '{0}' is implicitly public</value>
  </data>
  <data name="ImplicitVariantDeclarationInspectionResultFormat" xml:space="preserve">
    <value>{0} '{1}' is implicitly Variant</value>
  </data>
  <data name="ImplicitVariantReturnTypeInspectionResultFormat" xml:space="preserve">
    <value>Return type of member '{0}' is implicitly 'Variant'</value>
  </data>
  <data name="MultilineParameterInspectionResultFormat" xml:space="preserve">
    <value>Parameter '{0}' is specified on multiple lines</value>
  </data>
  <data name="NonReturningFunctionInspectionResultFormat" xml:space="preserve">
    <value>Return value for member '{0}' is never assigned</value>
  </data>
  <data name="ObsoleteGlobalInspectionResultFormat" xml:space="preserve">
    <value>{0} '{1}' uses obsolete 'Global' access modifier</value>
  </data>
  <data name="ParameterCanBeByValInspectionResultFormat" xml:space="preserve">
    <value>Parameter '{0}' can be passed by value</value>
  </data>
  <data name="ParameterNotUsedInspectionResultFormat" xml:space="preserve">
    <value>Parameter '{0}' is never used</value>
  </data>
  <data name="ProcedureShouldBeFunctionInspectionResultFormat" xml:space="preserve">
    <value>Procedure '{0}' can be written as a function</value>
  </data>
  <data name="UnassignedVariableUsageInspectionResultFormat" xml:space="preserve">
    <value>Variable '{0}' is used but not assigned</value>
  </data>
  <data name="ConvertFunctionToProcedureQuickFix" xml:space="preserve">
    <value>Convert function to procedure</value>
  </data>
  <data name="DeclareAsExplicitVariantQuickFix" xml:space="preserve">
    <value>Declare as explicit Variant</value>
  </data>
  <data name="ImplicitByRefModifierQuickFix" xml:space="preserve">
    <value>Pass parameter by reference explicitly</value>
  </data>
  <data name="Inspections_Declaration" xml:space="preserve">
    <value>Declaration</value>
  </data>
  <data name="Inspections_UnassignedVariableTodo" xml:space="preserve">
    <value>TODO</value>
  </data>
  <data name="Inspections_Usage" xml:space="preserve">
    <value>Usage</value>
  </data>
  <data name="MakeSingleLineParameterQuickFix" xml:space="preserve">
    <value>Write variable on one line</value>
  </data>
  <data name="ObsoleteGlobalInspectionQuickFix" xml:space="preserve">
    <value>Replace 'Global' access modifier with 'Public'</value>
  </data>
  <data name="OptionExplicitInspectionResultFormat" xml:space="preserve">
    <value>Option Explicit is not specified in '{0}'</value>
  </data>
  <data name="OptionExplicitQuickFix" xml:space="preserve">
    <value>Specify 'Option Explicit'</value>
  </data>
  <data name="PassParameterByReferenceQuickFix" xml:space="preserve">
    <value>Pass parameter by reference</value>
  </data>
  <data name="PassParameterByValueQuickFix" xml:space="preserve">
    <value>Pass parameter by value</value>
  </data>
  <data name="QuickFixUseTypedFunction_" xml:space="preserve">
    <value>Change '{0}' to '{1}'</value>
  </data>
  <data name="QuickFix_ThisModule" xml:space="preserve">
    <value>Fix all occurrences in module</value>
  </data>
  <data name="QuickFix_ThisProject" xml:space="preserve">
    <value>Fix all occurrences in project</value>
  </data>
  <data name="RemoveCommentQuickFix" xml:space="preserve">
    <value>Remove comment</value>
  </data>
  <data name="RemoveObsoleteStatementQuickFix" xml:space="preserve">
    <value>Remove obsolete statement</value>
  </data>
  <data name="RemoveTypeHintsQuickFix" xml:space="preserve">
    <value>Remove type hints</value>
  </data>
  <data name="RemoveUnassignedIdentifierQuickFix" xml:space="preserve">
    <value>Remove unassigned variable</value>
  </data>
  <data name="RemoveUnassignedVariableUsageQuickFix" xml:space="preserve">
    <value>Remove usage (breaks code)</value>
  </data>
  <data name="RemoveUnusedDeclarationQuickFix" xml:space="preserve">
    <value>Remove unused declaration</value>
  </data>
  <data name="RemoveUnusedParameterQuickFix" xml:space="preserve">
    <value>Remove unused parameter</value>
  </data>
  <data name="ReplaceCommentMarkerQuickFix" xml:space="preserve">
    <value>Replace 'Rem' usage with a single-quote comment marker</value>
  </data>
  <data name="SetExplicitVariantReturnTypeQuickFix" xml:space="preserve">
    <value>Return explicit Variant</value>
  </data>
  <data name="SpecifyExplicitPublicModifierQuickFix" xml:space="preserve">
    <value>Specify Public access modifier explicitly</value>
  </data>
  <data name="SplitMultipleDeclarationsQuickFix" xml:space="preserve">
    <value>Separate multiple declarations into multiple instructions</value>
  </data>
  <data name="EmptyStringLiteralInspectionResultFormat" xml:space="preserve">
    <value>'vbNullString' preferred to empty string literals</value>
  </data>
  <data name="VariableNotAssignedInspectionResultFormat" xml:space="preserve">
    <value>Variable '{0}' is not assigned</value>
  </data>
  <data name="DisableThisInspection" xml:space="preserve">
    <value>Disable this inspection</value>
  </data>
  <data name="InvalidContextTypeInspectionFix" xml:space="preserve">
    <value>Context type '{0}' is not valid for {1}.</value>
  </data>
  <data name="QualifiedSelectionInspection" xml:space="preserve">
    <value>{0}: {1} - {2} {3}.{4}, line {5}</value>
  </data>
  <data name="ObjectVariableNotSetInspectionMeta" xml:space="preserve">
    <value>As far as Rubberduck can tell, this variable is an object variable, assigned without the 'Set' keyword. This causes run-time error 91 'Object or With block variable not set'.</value>
  </data>
  <data name="ObjectVariableNotSetInspectionResultFormat" xml:space="preserve">
    <value>Object variable '{0}' is assigned without the 'Set' keyword</value>
    <comment>{0} Variable name</comment>
  </data>
  <data name="SetObjectVariableQuickFix" xml:space="preserve">
    <value>Use 'Set' keyword</value>
  </data>
  <data name="ObjectVariableNotSetInspectionName" xml:space="preserve">
    <value>Object variable assignment requires 'Set' keyword</value>
  </data>
  <data name="DefaultProjectNameInspectionResultFormat" xml:space="preserve">
    <value>Project '{0}' has default name</value>
  </data>
  <data name="ObsoleteCallStatementInspectionResultFormat" xml:space="preserve">
    <value>Assignment uses obsolete 'Call' modifier</value>
  </data>
  <data name="ObsoleteCommentSyntaxInspectionResultFormat" xml:space="preserve">
    <value>Comment uses obsolete 'Rem' marker</value>
  </data>
  <data name="ObsoleteLetStatementInspectionResultFormat" xml:space="preserve">
    <value>Assignment uses obsolete 'Let' modifier</value>
  </data>
  <data name="ImplicitActiveSheetReferenceInspectionResultFormat" xml:space="preserve">
    <value>Member '{0}' implicitly references ActiveSheet</value>
  </data>
  <data name="ImplicitActiveWorkbookReferenceInspectionResultFormat" xml:space="preserve">
    <value>Member '{0}' implicitly references ActiveWorkbook</value>
  </data>
  <data name="MultipleDeclarationsInspectionResultFormat" xml:space="preserve">
    <value>Instruction contains multiple declarations</value>
  </data>
  <data name="ObsoleteTypeHintInspectionResultFormat" xml:space="preserve">
    <value>{0} of {1} '{2}' uses an obsolete type hint</value>
  </data>
  <data name="OptionBaseInspectionResultFormat" xml:space="preserve">
    <value>Component '{0}' uses 'Option Base 1'</value>
  </data>
  <data name="UntypedFunctionUsageInspectionResultFormat" xml:space="preserve">
    <value>Replace function '{0}' with existing typed function</value>
  </data>
  <data name="VariableTypeNotDeclaredInspectionResultFormat" xml:space="preserve">
    <value>{0} '{1}' is implicitly 'Variant'</value>
  </data>
  <data name="MissingAnnotationArgumentInspectionMeta" xml:space="preserve">
    <value>An annotation parameter is missing or incorrectly specified. The correct syntax is : '@Annotation([parameter])\nExample: '@Folder("Parent.Child")</value>
  </data>
  <data name="MissingAnnotationArgumentInspectionName" xml:space="preserve">
    <value>Missing annotation parameter</value>
  </data>
  <data name="MissingAnnotationArgumentInspectionResultFormat" xml:space="preserve">
    <value>Expression '{0}' was expected to contain a parameter, but none was specified.</value>
  </data>
  <data name="WriteOnlyPropertyQuickFix" xml:space="preserve">
    <value>Add property get accessor</value>
  </data>
  <data name="ChangeDimToPrivateQuickFix" xml:space="preserve">
    <value>Replace 'Dim' with 'Private'</value>
  </data>
  <data name="ModuleScopeDimKeywordInspectionMeta" xml:space="preserve">
    <value>The 'Public' keyword can only be used at module level; its counterpart 'Private' can also only be used at module level. 'Dim' however, can be used to declare both procedure and module scope variables. For consistency, it would be preferable to reserve 'Dim' for locals, and thus to use 'Private' instead of 'Dim' at module level.</value>
  </data>
  <data name="ModuleScopeDimKeywordInspectionName" xml:space="preserve">
    <value>Use of 'Dim' keyword at module level</value>
  </data>
  <data name="ModuleScopeDimKeywordInspectionResultFormat" xml:space="preserve">
    <value>Module-level variable '{0}' is declared with the 'Dim' keyword.</value>
  </data>
  <data name="UndeclaredVariableInspectionMeta" xml:space="preserve">
    <value>Code that uses undeclared variables does not compile when Option Explicit is specified. Undeclared variables are always Variant, a data type that incurs unnecessary overhead and storage.</value>
  </data>
  <data name="UndeclaredVariableInspectionName" xml:space="preserve">
    <value>Undeclared variable</value>
  </data>
  <data name="UndeclaredVariableInspectionResultFormat" xml:space="preserve">
    <value>Local variable '{0}' is not declared</value>
    <comment>{0} variable name</comment>
  </data>
  <data name="IntroduceLocalVariableQuickFix" xml:space="preserve">
    <value>Introduce local variable</value>
  </data>
  <data name="ImplicitDefaultMemberAssignmentInspectionMeta" xml:space="preserve">
    <value>Such assignments look like they are assigning an object variable to a value type on the surface, but they are actually assigning that object's default member, implicitly. Consider referring to the default member explicitly, for improved readability.</value>
  </data>
  <data name="ImplicitDefaultMemberAssignmentInspectionName" xml:space="preserve">
    <value>Implicit default member assignment</value>
  </data>
  <data name="ImplicitDefaultMemberAssignmentInspectionResultFormat" xml:space="preserve">
    <value>Assignment to '{0}' implicitly assigns default member of class '{1}'</value>
  </data>
  <data name="AggregateInspectionResultFormat" xml:space="preserve">
    <value>{0} ({1} results)</value>
    <comment>{0} inpection description, {1} result count</comment>
  </data>
  <data name="HungarianNotationInspectionMeta" xml:space="preserve">
    <value>Hungarian notation makes code less readable, and is redundant when strongly typed variables and meaningful names are used.</value>
  </data>
  <data name="HungarianNotationInspectionName" xml:space="preserve">
    <value>Variable uses Hungarian notation.</value>
  </data>
  <data name="WhiteListIdentifierQuickFix" xml:space="preserve">
    <value>Add to whitelist</value>
  </data>
  <data name="MemberNotOnInterfaceInspectionMeta" xml:space="preserve">
    <value>A member access call is made against an extended interface that Rubberduck couldn't resolve, or the member couldn't be found. If VBA cannot resolve the type at run-time, error 438 will be raised. If an equivalent, non-extended interface that Rubberduck can resolve is available, consider using it instead.</value>
  </data>
  <data name="MemberNotOnInterfaceInspectionName" xml:space="preserve">
    <value>Member not found</value>
  </data>
  <data name="MemberNotOnInterfaceInspectionResultFormat" xml:space="preserve">
    <value>Member '{0}' was not found on the compile-time interface for type '{1}'.</value>
    <comment>{0} Member used, {1} type being accessed.</comment>
  </data>
  <data name="HostSpecificExpressionInspectionMeta" xml:space="preserve">
    <value>Bracketed expressions are evaluated by the host application at runtime, which means VBA can't validate the expression at compile-time. Consider using the host application's object model instead.</value>
  </data>
  <data name="HostSpecificExpressionInspectionName" xml:space="preserve">
    <value>Host-specific bracketed expression is only evaluated at runtime</value>
  </data>
  <data name="HostSpecificExpressionInspectionResultFormat" xml:space="preserve">
    <value>Expression '{0}' cannot be validated at compile-time.</value>
  </data>
  <data name="ApplicationWorksheetFunctionInspectionMeta" xml:space="preserve">
    <value>The Excel Application object does not implement the WorksheetFunction interface directly. All calls made to WorksheetFunction members are handled as late bound and errors in the called member will be returned wrapped in a Variant of VbVarType.vbError. This makes errors un-trappable with error handlers and adds a performance penalty in comparison to early bound calls. Consider calling Application.WorksheetFunction explicitly. Note: If this call generated errors in the past, those errors were ignored. If applying the quick fix, proper error handling should be in place.</value>
  </data>
  <data name="ApplicationWorksheetFunctionInspectionName" xml:space="preserve">
    <value>Late bound WorksheetFunction call.</value>
  </data>
  <data name="ApplicationWorksheetFunctionInspectionResultFormat" xml:space="preserve">
    <value>Use of late bound Application.{0} member.</value>
    <comment>{0} Member name</comment>
  </data>
  <data name="ApplicationWorksheetFunctionQuickFix" xml:space="preserve">
    <value>Use Application.WorksheetFunction explicitly.</value>
  </data>
  <data name="AssignedByValParameterMakeLocalCopyQuickFix" xml:space="preserve">
    <value>Create and use a local copy of the parameter</value>
  </data>
  <data name="OptionBaseZeroInspectionMeta" xml:space="preserve">
    <value>This is the default setting, it does not need to be specified.</value>
  </data>
  <data name="OptionBaseZeroInspectionName" xml:space="preserve">
    <value>'Option Base 0' is redundant</value>
  </data>
  <data name="OptionBaseZeroInspectionResultFormat" xml:space="preserve">
    <value>Component '{0}' uses 'Option Base 0'</value>
  </data>
  <data name="RemoveOptionBaseStatementQuickFix" xml:space="preserve">
    <value>Remove 'Option Base' statement</value>
  </data>
  <data name="QuickFix_All" xml:space="preserve">
    <value>Fix all occurences</value>
  </data>
  <data name="QuickFix_ThisProcedure" xml:space="preserve">
    <value>Fix all occurrences in procedure</value>
  </data>
  <data name="IllegalAnnotationInspectionMeta" xml:space="preserve">
    <value>An annotation meant to be specified at module level cannot be used to annotate members; annotations meant to be annotate members cannot be used at module level; module and member annotations should only be specified once.</value>
  </data>
  <data name="IllegalAnnotationInspectionName" xml:space="preserve">
    <value>Illegal annotation</value>
  </data>
  <data name="IllegalAnnotationInspectionResultFormat" xml:space="preserve">
    <value>Annotation '{0}' is illegal in this context.</value>
    <comment>{0} annotation name</comment>
  </data>
  <data name="MissingAnnotationInspectionMeta" xml:space="preserve">
    <value>Module and member attributes are not displayed in the VBE. By adding an annotation, you make these attributes more explicit, and Rubberduck can keep annotations and attributes synchronized.</value>
  </data>
  <data name="MissingAnnotationInspectionName" xml:space="preserve">
    <value>Missing annotation</value>
  </data>
  <data name="MissingAnnotationInspectionResultFormat" xml:space="preserve">
    <value>Module or member '{0}' has a '{1}' attribute, but no corresponding annotation</value>
    <comment>{0} module/member; {1} specified attribute</comment>
  </data>
  <data name="MissingAttributeInspectionMeta" xml:space="preserve">
    <value>A Rubberduck annotation is specified for a module or member, but the corresponding attribute isn't present. Module attributes and annotations need to be synchronized.</value>
  </data>
  <data name="MissingAttributeInspectionName" xml:space="preserve">
    <value>Missing attribute</value>
  </data>
  <data name="MissingAttributeInspectionResultFormat" xml:space="preserve">
    <value>Module or member '{0}' has a '{1}' annotation, but no corresponding attribute</value>
    <comment>{0} module/member; {1} specified annotation</comment>
  </data>
  <data name="SynchronizeAttributesQuickFix" xml:space="preserve">
    <value>Synchronize attributes/annotations in module</value>
  </data>
  <data name="EmptyIfBlockInspectionMeta" xml:space="preserve">
    <value>An empty conditional branch without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn't need to be written.</value>
  </data>
  <data name="EmptyIfBlockInspectionName" xml:space="preserve">
    <value>Empty conditional branch</value>
  </data>
  <data name="EmptyIfBlockInspectionResultFormat" xml:space="preserve">
    <value>'If' block contains no executable statements.</value>
  </data>
  <data name="RemoveEmptyIfBlockQuickFix" xml:space="preserve">
    <value>Remove empty If block</value>
  </data>
  <data name="RedundantOptionInspectionMeta" xml:space="preserve">
    <value>Being the default/implicit setting for this option, this instruction can be safely omitted.</value>
  </data>
  <data name="RedundantOptionInspectionName" xml:space="preserve">
    <value>Redundant module option</value>
  </data>
  <data name="RedundantOptionInspectionResultFormat" xml:space="preserve">
    <value>'{0}' has no effect</value>
    <comment>'{0}' the whole ModuleOptionContext text</comment>
  </data>
  <data name="RedundantByRefModifierInspectionMeta" xml:space="preserve">
    <value>By default, all parameters are passed by reference, so it is not necessary to include the 'ByRef' modifier.</value>
  </data>
  <data name="RedundantByRefModifierInspectionName" xml:space="preserve">
    <value>Redundant 'ByRef' modifier</value>
  </data>
  <data name="RedundantByRefModifierInspectionResultFormat" xml:space="preserve">
    <value>Parameter '{0}' has a redundant ByRef modifier</value>
  </data>
  <data name="RedundantByRefModifierQuickFix" xml:space="preserve">
    <value>Remove 'ByRef' modifier</value>
  </data>
  <data name="LineLabelNotUsedInspectionMeta" xml:space="preserve">
    <value>A line label that is never jumpted to ('GoTo', 'Resume', ...), serves no purpose. Consider removing it.</value>
  </data>
  <data name="LineLabelNotUsedInspectionName" xml:space="preserve">
    <value>Line label is not used</value>
  </data>
  <data name="LineLabelNotUsedInspectionResultFormat" xml:space="preserve">
    <value>Line label '{0}' is not used</value>
    <comment>{0} line label name</comment>
  </data>
  <data name="CodeInspectionSettings_CodeQualityIssues" xml:space="preserve">
    <value>Code Quality Issues</value>
  </data>
  <data name="CodeInspectionSettings_LanguageOpportunities" xml:space="preserve">
    <value>Language Opportunities</value>
  </data>
  <data name="CodeInspectionSettings_MaintainabilityAndReadabilityIssues" xml:space="preserve">
    <value>Maintainability and Readability Issues</value>
  </data>
  <data name="CodeInspectionSettings_Performance" xml:space="preserve">
    <value>Performance</value>
  </data>
  <data name="CodeInspectionSettings_RubberduckOpportunities" xml:space="preserve">
    <value>Rubberduck Opportunities</value>
  </data>
  <data name="CodeInspectionSeverity_DoNotShow" xml:space="preserve">
    <value>Do Not Show</value>
  </data>
  <data name="CodeInspectionSeverity_Error" xml:space="preserve">
    <value>Error</value>
  </data>
  <data name="CodeInspectionSeverity_Hint" xml:space="preserve">
    <value>Hint</value>
  </data>
  <data name="CodeInspectionSeverity_Suggestion" xml:space="preserve">
    <value>Suggestion</value>
  </data>
  <data name="CodeInspectionSeverity_Warning" xml:space="preserve">
    <value>Warning</value>
  </data>
  <data name="EmptyElseBlockInspectionResultFormat" xml:space="preserve">
    <value>'Else' block contains no executable statements</value>
  </data>
  <data name="EmptyElseBlockInspectionMeta" xml:space="preserve">
    <value>An empty 'Else' loop without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn't need to be written.</value>
  </data>
  <data name="EmptyElseBlockInspectionName" xml:space="preserve">
    <value>Empty 'Else' block</value>
  </data>
  <data name="RemoveEmptyElseBlockQuickFix" xml:space="preserve">
    <value>Remove empty 'Else' block</value>
  </data>
  <data name="IntegerDataTypeInspectionMeta" xml:space="preserve">
    <value>The maximum value of a 16-bit signed integer is 32,767 - using a 32-bit (Long) integer data type where possible can help prevent 'Overflow' run-time errors, and is better handled by modern CPUs.</value>
  </data>
  <data name="IntegerDataTypeInspectionName" xml:space="preserve">
    <value>Use of 16-bit integer type</value>
  </data>
  <data name="IntegerDataTypeInspectionResultFormat" xml:space="preserve">
    <value>{0} '{1}' is declared as Integer</value>
  </data>
  <data name="IntegerDataTypeQuickFix" xml:space="preserve">
    <value>Change type to 'Long'</value>
  </data>
  <data name="RemoveStopKeywordQuickFix" xml:space="preserve">
    <value>Remove usage of the 'Stop' keyword</value>
  </data>
  <data name="StopKeywordInspectionMeta" xml:space="preserve">
    <value>The 'Stop' keyword halts execution and brings up the debugger. Avoid its use in distributed code.</value>
  </data>
  <data name="StopKeywordInspectionName" xml:space="preserve">
    <value>'Stop' keyword</value>
  </data>
  <data name="StopKeywordInspectionResultFormat" xml:space="preserve">
    <value>'Stop' keyword halts execution</value>
    <comment>{0} Property name</comment>
  </data>
  <data name="EmptyCaseBlockInspectionMeta" xml:space="preserve">
    <value>An empty 'Case' block without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn't need to be written.</value>
  </data>
  <data name="EmptyCaseBlockInspectionName" xml:space="preserve">
    <value>Empty 'Case' block</value>
  </data>
  <data name="EmptyCaseBlockInspectionResultFormat" xml:space="preserve">
    <value>'Case' block contains no executable statements</value>
  </data>
  <data name="EmptyDoWhileBlockInspectionResultFormat" xml:space="preserve">
    <value>'Do...While' loop contains no executable statements</value>
  </data>
  <data name="EmptyDoWhileBlockInspectionMeta" xml:space="preserve">
    <value>An empty 'Do...While' loop without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn't need to be written.</value>
  </data>
  <data name="EmptyDoWhileBlockInspectionName" xml:space="preserve">
    <value>Empty 'Do...While' Loop</value>
  </data>
  <data name="EmptyForEachBlockInspectionResultFormat" xml:space="preserve">
    <value>'For-Each loop contains no executable statements</value>
  </data>
  <data name="EmptyForEachBlockInspectionMeta" xml:space="preserve">
    <value>An empty 'For Each...Next' loop without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn't need to be written.</value>
  </data>
  <data name="EmptyForEachBlockInspectionName" xml:space="preserve">
    <value>Empty 'For Each...Next' Loop</value>
  </data>
  <data name="EmptyForLoopBlockInspectionResultFormat" xml:space="preserve">
    <value>'For...Next' loop contains no executable statements.</value>
  </data>
  <data name="EmptyForLoopBlockInspectionMeta" xml:space="preserve">
    <value>An empty 'For...Next' loop without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn't need to be written.</value>
  </data>
  <data name="EmptyForLoopBlockInspectionName" xml:space="preserve">
    <value>Empty 'For...Next' Loop</value>
  </data>
  <data name="EmptyWhileWendBlockInspectionResultFormat" xml:space="preserve">
    <value>'While...Wend' loop contains no executable statements.</value>
  </data>
  <data name="EmptyWhileWendBlockInspectionMeta" xml:space="preserve">
    <value>An empty 'Loop' block without any executable statements, leaves a maintainer wondering about the intent of the code. Avoid writing code that doesn't need to be written.</value>
  </data>
  <data name="EmptyWhileWendBlockInspectionName" xml:space="preserve">
    <value>Empty 'While...Wend' loop</value>
  </data>
  <data name="ShadowedDeclarationInspectionMeta" xml:space="preserve">
    <value>Two declarations are in scope and have the same identifier name. This means that only one of them will be available to use.</value>
  </data>
  <data name="ShadowedDeclarationInspectionName" xml:space="preserve">
    <value>Shadowed declaration</value>
  </data>
  <data name="ShadowedDeclarationInspectionResultFormat" xml:space="preserve">
    <value>{0} '{1}' hides {2} '{3}'</value>
  </data>
  <data name="ObsoleteErrorSyntaxInspectionMeta" xml:space="preserve">
    <value>The 'Error' statement only exists in the language to support legacy code that required it; prefer using 'Err.Raise' instead.</value>
  </data>
  <data name="ObsoleteErrorSyntaxInspectionResultFormat" xml:space="preserve">
    <value>A run-time error is raised using the obsolete 'Error' statement</value>
  </data>
  <data name="ReplaceObsoleteErrorStatementQuickFix" xml:space="preserve">
    <value>Replace 'Error' with 'Err.Raise'</value>
  </data>
  <data name="BooleanAssignedInIfElseInspectionMeta" xml:space="preserve">
    <value>A member is assigned True/False in different branches of an if statement with no other statements in the conditional. Use the condition directly to the member instead.</value>
  </data>
  <data name="BooleanAssignedInIfElseInspectionName" xml:space="preserve">
    <value>Boolean literal assignment in conditional</value>
  </data>
  <data name="BooleanAssignedInIfElseInspectionResultFormat" xml:space="preserve">
    <value>Boolean literal '{0}' assigned in conditional</value>
  </data>
  <data name="ReplaceIfElseWithConditionalStatementQuickFix" xml:space="preserve">
    <value>Replace If/Else with single assignment</value>
  </data>
  <data name="EmptyModuleInspectionName" xml:space="preserve">
    <value>Empty module</value>
  </data>
  <data name="EmptyModuleInspectionMeta" xml:space="preserve">
    <value>Empty modules and classes either point to not yet implemented functionality or represent unnecessary baggage that can hurt the maintainability of a project.</value>
  </data>
  <data name="EmptyModuleInspectionResultFormat" xml:space="preserve">
    <value>Module/class {0} is empty.</value>
  </data>
  <data name="ObsoleteErrorSyntaxInspectionName" xml:space="preserve">
    <value>Use of obsolete 'Error' statement</value>
  </data>
  <data name="UnhandledOnErrorResumeNextInspectionMeta" xml:space="preserve">
    <value>Error handling should be restored after using 'On Error Resume Next'.</value>
  </data>
  <data name="UnhandledOnErrorResumeNextInspectionName" xml:space="preserve">
    <value>Unhandled 'On Error Resume Next'</value>
  </data>
  <data name="UnhandledOnErrorResumeNextInspectionQuickFix" xml:space="preserve">
    <value>Introduce error handling subroutine</value>
  </data>
  <data name="UnhandledOnErrorResumeNextInspectionResultFormat" xml:space="preserve">
    <value>Errors are ignored but never handled again</value>
  </data>
</root>