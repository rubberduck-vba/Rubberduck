//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\Splinter\Documents\Visual Studio 2015\Projects\RubberduckParserTest\RubberduckParserTest\VBAExpressionParser.g4 by ANTLR 4.3

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

namespace Rubberduck.Parsing.Binding {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.3")]
[System.CLSCompliant(false)]
public partial class VBAExpressionParser : Parser {
	public const int
		PRINT=156, ELSEIF=88, CBYTE=5, CLOSE=65, STATIC=180, MINUS=212, OPTION_EXPLICIT=149, 
		L_SQUARE_BRACKET=223, DOEVENTS=21, HASHENDIF=222, DATELITERAL=230, ERROR=102, 
		NOTHING=141, EACH=86, SUB=184, STOP=182, LPAREN=210, MID=136, CVERR=19, 
		AS=55, END_PROPERTY=93, AT=45, DATABASE=67, GOSUB=115, CSNG=15, HASHCONST=218, 
		POW=216, DOLLAR=47, PROPERTY_LET=159, THEN=187, XOR=202, EXIT_FOR=105, 
		DEFINT=75, HASHIF=219, UNLOCK=192, CALL=62, LOCK_READ=131, SET=176, LOCK_READ_WRITE=133, 
		ABS=1, LSET=134, RAISEEVENT=165, MIDBTYPESUFFIX=32, SEEK=174, LONG=125, 
		CBOOL=4, LIB=128, DIM=83, APPEND=54, OPEN=146, DIV=204, PROPERTY_SET=160, 
		CDBL=8, PERCENT=46, END_SELECT=94, STRING=183, HASHELSEIF=220, SGN=37, 
		REM=169, TO=188, DEFDBL=73, BYVAL=59, FRIEND=110, LOOP=126, CLASS=64, 
		DO=84, VARIANT=194, END_WITH=97, DEFBOOL=70, OPTIONAL=147, ADDRESSOF=50, 
		CONST=66, RSET=173, INTEGER=123, CDEC=9, ATTRIBUTE=53, OUTPUT=153, FOR=111, 
		PTRSAFE=161, EQ=206, BOOLEAN=58, CIRCLE=11, END_FUNCTION=91, DEFSNG=80, 
		DEFBYTE=71, NOT=140, CINT=10, END=98, PRESERVE=155, ON_LOCAL_ERROR=145, 
		FLOATLITERAL=228, HASHELSE=221, BINARY=57, LENB=28, RETURN=172, EXCLAMATIONPOINT=42, 
		NEXT=138, GLOBAL=114, INPUTB=24, IDENTIFIER=236, WS=234, EMPTY=89, CURRENCY=17, 
		CCUR=6, MOD=137, WITHEVENTS=200, COLON=40, DEFLNGLNG=77, STEP=181, OPTION_BASE=148, 
		GT=208, PUT=163, WITH=199, CSTR=16, LOCK_WRITE=132, LINE_CONTINUATION=237, 
		TYPEOF=191, DEFVAR=82, DEFLNG=76, UBOUND=38, FALSE=109, ERRORCHAR=238, 
		UNDERSCORE=233, INTEGERLITERAL=229, END_IF=92, LOCK=124, TEXT=186, SINGLEQUOTE=232, 
		MULT=213, SEMICOLON=41, BYTE=61, HEXLITERAL=227, ELSE=87, IF=117, TYPE=190, 
		AMPERSAND=48, DEFLNGPTR=78, ENUM=99, DEFOBJ=79, IN=120, OPTION=34, DOT=43, 
		EXIT_DO=104, GUIDLITERAL=235, IS=122, EQV=100, WEND=196, FUNCTION=112, 
		HASH=44, CASE=63, GEQ=207, GET=113, PUBLIC=162, ON_ERROR=144, EXIT=22, 
		MIDB=31, END_ENUM=90, GOTO=116, INTDIV=205, LONGPTR=30, WIDTH=198, BEGIN=56, 
		EXIT_SUB=108, ASSIGN=203, WRITE=201, DOUBLE=85, EXIT_PROPERTY=107, COMMA=39, 
		RANDOM=164, PROPERTY_GET=158, SELECT=175, PRIVATE=157, ERASE=101, TAB=185, 
		BYREF=60, VERSION=195, NEQ=214, END_TYPE=96, NEW=139, ARRAY=3, INPUT=121, 
		SINGLE=178, ALIAS=51, SPC=179, LT=211, RESET=170, END_SUB=95, EVENT=103, 
		READ_WRITE=167, OPTION_COMPARE=150, ME=135, SCALE=36, CDATE=7, MIDTYPESUFFIX=33, 
		NULL=142, NEWLINE=231, TRUE=189, RPAREN=217, IMP=118, STRINGLITERAL=225, 
		OCTLITERAL=226, READ=166, DATE=68, LIKE=129, AND=52, OPTION_PRIVATE_MODULE=151, 
		CLNGLNG=13, PLUS=215, ANY=2, RESUME=171, INT=25, SHARED=177, EXIT_FUNCTION=106, 
		PSET=35, ACCESS=49, LINE_INPUT=130, ON=143, OR=152, PARAMARRAY=154, LBOUND=26, 
		R_SQUARE_BRACKET=224, IMPLEMENTS=119, UNTIL=193, DEBUG=20, DEFCUR=74, 
		CLNGPTR=14, LONGLONG=29, DECLARE=69, DEFDATE=72, FIX=23, LEN=27, REDIM=168, 
		LEQ=209, DEFSTR=81, LET=127, WHILE=197, CVAR=18, CLNG=12, FOREIGNNAME=239, 
		OBJECT=240, COLLECTION=241;
	public static readonly string[] tokenNames = {
		"<INVALID>", "ABS", "ANY", "ARRAY", "CBOOL", "CBYTE", "CCUR", "CDATE", 
		"CDBL", "CDEC", "CINT", "CIRCLE", "CLNG", "CLNGLNG", "CLNGPTR", "CSNG", 
		"CSTR", "CURRENCY", "CVAR", "CVERR", "DEBUG", "DOEVENTS", "EXIT", "FIX", 
		"INPUTB", "INT", "LBOUND", "LEN", "LENB", "LONGLONG", "LONGPTR", "MIDB", 
		"MIDBTYPESUFFIX", "MIDTYPESUFFIX", "OPTION", "PSET", "SCALE", "SGN", "UBOUND", 
		"','", "':'", "';'", "'!'", "'.'", "'#'", "'@'", "'%'", "'$'", "'&'", 
		"ACCESS", "ADDRESSOF", "ALIAS", "AND", "ATTRIBUTE", "APPEND", "AS", "BEGIN", 
		"BINARY", "BOOLEAN", "BYVAL", "BYREF", "BYTE", "CALL", "CASE", "CLASS", 
		"CLOSE", "CONST", "DATABASE", "DATE", "DECLARE", "DEFBOOL", "DEFBYTE", 
		"DEFDATE", "DEFDBL", "DEFCUR", "DEFINT", "DEFLNG", "DEFLNGLNG", "DEFLNGPTR", 
		"DEFOBJ", "DEFSNG", "DEFSTR", "DEFVAR", "DIM", "DO", "DOUBLE", "EACH", 
		"ELSE", "ELSEIF", "EMPTY", "END_ENUM", "END_FUNCTION", "END_IF", "END_PROPERTY", 
		"END_SELECT", "END_SUB", "END_TYPE", "END_WITH", "END", "ENUM", "EQV", 
		"ERASE", "ERROR", "EVENT", "EXIT_DO", "EXIT_FOR", "EXIT_FUNCTION", "EXIT_PROPERTY", 
		"EXIT_SUB", "FALSE", "FRIEND", "FOR", "FUNCTION", "GET", "GLOBAL", "GOSUB", 
		"GOTO", "IF", "IMP", "IMPLEMENTS", "IN", "INPUT", "IS", "INTEGER", "LOCK", 
		"LONG", "LOOP", "LET", "LIB", "LIKE", "LINE_INPUT", "LOCK_READ", "LOCK_WRITE", 
		"LOCK_READ_WRITE", "LSET", "ME", "MID", "MOD", "NEXT", "NEW", "NOT", "NOTHING", 
		"NULL", "ON", "ON_ERROR", "ON_LOCAL_ERROR", "OPEN", "OPTIONAL", "OPTION_BASE", 
		"OPTION_EXPLICIT", "OPTION_COMPARE", "OPTION_PRIVATE_MODULE", "OR", "OUTPUT", 
		"PARAMARRAY", "PRESERVE", "PRINT", "PRIVATE", "PROPERTY_GET", "PROPERTY_LET", 
		"PROPERTY_SET", "PTRSAFE", "PUBLIC", "PUT", "RANDOM", "RAISEEVENT", "READ", 
		"READ_WRITE", "REDIM", "REM", "RESET", "RESUME", "RETURN", "RSET", "SEEK", 
		"SELECT", "SET", "SHARED", "SINGLE", "SPC", "STATIC", "STEP", "STOP", 
		"STRING", "SUB", "TAB", "TEXT", "THEN", "TO", "TRUE", "TYPE", "TYPEOF", 
		"UNLOCK", "UNTIL", "VARIANT", "VERSION", "WEND", "WHILE", "WIDTH", "WITH", 
		"WITHEVENTS", "WRITE", "XOR", "':='", "'/'", "'\\'", "'='", "GEQ", "'>'", 
		"LEQ", "'('", "'<'", "'-'", "'*'", "NEQ", "'+'", "'^'", "')'", "HASHCONST", 
		"HASHIF", "HASHELSEIF", "HASHELSE", "HASHENDIF", "'['", "']'", "STRINGLITERAL", 
		"OCTLITERAL", "HEXLITERAL", "FLOATLITERAL", "INTEGERLITERAL", "DATELITERAL", 
		"NEWLINE", "'''", "'_'", "WS", "GUIDLITERAL", "IDENTIFIER", "LINE_CONTINUATION", 
		"ERRORCHAR", "FOREIGNNAME", "OBJECT", "COLLECTION"
	};
	public const int
		RULE_startRule = 0, RULE_callStmt = 1, RULE_unrestrictedName = 2, RULE_name = 3, 
		RULE_reservedIdentifierName = 4, RULE_reservedUntypedName = 5, RULE_reservedTypedName = 6, 
		RULE_untypedName = 7, RULE_typedName = 8, RULE_typedNameValue = 9, RULE_typeSuffix = 10, 
		RULE_optionCompareArgument = 11, RULE_builtInType = 12, RULE_expression = 13, 
		RULE_literalExpression = 14, RULE_numberLiteral = 15, RULE_parenthesizedExpression = 16, 
		RULE_typeOfIsExpression = 17, RULE_newExpression = 18, RULE_lExpression = 19, 
		RULE_memberAccessExpression = 20, RULE_indexExpression = 21, RULE_dictionaryAccessExpression = 22, 
		RULE_argumentList = 23, RULE_positionalOrNamedArgumentList = 24, RULE_positionalArgument = 25, 
		RULE_requiredPositionalArgument = 26, RULE_namedArgumentList = 27, RULE_namedArgument = 28, 
		RULE_argumentExpression = 29, RULE_simpleNameExpression = 30, RULE_instanceExpression = 31, 
		RULE_withExpression = 32, RULE_withMemberAccessExpression = 33, RULE_withDictionaryAccessExpression = 34, 
		RULE_constantExpression = 35, RULE_typeExpression = 36, RULE_definedTypeExpression = 37, 
		RULE_addressOfExpression = 38, RULE_procedurePointerExpression = 39, RULE_reservedIdentifier = 40, 
		RULE_statementKeyword = 41, RULE_remKeyword = 42, RULE_markerKeyword = 43, 
		RULE_operatorIdentifier = 44, RULE_reservedName = 45, RULE_reservedProcedureName = 46, 
		RULE_specialForm = 47, RULE_reservedTypeIdentifier = 48, RULE_uncategorizedKeyword = 49, 
		RULE_literalIdentifier = 50, RULE_booleanLiteralIdentifier = 51, RULE_objectLiteralIdentifier = 52, 
		RULE_variantLiteralIdentifier = 53, RULE_whiteSpace = 54;
	public static readonly string[] ruleNames = {
		"startRule", "callStmt", "unrestrictedName", "name", "reservedIdentifierName", 
		"reservedUntypedName", "reservedTypedName", "untypedName", "typedName", 
		"typedNameValue", "typeSuffix", "optionCompareArgument", "builtInType", 
		"expression", "literalExpression", "numberLiteral", "parenthesizedExpression", 
		"typeOfIsExpression", "newExpression", "lExpression", "memberAccessExpression", 
		"indexExpression", "dictionaryAccessExpression", "argumentList", "positionalOrNamedArgumentList", 
		"positionalArgument", "requiredPositionalArgument", "namedArgumentList", 
		"namedArgument", "argumentExpression", "simpleNameExpression", "instanceExpression", 
		"withExpression", "withMemberAccessExpression", "withDictionaryAccessExpression", 
		"constantExpression", "typeExpression", "definedTypeExpression", "addressOfExpression", 
		"procedurePointerExpression", "reservedIdentifier", "statementKeyword", 
		"remKeyword", "markerKeyword", "operatorIdentifier", "reservedName", "reservedProcedureName", 
		"specialForm", "reservedTypeIdentifier", "uncategorizedKeyword", "literalIdentifier", 
		"booleanLiteralIdentifier", "objectLiteralIdentifier", "variantLiteralIdentifier", 
		"whiteSpace"
	};

	public override string GrammarFileName { get { return "VBAExpressionParser.g4"; } }

	public override string[] TokenNames { get { return tokenNames; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public VBAExpressionParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class StartRuleContext : ParserRuleContext {
		public CallStmtContext callStmt() {
			return GetRuleContext<CallStmtContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(VBAExpressionParser.Eof, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public StartRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_startRule; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterStartRule(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitStartRule(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStartRule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StartRuleContext startRule() {
		StartRuleContext _localctx = new StartRuleContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_startRule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 112;
			switch ( Interpreter.AdaptivePredict(_input,0,_ctx) ) {
			case 1:
				{
				State = 110; expression(0);
				}
				break;

			case 2:
				{
				State = 111; callStmt();
				}
				break;
			}
			State = 114; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CallStmtContext : ParserRuleContext {
		public MemberAccessExpressionContext memberAccessExpression() {
			return GetRuleContext<MemberAccessExpressionContext>(0);
		}
		public WithExpressionContext withExpression() {
			return GetRuleContext<WithExpressionContext>(0);
		}
		public SimpleNameExpressionContext simpleNameExpression() {
			return GetRuleContext<SimpleNameExpressionContext>(0);
		}
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		public CallStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_callStmt; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterCallStmt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitCallStmt(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCallStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CallStmtContext callStmt() {
		CallStmtContext _localctx = new CallStmtContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_callStmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 119;
			switch ( Interpreter.AdaptivePredict(_input,1,_ctx) ) {
			case 1:
				{
				State = 116; memberAccessExpression();
				}
				break;

			case 2:
				{
				State = 117; simpleNameExpression();
				}
				break;

			case 3:
				{
				State = 118; withExpression();
				}
				break;
			}
			State = 124;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 121; whiteSpace();
				State = 122; argumentList();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnrestrictedNameContext : ParserRuleContext {
		public ReservedIdentifierNameContext reservedIdentifierName() {
			return GetRuleContext<ReservedIdentifierNameContext>(0);
		}
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public UnrestrictedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unrestrictedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterUnrestrictedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitUnrestrictedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnrestrictedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnrestrictedNameContext unrestrictedName() {
		UnrestrictedNameContext _localctx = new UnrestrictedNameContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_unrestrictedName);
		try {
			State = 128;
			switch ( Interpreter.AdaptivePredict(_input,3,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 126; name();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 127; reservedIdentifierName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NameContext : ParserRuleContext {
		public TypedNameContext typedName() {
			return GetRuleContext<TypedNameContext>(0);
		}
		public UntypedNameContext untypedName() {
			return GetRuleContext<UntypedNameContext>(0);
		}
		public NameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NameContext name() {
		NameContext _localctx = new NameContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_name);
		try {
			State = 132;
			switch ( Interpreter.AdaptivePredict(_input,4,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 130; untypedName();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 131; typedName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedIdentifierNameContext : ParserRuleContext {
		public ReservedTypedNameContext reservedTypedName() {
			return GetRuleContext<ReservedTypedNameContext>(0);
		}
		public ReservedUntypedNameContext reservedUntypedName() {
			return GetRuleContext<ReservedUntypedNameContext>(0);
		}
		public ReservedIdentifierNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedIdentifierName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedIdentifierName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedIdentifierName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedIdentifierName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedIdentifierNameContext reservedIdentifierName() {
		ReservedIdentifierNameContext _localctx = new ReservedIdentifierNameContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_reservedIdentifierName);
		try {
			State = 136;
			switch ( Interpreter.AdaptivePredict(_input,5,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 134; reservedUntypedName();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 135; reservedTypedName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedUntypedNameContext : ParserRuleContext {
		public ReservedIdentifierContext reservedIdentifier() {
			return GetRuleContext<ReservedIdentifierContext>(0);
		}
		public ReservedUntypedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedUntypedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedUntypedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedUntypedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedUntypedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedUntypedNameContext reservedUntypedName() {
		ReservedUntypedNameContext _localctx = new ReservedUntypedNameContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_reservedUntypedName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 138; reservedIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedTypedNameContext : ParserRuleContext {
		public TypeSuffixContext typeSuffix() {
			return GetRuleContext<TypeSuffixContext>(0);
		}
		public ReservedIdentifierContext reservedIdentifier() {
			return GetRuleContext<ReservedIdentifierContext>(0);
		}
		public ReservedTypedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedTypedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedTypedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedTypedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedTypedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedTypedNameContext reservedTypedName() {
		ReservedTypedNameContext _localctx = new ReservedTypedNameContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_reservedTypedName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 140; reservedIdentifier();
			State = 141; typeSuffix();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UntypedNameContext : ParserRuleContext {
		public UncategorizedKeywordContext uncategorizedKeyword() {
			return GetRuleContext<UncategorizedKeywordContext>(0);
		}
		public ITerminalNode FOREIGNNAME() { return GetToken(VBAExpressionParser.FOREIGNNAME, 0); }
		public SpecialFormContext specialForm() {
			return GetRuleContext<SpecialFormContext>(0);
		}
		public ITerminalNode OBJECT() { return GetToken(VBAExpressionParser.OBJECT, 0); }
		public ITerminalNode ERROR() { return GetToken(VBAExpressionParser.ERROR, 0); }
		public OptionCompareArgumentContext optionCompareArgument() {
			return GetRuleContext<OptionCompareArgumentContext>(0);
		}
		public ReservedTypeIdentifierContext reservedTypeIdentifier() {
			return GetRuleContext<ReservedTypeIdentifierContext>(0);
		}
		public ITerminalNode IDENTIFIER() { return GetToken(VBAExpressionParser.IDENTIFIER, 0); }
		public ReservedProcedureNameContext reservedProcedureName() {
			return GetRuleContext<ReservedProcedureNameContext>(0);
		}
		public UntypedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_untypedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterUntypedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitUntypedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUntypedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UntypedNameContext untypedName() {
		UntypedNameContext _localctx = new UntypedNameContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_untypedName);
		try {
			State = 152;
			switch ( Interpreter.AdaptivePredict(_input,6,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 143; Match(IDENTIFIER);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 144; Match(FOREIGNNAME);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 145; reservedProcedureName();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 146; specialForm();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 147; optionCompareArgument();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 148; Match(OBJECT);
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 149; uncategorizedKeyword();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 150; Match(ERROR);
				}
				break;

			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 151; reservedTypeIdentifier();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypedNameContext : ParserRuleContext {
		public TypeSuffixContext typeSuffix() {
			return GetRuleContext<TypeSuffixContext>(0);
		}
		public TypedNameValueContext typedNameValue() {
			return GetRuleContext<TypedNameValueContext>(0);
		}
		public TypedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypedNameContext typedName() {
		TypedNameContext _localctx = new TypedNameContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_typedName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 154; typedNameValue();
			State = 155; typeSuffix();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypedNameValueContext : ParserRuleContext {
		public UncategorizedKeywordContext uncategorizedKeyword() {
			return GetRuleContext<UncategorizedKeywordContext>(0);
		}
		public SpecialFormContext specialForm() {
			return GetRuleContext<SpecialFormContext>(0);
		}
		public ITerminalNode OBJECT() { return GetToken(VBAExpressionParser.OBJECT, 0); }
		public ITerminalNode ERROR() { return GetToken(VBAExpressionParser.ERROR, 0); }
		public OptionCompareArgumentContext optionCompareArgument() {
			return GetRuleContext<OptionCompareArgumentContext>(0);
		}
		public ReservedTypeIdentifierContext reservedTypeIdentifier() {
			return GetRuleContext<ReservedTypeIdentifierContext>(0);
		}
		public ITerminalNode IDENTIFIER() { return GetToken(VBAExpressionParser.IDENTIFIER, 0); }
		public ReservedProcedureNameContext reservedProcedureName() {
			return GetRuleContext<ReservedProcedureNameContext>(0);
		}
		public TypedNameValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typedNameValue; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypedNameValue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypedNameValue(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypedNameValue(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypedNameValueContext typedNameValue() {
		TypedNameValueContext _localctx = new TypedNameValueContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_typedNameValue);
		try {
			State = 165;
			switch ( Interpreter.AdaptivePredict(_input,7,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 157; Match(IDENTIFIER);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 158; reservedProcedureName();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 159; specialForm();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 160; optionCompareArgument();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 161; Match(OBJECT);
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 162; uncategorizedKeyword();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 163; Match(ERROR);
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 164; reservedTypeIdentifier();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeSuffixContext : ParserRuleContext {
		public ITerminalNode AT() { return GetToken(VBAExpressionParser.AT, 0); }
		public ITerminalNode DOLLAR() { return GetToken(VBAExpressionParser.DOLLAR, 0); }
		public ITerminalNode EXCLAMATIONPOINT() { return GetToken(VBAExpressionParser.EXCLAMATIONPOINT, 0); }
		public ITerminalNode AMPERSAND() { return GetToken(VBAExpressionParser.AMPERSAND, 0); }
		public ITerminalNode PERCENT() { return GetToken(VBAExpressionParser.PERCENT, 0); }
		public ITerminalNode POW() { return GetToken(VBAExpressionParser.POW, 0); }
		public ITerminalNode HASH() { return GetToken(VBAExpressionParser.HASH, 0); }
		public TypeSuffixContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeSuffix; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypeSuffix(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypeSuffix(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeSuffix(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeSuffixContext typeSuffix() {
		TypeSuffixContext _localctx = new TypeSuffixContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_typeSuffix);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 167;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << EXCLAMATIONPOINT) | (1L << HASH) | (1L << AT) | (1L << PERCENT) | (1L << DOLLAR) | (1L << AMPERSAND))) != 0) || _la==POW) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OptionCompareArgumentContext : ParserRuleContext {
		public ITerminalNode TEXT() { return GetToken(VBAExpressionParser.TEXT, 0); }
		public ITerminalNode DATABASE() { return GetToken(VBAExpressionParser.DATABASE, 0); }
		public ITerminalNode BINARY() { return GetToken(VBAExpressionParser.BINARY, 0); }
		public OptionCompareArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_optionCompareArgument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterOptionCompareArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitOptionCompareArgument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOptionCompareArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OptionCompareArgumentContext optionCompareArgument() {
		OptionCompareArgumentContext _localctx = new OptionCompareArgumentContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_optionCompareArgument);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 169;
			_la = _input.La(1);
			if ( !(_la==BINARY || _la==DATABASE || _la==TEXT) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BuiltInTypeContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode OBJECT() { return GetToken(VBAExpressionParser.OBJECT, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ReservedTypeIdentifierContext reservedTypeIdentifier() {
			return GetRuleContext<ReservedTypeIdentifierContext>(0);
		}
		public ITerminalNode L_SQUARE_BRACKET() { return GetToken(VBAExpressionParser.L_SQUARE_BRACKET, 0); }
		public ITerminalNode R_SQUARE_BRACKET() { return GetToken(VBAExpressionParser.R_SQUARE_BRACKET, 0); }
		public BuiltInTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_builtInType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterBuiltInType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitBuiltInType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltInType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BuiltInTypeContext builtInType() {
		BuiltInTypeContext _localctx = new BuiltInTypeContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_builtInType);
		int _la;
		try {
			State = 192;
			switch ( Interpreter.AdaptivePredict(_input,12,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 171; reservedTypeIdentifier();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 172; Match(L_SQUARE_BRACKET);
				State = 174;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 173; whiteSpace();
					}
				}

				State = 176; reservedTypeIdentifier();
				State = 178;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 177; whiteSpace();
					}
				}

				State = 180; Match(R_SQUARE_BRACKET);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 182; Match(OBJECT);
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 183; Match(L_SQUARE_BRACKET);
				State = 185;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 184; whiteSpace();
					}
				}

				State = 187; Match(OBJECT);
				State = 189;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 188; whiteSpace();
					}
				}

				State = 191; Match(R_SQUARE_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
	 
		public ExpressionContext() { }
		public virtual void CopyFrom(ExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class UnaryMinusOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public ITerminalNode MINUS() { return GetToken(VBAExpressionParser.MINUS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public UnaryMinusOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterUnaryMinusOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitUnaryMinusOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryMinusOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NewExprContext : ExpressionContext {
		public NewExpressionContext newExpression() {
			return GetRuleContext<NewExpressionContext>(0);
		}
		public NewExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterNewExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitNewExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNewExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PowOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode POW() { return GetToken(VBAExpressionParser.POW, 0); }
		public PowOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterPowOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitPowOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPowOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AddOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode PLUS() { return GetToken(VBAExpressionParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(VBAExpressionParser.MINUS, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public AddOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterAddOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitAddOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAddOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TypeOfIsExprContext : ExpressionContext {
		public TypeOfIsExpressionContext typeOfIsExpression() {
			return GetRuleContext<TypeOfIsExpressionContext>(0);
		}
		public TypeOfIsExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypeOfIsExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypeOfIsExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeOfIsExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class IntDivOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode INTDIV() { return GetToken(VBAExpressionParser.INTDIV, 0); }
		public IntDivOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterIntDivOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitIntDivOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIntDivOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalImpOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode IMP() { return GetToken(VBAExpressionParser.IMP, 0); }
		public LogicalImpOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalImpOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalImpOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalImpOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ConcatOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode AMPERSAND() { return GetToken(VBAExpressionParser.AMPERSAND, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ConcatOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterConcatOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitConcatOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConcatOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ModOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode MOD() { return GetToken(VBAExpressionParser.MOD, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ModOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterModOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitModOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LExprContext : ExpressionContext {
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public LExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MultOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode MULT() { return GetToken(VBAExpressionParser.MULT, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode DIV() { return GetToken(VBAExpressionParser.DIV, 0); }
		public MultOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterMultOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitMultOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalXorOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode XOR() { return GetToken(VBAExpressionParser.XOR, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public LogicalXorOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalXorOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalXorOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalXorOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalAndOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode AND() { return GetToken(VBAExpressionParser.AND, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public LogicalAndOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalAndOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalAndOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalAndOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalOrOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode OR() { return GetToken(VBAExpressionParser.OR, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public LogicalOrOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalOrOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalOrOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalOrOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RelationalOpContext : ExpressionContext {
		public ITerminalNode GEQ() { return GetToken(VBAExpressionParser.GEQ, 0); }
		public ITerminalNode NEQ() { return GetToken(VBAExpressionParser.NEQ, 0); }
		public ITerminalNode IS() { return GetToken(VBAExpressionParser.IS, 0); }
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode LEQ() { return GetToken(VBAExpressionParser.LEQ, 0); }
		public ITerminalNode LT() { return GetToken(VBAExpressionParser.LT, 0); }
		public ITerminalNode GT() { return GetToken(VBAExpressionParser.GT, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode EQ() { return GetToken(VBAExpressionParser.EQ, 0); }
		public ITerminalNode LIKE() { return GetToken(VBAExpressionParser.LIKE, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public RelationalOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterRelationalOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitRelationalOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelationalOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalEqvOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode EQV() { return GetToken(VBAExpressionParser.EQV, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public LogicalEqvOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalEqvOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalEqvOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalEqvOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ParenthesizedExprContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode LPAREN() { return GetToken(VBAExpressionParser.LPAREN, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode RPAREN() { return GetToken(VBAExpressionParser.RPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ParenthesizedExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterParenthesizedExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitParenthesizedExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthesizedExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LiteralExprContext : ExpressionContext {
		public LiteralExpressionContext literalExpression() {
			return GetRuleContext<LiteralExpressionContext>(0);
		}
		public LiteralExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLiteralExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLiteralExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalNotOpContext : ExpressionContext {
		public ITerminalNode NOT() { return GetToken(VBAExpressionParser.NOT, 0); }
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public LogicalNotOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalNotOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalNotOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalNotOp(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(_ctx, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 26;
		EnterRecursionRule(_localctx, 26, RULE_expression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 219;
			switch (_input.La(1)) {
			case MINUS:
				{
				_localctx = new UnaryMinusOpContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;

				State = 195; Match(MINUS);
				State = 197;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 196; whiteSpace();
					}
				}

				State = 199; expression(14);
				}
				break;
			case NOT:
				{
				_localctx = new LogicalNotOpContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 200; Match(NOT);
				State = 202;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 201; whiteSpace();
					}
				}

				State = 204; expression(7);
				}
				break;
			case ABS:
			case ANY:
			case ARRAY:
			case CBOOL:
			case CBYTE:
			case CCUR:
			case CDATE:
			case CDBL:
			case CDEC:
			case CINT:
			case CIRCLE:
			case CLNG:
			case CLNGLNG:
			case CLNGPTR:
			case CSNG:
			case CSTR:
			case CURRENCY:
			case CVAR:
			case CVERR:
			case DEBUG:
			case DOEVENTS:
			case FIX:
			case INPUTB:
			case INT:
			case LBOUND:
			case LEN:
			case LENB:
			case LONGLONG:
			case LONGPTR:
			case MIDB:
			case MIDBTYPESUFFIX:
			case MIDTYPESUFFIX:
			case PSET:
			case SCALE:
			case SGN:
			case UBOUND:
			case EXCLAMATIONPOINT:
			case DOT:
			case ACCESS:
			case ALIAS:
			case ATTRIBUTE:
			case APPEND:
			case BEGIN:
			case BINARY:
			case BOOLEAN:
			case BYTE:
			case CLASS:
			case DATABASE:
			case DATE:
			case DOUBLE:
			case END_SELECT:
			case END_WITH:
			case END:
			case ERROR:
			case EXIT_DO:
			case EXIT_FOR:
			case EXIT_FUNCTION:
			case EXIT_PROPERTY:
			case EXIT_SUB:
			case INPUT:
			case INTEGER:
			case LONG:
			case LIB:
			case LINE_INPUT:
			case LOCK_READ:
			case LOCK_WRITE:
			case LOCK_READ_WRITE:
			case ME:
			case MID:
			case ON:
			case ON_ERROR:
			case OUTPUT:
			case RANDOM:
			case READ:
			case READ_WRITE:
			case RESET:
			case SHARED:
			case SINGLE:
			case STEP:
			case STRING:
			case TAB:
			case TEXT:
			case VARIANT:
			case VERSION:
			case WIDTH:
			case WRITE:
			case IDENTIFIER:
			case FOREIGNNAME:
			case OBJECT:
			case COLLECTION:
				{
				_localctx = new LExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 205; lExpression(0);
				}
				break;
			case LPAREN:
				{
				_localctx = new ParenthesizedExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 206; Match(LPAREN);
				State = 208;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 207; whiteSpace();
					}
				}

				State = 210; expression(0);
				State = 212;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 211; whiteSpace();
					}
				}

				State = 214; Match(RPAREN);
				}
				break;
			case TYPEOF:
				{
				_localctx = new TypeOfIsExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 216; typeOfIsExpression();
				}
				break;
			case NEW:
				{
				_localctx = new NewExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 217; newExpression();
				}
				break;
			case EMPTY:
			case FALSE:
			case NOTHING:
			case NULL:
			case TRUE:
			case STRINGLITERAL:
			case OCTLITERAL:
			case HEXLITERAL:
			case FLOATLITERAL:
			case INTEGERLITERAL:
			case DATELITERAL:
				{
				_localctx = new LiteralExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 218; literalExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			_ctx.stop = _input.Lt(-1);
			State = 331;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,43,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 329;
					switch ( Interpreter.AdaptivePredict(_input,42,_ctx) ) {
					case 1:
						{
						_localctx = new PowOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 221;
						if (!(Precpred(_ctx, 15))) throw new FailedPredicateException(this, "Precpred(_ctx, 15)");
						State = 223;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 222; whiteSpace();
							}
						}

						State = 225; Match(POW);
						State = 227;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 226; whiteSpace();
							}
						}

						State = 229; expression(16);
						}
						break;

					case 2:
						{
						_localctx = new MultOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 230;
						if (!(Precpred(_ctx, 13))) throw new FailedPredicateException(this, "Precpred(_ctx, 13)");
						State = 232;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 231; whiteSpace();
							}
						}

						State = 234;
						_la = _input.La(1);
						if ( !(_la==DIV || _la==MULT) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 236;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 235; whiteSpace();
							}
						}

						State = 238; expression(14);
						}
						break;

					case 3:
						{
						_localctx = new IntDivOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 239;
						if (!(Precpred(_ctx, 12))) throw new FailedPredicateException(this, "Precpred(_ctx, 12)");
						State = 241;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 240; whiteSpace();
							}
						}

						State = 243; Match(INTDIV);
						State = 245;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 244; whiteSpace();
							}
						}

						State = 247; expression(13);
						}
						break;

					case 4:
						{
						_localctx = new ModOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 248;
						if (!(Precpred(_ctx, 11))) throw new FailedPredicateException(this, "Precpred(_ctx, 11)");
						State = 250;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 249; whiteSpace();
							}
						}

						State = 252; Match(MOD);
						State = 254;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 253; whiteSpace();
							}
						}

						State = 256; expression(12);
						}
						break;

					case 5:
						{
						_localctx = new AddOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 257;
						if (!(Precpred(_ctx, 10))) throw new FailedPredicateException(this, "Precpred(_ctx, 10)");
						State = 259;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 258; whiteSpace();
							}
						}

						State = 261;
						_la = _input.La(1);
						if ( !(_la==MINUS || _la==PLUS) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 263;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 262; whiteSpace();
							}
						}

						State = 265; expression(11);
						}
						break;

					case 6:
						{
						_localctx = new ConcatOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 266;
						if (!(Precpred(_ctx, 9))) throw new FailedPredicateException(this, "Precpred(_ctx, 9)");
						State = 268;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 267; whiteSpace();
							}
						}

						State = 270; Match(AMPERSAND);
						State = 272;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 271; whiteSpace();
							}
						}

						State = 274; expression(10);
						}
						break;

					case 7:
						{
						_localctx = new RelationalOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 275;
						if (!(Precpred(_ctx, 8))) throw new FailedPredicateException(this, "Precpred(_ctx, 8)");
						State = 277;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 276; whiteSpace();
							}
						}

						State = 279;
						_la = _input.La(1);
						if ( !(_la==IS || _la==LIKE || ((((_la - 206)) & ~0x3f) == 0 && ((1L << (_la - 206)) & ((1L << (EQ - 206)) | (1L << (GEQ - 206)) | (1L << (GT - 206)) | (1L << (LEQ - 206)) | (1L << (LT - 206)) | (1L << (NEQ - 206)))) != 0)) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 281;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 280; whiteSpace();
							}
						}

						State = 283; expression(9);
						}
						break;

					case 8:
						{
						_localctx = new LogicalAndOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 284;
						if (!(Precpred(_ctx, 6))) throw new FailedPredicateException(this, "Precpred(_ctx, 6)");
						State = 286;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 285; whiteSpace();
							}
						}

						State = 288; Match(AND);
						State = 290;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 289; whiteSpace();
							}
						}

						State = 292; expression(7);
						}
						break;

					case 9:
						{
						_localctx = new LogicalOrOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 293;
						if (!(Precpred(_ctx, 5))) throw new FailedPredicateException(this, "Precpred(_ctx, 5)");
						State = 295;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 294; whiteSpace();
							}
						}

						State = 297; Match(OR);
						State = 299;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 298; whiteSpace();
							}
						}

						State = 301; expression(6);
						}
						break;

					case 10:
						{
						_localctx = new LogicalXorOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 302;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 304;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 303; whiteSpace();
							}
						}

						State = 306; Match(XOR);
						State = 308;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 307; whiteSpace();
							}
						}

						State = 310; expression(5);
						}
						break;

					case 11:
						{
						_localctx = new LogicalEqvOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 311;
						if (!(Precpred(_ctx, 3))) throw new FailedPredicateException(this, "Precpred(_ctx, 3)");
						State = 313;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 312; whiteSpace();
							}
						}

						State = 315; Match(EQV);
						State = 317;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 316; whiteSpace();
							}
						}

						State = 319; expression(4);
						}
						break;

					case 12:
						{
						_localctx = new LogicalImpOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 320;
						if (!(Precpred(_ctx, 2))) throw new FailedPredicateException(this, "Precpred(_ctx, 2)");
						State = 322;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 321; whiteSpace();
							}
						}

						State = 324; Match(IMP);
						State = 326;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 325; whiteSpace();
							}
						}

						State = 328; expression(3);
						}
						break;
					}
					} 
				}
				State = 333;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,43,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class LiteralExpressionContext : ParserRuleContext {
		public ITerminalNode STRINGLITERAL() { return GetToken(VBAExpressionParser.STRINGLITERAL, 0); }
		public TypeSuffixContext typeSuffix() {
			return GetRuleContext<TypeSuffixContext>(0);
		}
		public ITerminalNode DATELITERAL() { return GetToken(VBAExpressionParser.DATELITERAL, 0); }
		public NumberLiteralContext numberLiteral() {
			return GetRuleContext<NumberLiteralContext>(0);
		}
		public LiteralIdentifierContext literalIdentifier() {
			return GetRuleContext<LiteralIdentifierContext>(0);
		}
		public LiteralExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literalExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLiteralExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLiteralExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralExpressionContext literalExpression() {
		LiteralExpressionContext _localctx = new LiteralExpressionContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_literalExpression);
		try {
			State = 341;
			switch (_input.La(1)) {
			case OCTLITERAL:
			case HEXLITERAL:
			case FLOATLITERAL:
			case INTEGERLITERAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 334; numberLiteral();
				}
				break;
			case DATELITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 335; Match(DATELITERAL);
				}
				break;
			case STRINGLITERAL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 336; Match(STRINGLITERAL);
				}
				break;
			case EMPTY:
			case FALSE:
			case NOTHING:
			case NULL:
			case TRUE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 337; literalIdentifier();
				State = 339;
				switch ( Interpreter.AdaptivePredict(_input,44,_ctx) ) {
				case 1:
					{
					State = 338; typeSuffix();
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumberLiteralContext : ParserRuleContext {
		public ITerminalNode INTEGERLITERAL() { return GetToken(VBAExpressionParser.INTEGERLITERAL, 0); }
		public ITerminalNode FLOATLITERAL() { return GetToken(VBAExpressionParser.FLOATLITERAL, 0); }
		public ITerminalNode HEXLITERAL() { return GetToken(VBAExpressionParser.HEXLITERAL, 0); }
		public ITerminalNode OCTLITERAL() { return GetToken(VBAExpressionParser.OCTLITERAL, 0); }
		public NumberLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numberLiteral; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterNumberLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitNumberLiteral(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumberLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumberLiteralContext numberLiteral() {
		NumberLiteralContext _localctx = new NumberLiteralContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_numberLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 343;
			_la = _input.La(1);
			if ( !(((((_la - 226)) & ~0x3f) == 0 && ((1L << (_la - 226)) & ((1L << (OCTLITERAL - 226)) | (1L << (HEXLITERAL - 226)) | (1L << (FLOATLITERAL - 226)) | (1L << (INTEGERLITERAL - 226)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParenthesizedExpressionContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode LPAREN() { return GetToken(VBAExpressionParser.LPAREN, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode RPAREN() { return GetToken(VBAExpressionParser.RPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ParenthesizedExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parenthesizedExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterParenthesizedExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitParenthesizedExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthesizedExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParenthesizedExpressionContext parenthesizedExpression() {
		ParenthesizedExpressionContext _localctx = new ParenthesizedExpressionContext(_ctx, State);
		EnterRule(_localctx, 32, RULE_parenthesizedExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 345; Match(LPAREN);
			State = 347;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 346; whiteSpace();
				}
			}

			State = 349; expression(0);
			State = 351;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 350; whiteSpace();
				}
			}

			State = 353; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeOfIsExpressionContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode IS() { return GetToken(VBAExpressionParser.IS, 0); }
		public ITerminalNode TYPEOF() { return GetToken(VBAExpressionParser.TYPEOF, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public TypeExpressionContext typeExpression() {
			return GetRuleContext<TypeExpressionContext>(0);
		}
		public TypeOfIsExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeOfIsExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypeOfIsExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypeOfIsExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeOfIsExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeOfIsExpressionContext typeOfIsExpression() {
		TypeOfIsExpressionContext _localctx = new TypeOfIsExpressionContext(_ctx, State);
		EnterRule(_localctx, 34, RULE_typeOfIsExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 355; Match(TYPEOF);
			State = 356; whiteSpace();
			State = 357; expression(0);
			State = 358; whiteSpace();
			State = 359; Match(IS);
			State = 360; whiteSpace();
			State = 361; typeExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NewExpressionContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public ITerminalNode NEW() { return GetToken(VBAExpressionParser.NEW, 0); }
		public TypeExpressionContext typeExpression() {
			return GetRuleContext<TypeExpressionContext>(0);
		}
		public NewExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_newExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterNewExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitNewExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNewExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NewExpressionContext newExpression() {
		NewExpressionContext _localctx = new NewExpressionContext(_ctx, State);
		EnterRule(_localctx, 36, RULE_newExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 363; Match(NEW);
			State = 364; whiteSpace();
			State = 365; typeExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LExpressionContext : ParserRuleContext {
		public LExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lExpression; } }
	 
		public LExpressionContext() { }
		public virtual void CopyFrom(LExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class IndexExprContext : LExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode LPAREN() { return GetToken(VBAExpressionParser.LPAREN, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode RPAREN() { return GetToken(VBAExpressionParser.RPAREN, 0); }
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		public IndexExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterIndexExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitIndexExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SimpleNameExprContext : LExpressionContext {
		public SimpleNameExpressionContext simpleNameExpression() {
			return GetRuleContext<SimpleNameExpressionContext>(0);
		}
		public SimpleNameExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterSimpleNameExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitSimpleNameExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleNameExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MemberAccessExprContext : LExpressionContext {
		public ITerminalNode DOT() { return GetToken(VBAExpressionParser.DOT, 0); }
		public ITerminalNode LINE_CONTINUATION() { return GetToken(VBAExpressionParser.LINE_CONTINUATION, 0); }
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public MemberAccessExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterMemberAccessExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitMemberAccessExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemberAccessExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class InstanceExprContext : LExpressionContext {
		public InstanceExpressionContext instanceExpression() {
			return GetRuleContext<InstanceExpressionContext>(0);
		}
		public InstanceExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterInstanceExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitInstanceExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInstanceExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class WithExprContext : LExpressionContext {
		public WithExpressionContext withExpression() {
			return GetRuleContext<WithExpressionContext>(0);
		}
		public WithExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterWithExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitWithExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DictionaryAccessExprContext : LExpressionContext {
		public IReadOnlyList<ITerminalNode> LINE_CONTINUATION() { return GetTokens(VBAExpressionParser.LINE_CONTINUATION); }
		public ITerminalNode EXCLAMATIONPOINT() { return GetToken(VBAExpressionParser.EXCLAMATIONPOINT, 0); }
		public ITerminalNode LINE_CONTINUATION(int i) {
			return GetToken(VBAExpressionParser.LINE_CONTINUATION, i);
		}
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public DictionaryAccessExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterDictionaryAccessExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitDictionaryAccessExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDictionaryAccessExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LExpressionContext lExpression() {
		return lExpression(0);
	}

	private LExpressionContext lExpression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		LExpressionContext _localctx = new LExpressionContext(_ctx, _parentState);
		LExpressionContext _prevctx = _localctx;
		int _startState = 38;
		EnterRecursionRule(_localctx, 38, RULE_lExpression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 371;
			switch (_input.La(1)) {
			case ME:
				{
				_localctx = new InstanceExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;

				State = 368; instanceExpression();
				}
				break;
			case ABS:
			case ANY:
			case ARRAY:
			case CBOOL:
			case CBYTE:
			case CCUR:
			case CDATE:
			case CDBL:
			case CDEC:
			case CINT:
			case CIRCLE:
			case CLNG:
			case CLNGLNG:
			case CLNGPTR:
			case CSNG:
			case CSTR:
			case CURRENCY:
			case CVAR:
			case CVERR:
			case DEBUG:
			case DOEVENTS:
			case FIX:
			case INPUTB:
			case INT:
			case LBOUND:
			case LEN:
			case LENB:
			case LONGLONG:
			case LONGPTR:
			case MIDB:
			case MIDBTYPESUFFIX:
			case MIDTYPESUFFIX:
			case PSET:
			case SCALE:
			case SGN:
			case UBOUND:
			case ACCESS:
			case ALIAS:
			case ATTRIBUTE:
			case APPEND:
			case BEGIN:
			case BINARY:
			case BOOLEAN:
			case BYTE:
			case CLASS:
			case DATABASE:
			case DATE:
			case DOUBLE:
			case END_SELECT:
			case END_WITH:
			case END:
			case ERROR:
			case EXIT_DO:
			case EXIT_FOR:
			case EXIT_FUNCTION:
			case EXIT_PROPERTY:
			case EXIT_SUB:
			case INPUT:
			case INTEGER:
			case LONG:
			case LIB:
			case LINE_INPUT:
			case LOCK_READ:
			case LOCK_WRITE:
			case LOCK_READ_WRITE:
			case MID:
			case ON:
			case ON_ERROR:
			case OUTPUT:
			case RANDOM:
			case READ:
			case READ_WRITE:
			case RESET:
			case SHARED:
			case SINGLE:
			case STEP:
			case STRING:
			case TAB:
			case TEXT:
			case VARIANT:
			case VERSION:
			case WIDTH:
			case WRITE:
			case IDENTIFIER:
			case FOREIGNNAME:
			case OBJECT:
			case COLLECTION:
				{
				_localctx = new SimpleNameExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 369; simpleNameExpression();
				}
				break;
			case EXCLAMATIONPOINT:
			case DOT:
				{
				_localctx = new WithExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 370; withExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			_ctx.stop = _input.Lt(-1);
			State = 412;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,55,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 410;
					switch ( Interpreter.AdaptivePredict(_input,54,_ctx) ) {
					case 1:
						{
						_localctx = new IndexExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 373;
						if (!(Precpred(_ctx, 9))) throw new FailedPredicateException(this, "Precpred(_ctx, 9)");
						State = 375;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 374; whiteSpace();
							}
						}

						State = 377; Match(LPAREN);
						State = 379;
						switch ( Interpreter.AdaptivePredict(_input,50,_ctx) ) {
						case 1:
							{
							State = 378; whiteSpace();
							}
							break;
						}
						State = 382;
						switch ( Interpreter.AdaptivePredict(_input,51,_ctx) ) {
						case 1:
							{
							State = 381; argumentList();
							}
							break;
						}
						State = 385;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 384; whiteSpace();
							}
						}

						State = 387; Match(RPAREN);
						}
						break;

					case 2:
						{
						_localctx = new MemberAccessExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 388;
						if (!(Precpred(_ctx, 8))) throw new FailedPredicateException(this, "Precpred(_ctx, 8)");
						State = 389; Match(DOT);
						State = 390; unrestrictedName();
						}
						break;

					case 3:
						{
						_localctx = new MemberAccessExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 391;
						if (!(Precpred(_ctx, 7))) throw new FailedPredicateException(this, "Precpred(_ctx, 7)");
						State = 392; Match(LINE_CONTINUATION);
						State = 394;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 393; whiteSpace();
							}
						}

						State = 396; Match(DOT);
						State = 397; unrestrictedName();
						}
						break;

					case 4:
						{
						_localctx = new DictionaryAccessExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 398;
						if (!(Precpred(_ctx, 6))) throw new FailedPredicateException(this, "Precpred(_ctx, 6)");
						State = 399; Match(EXCLAMATIONPOINT);
						State = 400; unrestrictedName();
						}
						break;

					case 5:
						{
						_localctx = new DictionaryAccessExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 401;
						if (!(Precpred(_ctx, 5))) throw new FailedPredicateException(this, "Precpred(_ctx, 5)");
						State = 402; Match(LINE_CONTINUATION);
						State = 403; Match(EXCLAMATIONPOINT);
						State = 404; unrestrictedName();
						}
						break;

					case 6:
						{
						_localctx = new DictionaryAccessExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 405;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 406; Match(LINE_CONTINUATION);
						State = 407; Match(EXCLAMATIONPOINT);
						State = 408; Match(LINE_CONTINUATION);
						State = 409; unrestrictedName();
						}
						break;
					}
					} 
				}
				State = 414;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,55,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class MemberAccessExpressionContext : ParserRuleContext {
		public ITerminalNode DOT() { return GetToken(VBAExpressionParser.DOT, 0); }
		public ITerminalNode LINE_CONTINUATION() { return GetToken(VBAExpressionParser.LINE_CONTINUATION, 0); }
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public MemberAccessExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_memberAccessExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterMemberAccessExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitMemberAccessExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemberAccessExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MemberAccessExpressionContext memberAccessExpression() {
		MemberAccessExpressionContext _localctx = new MemberAccessExpressionContext(_ctx, State);
		EnterRule(_localctx, 40, RULE_memberAccessExpression);
		int _la;
		try {
			State = 427;
			switch ( Interpreter.AdaptivePredict(_input,57,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 415; lExpression(0);
				State = 416; Match(DOT);
				State = 417; unrestrictedName();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 419; lExpression(0);
				State = 420; Match(LINE_CONTINUATION);
				State = 422;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 421; whiteSpace();
					}
				}

				State = 424; Match(DOT);
				State = 425; unrestrictedName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexExpressionContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode LPAREN() { return GetToken(VBAExpressionParser.LPAREN, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode RPAREN() { return GetToken(VBAExpressionParser.RPAREN, 0); }
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		public IndexExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterIndexExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitIndexExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IndexExpressionContext indexExpression() {
		IndexExpressionContext _localctx = new IndexExpressionContext(_ctx, State);
		EnterRule(_localctx, 42, RULE_indexExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 429; lExpression(0);
			State = 431;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 430; whiteSpace();
				}
			}

			State = 433; Match(LPAREN);
			State = 435;
			switch ( Interpreter.AdaptivePredict(_input,59,_ctx) ) {
			case 1:
				{
				State = 434; whiteSpace();
				}
				break;
			}
			State = 438;
			switch ( Interpreter.AdaptivePredict(_input,60,_ctx) ) {
			case 1:
				{
				State = 437; argumentList();
				}
				break;
			}
			State = 441;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 440; whiteSpace();
				}
			}

			State = 443; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DictionaryAccessExpressionContext : ParserRuleContext {
		public IReadOnlyList<ITerminalNode> LINE_CONTINUATION() { return GetTokens(VBAExpressionParser.LINE_CONTINUATION); }
		public ITerminalNode EXCLAMATIONPOINT() { return GetToken(VBAExpressionParser.EXCLAMATIONPOINT, 0); }
		public ITerminalNode LINE_CONTINUATION(int i) {
			return GetToken(VBAExpressionParser.LINE_CONTINUATION, i);
		}
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public DictionaryAccessExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dictionaryAccessExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterDictionaryAccessExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitDictionaryAccessExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDictionaryAccessExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DictionaryAccessExpressionContext dictionaryAccessExpression() {
		DictionaryAccessExpressionContext _localctx = new DictionaryAccessExpressionContext(_ctx, State);
		EnterRule(_localctx, 44, RULE_dictionaryAccessExpression);
		try {
			State = 460;
			switch ( Interpreter.AdaptivePredict(_input,62,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 445; lExpression(0);
				State = 446; Match(EXCLAMATIONPOINT);
				State = 447; unrestrictedName();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 449; lExpression(0);
				State = 450; Match(LINE_CONTINUATION);
				State = 451; Match(EXCLAMATIONPOINT);
				State = 452; unrestrictedName();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 454; lExpression(0);
				State = 455; Match(LINE_CONTINUATION);
				State = 456; Match(EXCLAMATIONPOINT);
				State = 457; Match(LINE_CONTINUATION);
				State = 458; unrestrictedName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentListContext : ParserRuleContext {
		public PositionalOrNamedArgumentListContext positionalOrNamedArgumentList() {
			return GetRuleContext<PositionalOrNamedArgumentListContext>(0);
		}
		public ArgumentListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argumentList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterArgumentList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitArgumentList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgumentList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentListContext argumentList() {
		ArgumentListContext _localctx = new ArgumentListContext(_ctx, State);
		EnterRule(_localctx, 46, RULE_argumentList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 462; positionalOrNamedArgumentList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PositionalOrNamedArgumentListContext : ParserRuleContext {
		public RequiredPositionalArgumentContext requiredPositionalArgument() {
			return GetRuleContext<RequiredPositionalArgumentContext>(0);
		}
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public IReadOnlyList<ITerminalNode> COMMA() { return GetTokens(VBAExpressionParser.COMMA); }
		public IReadOnlyList<PositionalArgumentContext> positionalArgument() {
			return GetRuleContexts<PositionalArgumentContext>();
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public NamedArgumentListContext namedArgumentList() {
			return GetRuleContext<NamedArgumentListContext>(0);
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(VBAExpressionParser.COMMA, i);
		}
		public PositionalArgumentContext positionalArgument(int i) {
			return GetRuleContext<PositionalArgumentContext>(i);
		}
		public PositionalOrNamedArgumentListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_positionalOrNamedArgumentList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterPositionalOrNamedArgumentList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitPositionalOrNamedArgumentList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPositionalOrNamedArgumentList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PositionalOrNamedArgumentListContext positionalOrNamedArgumentList() {
		PositionalOrNamedArgumentListContext _localctx = new PositionalOrNamedArgumentListContext(_ctx, State);
		EnterRule(_localctx, 48, RULE_positionalOrNamedArgumentList);
		int _la;
		try {
			int _alt;
			State = 496;
			switch ( Interpreter.AdaptivePredict(_input,71,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 476;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,66,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 465;
						_la = _input.La(1);
						if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABS) | (1L << ANY) | (1L << ARRAY) | (1L << CBOOL) | (1L << CBYTE) | (1L << CCUR) | (1L << CDATE) | (1L << CDBL) | (1L << CDEC) | (1L << CINT) | (1L << CIRCLE) | (1L << CLNG) | (1L << CLNGLNG) | (1L << CLNGPTR) | (1L << CSNG) | (1L << CSTR) | (1L << CURRENCY) | (1L << CVAR) | (1L << CVERR) | (1L << DEBUG) | (1L << DOEVENTS) | (1L << FIX) | (1L << INPUTB) | (1L << INT) | (1L << LBOUND) | (1L << LEN) | (1L << LENB) | (1L << LONGLONG) | (1L << LONGPTR) | (1L << MIDB) | (1L << MIDBTYPESUFFIX) | (1L << MIDTYPESUFFIX) | (1L << PSET) | (1L << SCALE) | (1L << SGN) | (1L << UBOUND) | (1L << EXCLAMATIONPOINT) | (1L << DOT) | (1L << ACCESS) | (1L << ADDRESSOF) | (1L << ALIAS) | (1L << ATTRIBUTE) | (1L << APPEND) | (1L << BEGIN) | (1L << BINARY) | (1L << BOOLEAN) | (1L << BYVAL) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CLASS - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DOUBLE - 64)) | (1L << (EMPTY - 64)) | (1L << (END_SELECT - 64)) | (1L << (END_WITH - 64)) | (1L << (END - 64)) | (1L << (ERROR - 64)) | (1L << (EXIT_DO - 64)) | (1L << (EXIT_FOR - 64)) | (1L << (EXIT_FUNCTION - 64)) | (1L << (EXIT_PROPERTY - 64)) | (1L << (EXIT_SUB - 64)) | (1L << (FALSE - 64)) | (1L << (INPUT - 64)) | (1L << (INTEGER - 64)) | (1L << (LONG - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (LIB - 128)) | (1L << (LINE_INPUT - 128)) | (1L << (LOCK_READ - 128)) | (1L << (LOCK_WRITE - 128)) | (1L << (LOCK_READ_WRITE - 128)) | (1L << (ME - 128)) | (1L << (MID - 128)) | (1L << (NEW - 128)) | (1L << (NOT - 128)) | (1L << (NOTHING - 128)) | (1L << (NULL - 128)) | (1L << (ON - 128)) | (1L << (ON_ERROR - 128)) | (1L << (OUTPUT - 128)) | (1L << (RANDOM - 128)) | (1L << (READ - 128)) | (1L << (READ_WRITE - 128)) | (1L << (RESET - 128)) | (1L << (SHARED - 128)) | (1L << (SINGLE - 128)) | (1L << (STEP - 128)) | (1L << (STRING - 128)) | (1L << (TAB - 128)) | (1L << (TEXT - 128)) | (1L << (TRUE - 128)) | (1L << (TYPEOF - 128)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (VARIANT - 194)) | (1L << (VERSION - 194)) | (1L << (WIDTH - 194)) | (1L << (WRITE - 194)) | (1L << (LPAREN - 194)) | (1L << (MINUS - 194)) | (1L << (STRINGLITERAL - 194)) | (1L << (OCTLITERAL - 194)) | (1L << (HEXLITERAL - 194)) | (1L << (FLOATLITERAL - 194)) | (1L << (INTEGERLITERAL - 194)) | (1L << (DATELITERAL - 194)) | (1L << (IDENTIFIER - 194)) | (1L << (FOREIGNNAME - 194)) | (1L << (OBJECT - 194)) | (1L << (COLLECTION - 194)))) != 0)) {
							{
							State = 464; positionalArgument();
							}
						}

						State = 468;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 467; whiteSpace();
							}
						}

						State = 470; Match(COMMA);
						State = 472;
						switch ( Interpreter.AdaptivePredict(_input,65,_ctx) ) {
						case 1:
							{
							State = 471; whiteSpace();
							}
							break;
						}
						}
						} 
					}
					State = 478;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,66,_ctx);
				}
				State = 479; requiredPositionalArgument();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 492;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,70,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 481;
						_la = _input.La(1);
						if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABS) | (1L << ANY) | (1L << ARRAY) | (1L << CBOOL) | (1L << CBYTE) | (1L << CCUR) | (1L << CDATE) | (1L << CDBL) | (1L << CDEC) | (1L << CINT) | (1L << CIRCLE) | (1L << CLNG) | (1L << CLNGLNG) | (1L << CLNGPTR) | (1L << CSNG) | (1L << CSTR) | (1L << CURRENCY) | (1L << CVAR) | (1L << CVERR) | (1L << DEBUG) | (1L << DOEVENTS) | (1L << FIX) | (1L << INPUTB) | (1L << INT) | (1L << LBOUND) | (1L << LEN) | (1L << LENB) | (1L << LONGLONG) | (1L << LONGPTR) | (1L << MIDB) | (1L << MIDBTYPESUFFIX) | (1L << MIDTYPESUFFIX) | (1L << PSET) | (1L << SCALE) | (1L << SGN) | (1L << UBOUND) | (1L << EXCLAMATIONPOINT) | (1L << DOT) | (1L << ACCESS) | (1L << ADDRESSOF) | (1L << ALIAS) | (1L << ATTRIBUTE) | (1L << APPEND) | (1L << BEGIN) | (1L << BINARY) | (1L << BOOLEAN) | (1L << BYVAL) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CLASS - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DOUBLE - 64)) | (1L << (EMPTY - 64)) | (1L << (END_SELECT - 64)) | (1L << (END_WITH - 64)) | (1L << (END - 64)) | (1L << (ERROR - 64)) | (1L << (EXIT_DO - 64)) | (1L << (EXIT_FOR - 64)) | (1L << (EXIT_FUNCTION - 64)) | (1L << (EXIT_PROPERTY - 64)) | (1L << (EXIT_SUB - 64)) | (1L << (FALSE - 64)) | (1L << (INPUT - 64)) | (1L << (INTEGER - 64)) | (1L << (LONG - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (LIB - 128)) | (1L << (LINE_INPUT - 128)) | (1L << (LOCK_READ - 128)) | (1L << (LOCK_WRITE - 128)) | (1L << (LOCK_READ_WRITE - 128)) | (1L << (ME - 128)) | (1L << (MID - 128)) | (1L << (NEW - 128)) | (1L << (NOT - 128)) | (1L << (NOTHING - 128)) | (1L << (NULL - 128)) | (1L << (ON - 128)) | (1L << (ON_ERROR - 128)) | (1L << (OUTPUT - 128)) | (1L << (RANDOM - 128)) | (1L << (READ - 128)) | (1L << (READ_WRITE - 128)) | (1L << (RESET - 128)) | (1L << (SHARED - 128)) | (1L << (SINGLE - 128)) | (1L << (STEP - 128)) | (1L << (STRING - 128)) | (1L << (TAB - 128)) | (1L << (TEXT - 128)) | (1L << (TRUE - 128)) | (1L << (TYPEOF - 128)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (VARIANT - 194)) | (1L << (VERSION - 194)) | (1L << (WIDTH - 194)) | (1L << (WRITE - 194)) | (1L << (LPAREN - 194)) | (1L << (MINUS - 194)) | (1L << (STRINGLITERAL - 194)) | (1L << (OCTLITERAL - 194)) | (1L << (HEXLITERAL - 194)) | (1L << (FLOATLITERAL - 194)) | (1L << (INTEGERLITERAL - 194)) | (1L << (DATELITERAL - 194)) | (1L << (IDENTIFIER - 194)) | (1L << (FOREIGNNAME - 194)) | (1L << (OBJECT - 194)) | (1L << (COLLECTION - 194)))) != 0)) {
							{
							State = 480; positionalArgument();
							}
						}

						State = 484;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 483; whiteSpace();
							}
						}

						State = 486; Match(COMMA);
						State = 488;
						switch ( Interpreter.AdaptivePredict(_input,69,_ctx) ) {
						case 1:
							{
							State = 487; whiteSpace();
							}
							break;
						}
						}
						} 
					}
					State = 494;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,70,_ctx);
				}
				State = 495; namedArgumentList();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PositionalArgumentContext : ParserRuleContext {
		public ArgumentExpressionContext argumentExpression() {
			return GetRuleContext<ArgumentExpressionContext>(0);
		}
		public PositionalArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_positionalArgument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterPositionalArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitPositionalArgument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPositionalArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PositionalArgumentContext positionalArgument() {
		PositionalArgumentContext _localctx = new PositionalArgumentContext(_ctx, State);
		EnterRule(_localctx, 50, RULE_positionalArgument);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 498; argumentExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RequiredPositionalArgumentContext : ParserRuleContext {
		public ArgumentExpressionContext argumentExpression() {
			return GetRuleContext<ArgumentExpressionContext>(0);
		}
		public RequiredPositionalArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_requiredPositionalArgument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterRequiredPositionalArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitRequiredPositionalArgument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRequiredPositionalArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RequiredPositionalArgumentContext requiredPositionalArgument() {
		RequiredPositionalArgumentContext _localctx = new RequiredPositionalArgumentContext(_ctx, State);
		EnterRule(_localctx, 52, RULE_requiredPositionalArgument);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 500; argumentExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NamedArgumentListContext : ParserRuleContext {
		public IReadOnlyList<NamedArgumentContext> namedArgument() {
			return GetRuleContexts<NamedArgumentContext>();
		}
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public IReadOnlyList<ITerminalNode> COMMA() { return GetTokens(VBAExpressionParser.COMMA); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public NamedArgumentContext namedArgument(int i) {
			return GetRuleContext<NamedArgumentContext>(i);
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(VBAExpressionParser.COMMA, i);
		}
		public NamedArgumentListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_namedArgumentList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterNamedArgumentList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitNamedArgumentList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamedArgumentList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NamedArgumentListContext namedArgumentList() {
		NamedArgumentListContext _localctx = new NamedArgumentListContext(_ctx, State);
		EnterRule(_localctx, 54, RULE_namedArgumentList);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 502; namedArgument();
			State = 513;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,74,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 504;
					_la = _input.La(1);
					if (_la==WS || _la==LINE_CONTINUATION) {
						{
						State = 503; whiteSpace();
						}
					}

					State = 506; Match(COMMA);
					State = 508;
					_la = _input.La(1);
					if (_la==WS || _la==LINE_CONTINUATION) {
						{
						State = 507; whiteSpace();
						}
					}

					State = 510; namedArgument();
					}
					} 
				}
				State = 515;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,74,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NamedArgumentContext : ParserRuleContext {
		public ITerminalNode ASSIGN() { return GetToken(VBAExpressionParser.ASSIGN, 0); }
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ArgumentExpressionContext argumentExpression() {
			return GetRuleContext<ArgumentExpressionContext>(0);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public NamedArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_namedArgument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterNamedArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitNamedArgument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamedArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NamedArgumentContext namedArgument() {
		NamedArgumentContext _localctx = new NamedArgumentContext(_ctx, State);
		EnterRule(_localctx, 56, RULE_namedArgument);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 516; unrestrictedName();
			State = 518;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 517; whiteSpace();
				}
			}

			State = 520; Match(ASSIGN);
			State = 522;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 521; whiteSpace();
				}
			}

			State = 524; argumentExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentExpressionContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public AddressOfExpressionContext addressOfExpression() {
			return GetRuleContext<AddressOfExpressionContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode BYVAL() { return GetToken(VBAExpressionParser.BYVAL, 0); }
		public ArgumentExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argumentExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterArgumentExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitArgumentExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgumentExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentExpressionContext argumentExpression() {
		ArgumentExpressionContext _localctx = new ArgumentExpressionContext(_ctx, State);
		EnterRule(_localctx, 58, RULE_argumentExpression);
		int _la;
		try {
			State = 532;
			switch (_input.La(1)) {
			case ABS:
			case ANY:
			case ARRAY:
			case CBOOL:
			case CBYTE:
			case CCUR:
			case CDATE:
			case CDBL:
			case CDEC:
			case CINT:
			case CIRCLE:
			case CLNG:
			case CLNGLNG:
			case CLNGPTR:
			case CSNG:
			case CSTR:
			case CURRENCY:
			case CVAR:
			case CVERR:
			case DEBUG:
			case DOEVENTS:
			case FIX:
			case INPUTB:
			case INT:
			case LBOUND:
			case LEN:
			case LENB:
			case LONGLONG:
			case LONGPTR:
			case MIDB:
			case MIDBTYPESUFFIX:
			case MIDTYPESUFFIX:
			case PSET:
			case SCALE:
			case SGN:
			case UBOUND:
			case EXCLAMATIONPOINT:
			case DOT:
			case ACCESS:
			case ALIAS:
			case ATTRIBUTE:
			case APPEND:
			case BEGIN:
			case BINARY:
			case BOOLEAN:
			case BYVAL:
			case BYTE:
			case CLASS:
			case DATABASE:
			case DATE:
			case DOUBLE:
			case EMPTY:
			case END_SELECT:
			case END_WITH:
			case END:
			case ERROR:
			case EXIT_DO:
			case EXIT_FOR:
			case EXIT_FUNCTION:
			case EXIT_PROPERTY:
			case EXIT_SUB:
			case FALSE:
			case INPUT:
			case INTEGER:
			case LONG:
			case LIB:
			case LINE_INPUT:
			case LOCK_READ:
			case LOCK_WRITE:
			case LOCK_READ_WRITE:
			case ME:
			case MID:
			case NEW:
			case NOT:
			case NOTHING:
			case NULL:
			case ON:
			case ON_ERROR:
			case OUTPUT:
			case RANDOM:
			case READ:
			case READ_WRITE:
			case RESET:
			case SHARED:
			case SINGLE:
			case STEP:
			case STRING:
			case TAB:
			case TEXT:
			case TRUE:
			case TYPEOF:
			case VARIANT:
			case VERSION:
			case WIDTH:
			case WRITE:
			case LPAREN:
			case MINUS:
			case STRINGLITERAL:
			case OCTLITERAL:
			case HEXLITERAL:
			case FLOATLITERAL:
			case INTEGERLITERAL:
			case DATELITERAL:
			case IDENTIFIER:
			case FOREIGNNAME:
			case OBJECT:
			case COLLECTION:
				EnterOuterAlt(_localctx, 1);
				{
				State = 528;
				_la = _input.La(1);
				if (_la==BYVAL) {
					{
					State = 526; Match(BYVAL);
					State = 527; whiteSpace();
					}
				}

				State = 530; expression(0);
				}
				break;
			case ADDRESSOF:
				EnterOuterAlt(_localctx, 2);
				{
				State = 531; addressOfExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleNameExpressionContext : ParserRuleContext {
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public SimpleNameExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleNameExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterSimpleNameExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitSimpleNameExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleNameExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SimpleNameExpressionContext simpleNameExpression() {
		SimpleNameExpressionContext _localctx = new SimpleNameExpressionContext(_ctx, State);
		EnterRule(_localctx, 60, RULE_simpleNameExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 534; name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InstanceExpressionContext : ParserRuleContext {
		public ITerminalNode ME() { return GetToken(VBAExpressionParser.ME, 0); }
		public InstanceExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_instanceExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterInstanceExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitInstanceExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInstanceExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InstanceExpressionContext instanceExpression() {
		InstanceExpressionContext _localctx = new InstanceExpressionContext(_ctx, State);
		EnterRule(_localctx, 62, RULE_instanceExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 536; Match(ME);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithExpressionContext : ParserRuleContext {
		public WithDictionaryAccessExpressionContext withDictionaryAccessExpression() {
			return GetRuleContext<WithDictionaryAccessExpressionContext>(0);
		}
		public WithMemberAccessExpressionContext withMemberAccessExpression() {
			return GetRuleContext<WithMemberAccessExpressionContext>(0);
		}
		public WithExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterWithExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitWithExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WithExpressionContext withExpression() {
		WithExpressionContext _localctx = new WithExpressionContext(_ctx, State);
		EnterRule(_localctx, 64, RULE_withExpression);
		try {
			State = 540;
			switch (_input.La(1)) {
			case DOT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 538; withMemberAccessExpression();
				}
				break;
			case EXCLAMATIONPOINT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 539; withDictionaryAccessExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithMemberAccessExpressionContext : ParserRuleContext {
		public ITerminalNode DOT() { return GetToken(VBAExpressionParser.DOT, 0); }
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public WithMemberAccessExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withMemberAccessExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterWithMemberAccessExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitWithMemberAccessExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithMemberAccessExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WithMemberAccessExpressionContext withMemberAccessExpression() {
		WithMemberAccessExpressionContext _localctx = new WithMemberAccessExpressionContext(_ctx, State);
		EnterRule(_localctx, 66, RULE_withMemberAccessExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 542; Match(DOT);
			State = 543; unrestrictedName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithDictionaryAccessExpressionContext : ParserRuleContext {
		public ITerminalNode EXCLAMATIONPOINT() { return GetToken(VBAExpressionParser.EXCLAMATIONPOINT, 0); }
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public WithDictionaryAccessExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withDictionaryAccessExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterWithDictionaryAccessExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitWithDictionaryAccessExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithDictionaryAccessExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WithDictionaryAccessExpressionContext withDictionaryAccessExpression() {
		WithDictionaryAccessExpressionContext _localctx = new WithDictionaryAccessExpressionContext(_ctx, State);
		EnterRule(_localctx, 68, RULE_withDictionaryAccessExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 545; Match(EXCLAMATIONPOINT);
			State = 546; unrestrictedName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantExpressionContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ConstantExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constantExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterConstantExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitConstantExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstantExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantExpressionContext constantExpression() {
		ConstantExpressionContext _localctx = new ConstantExpressionContext(_ctx, State);
		EnterRule(_localctx, 70, RULE_constantExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 548; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeExpressionContext : ParserRuleContext {
		public DefinedTypeExpressionContext definedTypeExpression() {
			return GetRuleContext<DefinedTypeExpressionContext>(0);
		}
		public BuiltInTypeContext builtInType() {
			return GetRuleContext<BuiltInTypeContext>(0);
		}
		public TypeExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypeExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypeExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeExpressionContext typeExpression() {
		TypeExpressionContext _localctx = new TypeExpressionContext(_ctx, State);
		EnterRule(_localctx, 72, RULE_typeExpression);
		try {
			State = 552;
			switch ( Interpreter.AdaptivePredict(_input,80,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 550; builtInType();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 551; definedTypeExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DefinedTypeExpressionContext : ParserRuleContext {
		public MemberAccessExpressionContext memberAccessExpression() {
			return GetRuleContext<MemberAccessExpressionContext>(0);
		}
		public SimpleNameExpressionContext simpleNameExpression() {
			return GetRuleContext<SimpleNameExpressionContext>(0);
		}
		public DefinedTypeExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_definedTypeExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterDefinedTypeExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitDefinedTypeExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefinedTypeExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DefinedTypeExpressionContext definedTypeExpression() {
		DefinedTypeExpressionContext _localctx = new DefinedTypeExpressionContext(_ctx, State);
		EnterRule(_localctx, 74, RULE_definedTypeExpression);
		try {
			State = 556;
			switch ( Interpreter.AdaptivePredict(_input,81,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 554; simpleNameExpression();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 555; memberAccessExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AddressOfExpressionContext : ParserRuleContext {
		public ITerminalNode ADDRESSOF() { return GetToken(VBAExpressionParser.ADDRESSOF, 0); }
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public ProcedurePointerExpressionContext procedurePointerExpression() {
			return GetRuleContext<ProcedurePointerExpressionContext>(0);
		}
		public AddressOfExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_addressOfExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterAddressOfExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitAddressOfExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAddressOfExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AddressOfExpressionContext addressOfExpression() {
		AddressOfExpressionContext _localctx = new AddressOfExpressionContext(_ctx, State);
		EnterRule(_localctx, 76, RULE_addressOfExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 558; Match(ADDRESSOF);
			State = 559; whiteSpace();
			State = 560; procedurePointerExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedurePointerExpressionContext : ParserRuleContext {
		public MemberAccessExpressionContext memberAccessExpression() {
			return GetRuleContext<MemberAccessExpressionContext>(0);
		}
		public SimpleNameExpressionContext simpleNameExpression() {
			return GetRuleContext<SimpleNameExpressionContext>(0);
		}
		public ProcedurePointerExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedurePointerExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterProcedurePointerExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitProcedurePointerExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProcedurePointerExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProcedurePointerExpressionContext procedurePointerExpression() {
		ProcedurePointerExpressionContext _localctx = new ProcedurePointerExpressionContext(_ctx, State);
		EnterRule(_localctx, 78, RULE_procedurePointerExpression);
		try {
			State = 564;
			switch ( Interpreter.AdaptivePredict(_input,82,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 562; memberAccessExpression();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 563; simpleNameExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedIdentifierContext : ParserRuleContext {
		public MarkerKeywordContext markerKeyword() {
			return GetRuleContext<MarkerKeywordContext>(0);
		}
		public SpecialFormContext specialForm() {
			return GetRuleContext<SpecialFormContext>(0);
		}
		public ReservedTypeIdentifierContext reservedTypeIdentifier() {
			return GetRuleContext<ReservedTypeIdentifierContext>(0);
		}
		public OperatorIdentifierContext operatorIdentifier() {
			return GetRuleContext<OperatorIdentifierContext>(0);
		}
		public RemKeywordContext remKeyword() {
			return GetRuleContext<RemKeywordContext>(0);
		}
		public ReservedNameContext reservedName() {
			return GetRuleContext<ReservedNameContext>(0);
		}
		public StatementKeywordContext statementKeyword() {
			return GetRuleContext<StatementKeywordContext>(0);
		}
		public LiteralIdentifierContext literalIdentifier() {
			return GetRuleContext<LiteralIdentifierContext>(0);
		}
		public ReservedIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedIdentifierContext reservedIdentifier() {
		ReservedIdentifierContext _localctx = new ReservedIdentifierContext(_ctx, State);
		EnterRule(_localctx, 80, RULE_reservedIdentifier);
		try {
			State = 574;
			switch ( Interpreter.AdaptivePredict(_input,83,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 566; statementKeyword();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 567; markerKeyword();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 568; operatorIdentifier();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 569; specialForm();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 570; reservedName();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 571; literalIdentifier();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 572; remKeyword();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 573; reservedTypeIdentifier();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementKeywordContext : ParserRuleContext {
		public ITerminalNode CASE() { return GetToken(VBAExpressionParser.CASE, 0); }
		public ITerminalNode DEFOBJ() { return GetToken(VBAExpressionParser.DEFOBJ, 0); }
		public ITerminalNode ELSE() { return GetToken(VBAExpressionParser.ELSE, 0); }
		public ITerminalNode IF() { return GetToken(VBAExpressionParser.IF, 0); }
		public ITerminalNode ERASE() { return GetToken(VBAExpressionParser.ERASE, 0); }
		public ITerminalNode END_IF() { return GetToken(VBAExpressionParser.END_IF, 0); }
		public ITerminalNode RAISEEVENT() { return GetToken(VBAExpressionParser.RAISEEVENT, 0); }
		public ITerminalNode STOP() { return GetToken(VBAExpressionParser.STOP, 0); }
		public ITerminalNode PRIVATE() { return GetToken(VBAExpressionParser.PRIVATE, 0); }
		public ITerminalNode DEFBYTE() { return GetToken(VBAExpressionParser.DEFBYTE, 0); }
		public ITerminalNode DEFSNG() { return GetToken(VBAExpressionParser.DEFSNG, 0); }
		public ITerminalNode GOSUB() { return GetToken(VBAExpressionParser.GOSUB, 0); }
		public ITerminalNode RETURN() { return GetToken(VBAExpressionParser.RETURN, 0); }
		public ITerminalNode ENUM() { return GetToken(VBAExpressionParser.ENUM, 0); }
		public ITerminalNode LOCK() { return GetToken(VBAExpressionParser.LOCK, 0); }
		public ITerminalNode GLOBAL() { return GetToken(VBAExpressionParser.GLOBAL, 0); }
		public ITerminalNode WEND() { return GetToken(VBAExpressionParser.WEND, 0); }
		public ITerminalNode DEFSTR() { return GetToken(VBAExpressionParser.DEFSTR, 0); }
		public ITerminalNode DEFLNGLNG() { return GetToken(VBAExpressionParser.DEFLNGLNG, 0); }
		public ITerminalNode DEFVAR() { return GetToken(VBAExpressionParser.DEFVAR, 0); }
		public ITerminalNode EVENT() { return GetToken(VBAExpressionParser.EVENT, 0); }
		public ITerminalNode CONST() { return GetToken(VBAExpressionParser.CONST, 0); }
		public ITerminalNode ELSEIF() { return GetToken(VBAExpressionParser.ELSEIF, 0); }
		public ITerminalNode PRINT() { return GetToken(VBAExpressionParser.PRINT, 0); }
		public ITerminalNode DEFINT() { return GetToken(VBAExpressionParser.DEFINT, 0); }
		public ITerminalNode SUB() { return GetToken(VBAExpressionParser.SUB, 0); }
		public ITerminalNode FOR() { return GetToken(VBAExpressionParser.FOR, 0); }
		public ITerminalNode LSET() { return GetToken(VBAExpressionParser.LSET, 0); }
		public ITerminalNode INPUT() { return GetToken(VBAExpressionParser.INPUT, 0); }
		public ITerminalNode SEEK() { return GetToken(VBAExpressionParser.SEEK, 0); }
		public ITerminalNode LOOP() { return GetToken(VBAExpressionParser.LOOP, 0); }
		public ITerminalNode DEFCUR() { return GetToken(VBAExpressionParser.DEFCUR, 0); }
		public ITerminalNode PUBLIC() { return GetToken(VBAExpressionParser.PUBLIC, 0); }
		public ITerminalNode DEFDATE() { return GetToken(VBAExpressionParser.DEFDATE, 0); }
		public ITerminalNode PUT() { return GetToken(VBAExpressionParser.PUT, 0); }
		public ITerminalNode LET() { return GetToken(VBAExpressionParser.LET, 0); }
		public ITerminalNode FRIEND() { return GetToken(VBAExpressionParser.FRIEND, 0); }
		public ITerminalNode TYPE() { return GetToken(VBAExpressionParser.TYPE, 0); }
		public ITerminalNode CALL() { return GetToken(VBAExpressionParser.CALL, 0); }
		public ITerminalNode DEFBOOL() { return GetToken(VBAExpressionParser.DEFBOOL, 0); }
		public ITerminalNode OPEN() { return GetToken(VBAExpressionParser.OPEN, 0); }
		public ITerminalNode STATIC() { return GetToken(VBAExpressionParser.STATIC, 0); }
		public ITerminalNode DO() { return GetToken(VBAExpressionParser.DO, 0); }
		public ITerminalNode DIM() { return GetToken(VBAExpressionParser.DIM, 0); }
		public ITerminalNode OPTION() { return GetToken(VBAExpressionParser.OPTION, 0); }
		public ITerminalNode CLOSE() { return GetToken(VBAExpressionParser.CLOSE, 0); }
		public ITerminalNode DEFLNG() { return GetToken(VBAExpressionParser.DEFLNG, 0); }
		public ITerminalNode IMPLEMENTS() { return GetToken(VBAExpressionParser.IMPLEMENTS, 0); }
		public ITerminalNode ON() { return GetToken(VBAExpressionParser.ON, 0); }
		public ITerminalNode WITH() { return GetToken(VBAExpressionParser.WITH, 0); }
		public ITerminalNode DECLARE() { return GetToken(VBAExpressionParser.DECLARE, 0); }
		public ITerminalNode RESUME() { return GetToken(VBAExpressionParser.RESUME, 0); }
		public ITerminalNode WRITE() { return GetToken(VBAExpressionParser.WRITE, 0); }
		public ITerminalNode DEFLNGPTR() { return GetToken(VBAExpressionParser.DEFLNGPTR, 0); }
		public ITerminalNode WHILE() { return GetToken(VBAExpressionParser.WHILE, 0); }
		public ITerminalNode EXIT() { return GetToken(VBAExpressionParser.EXIT, 0); }
		public ITerminalNode GET() { return GetToken(VBAExpressionParser.GET, 0); }
		public ITerminalNode DEFDBL() { return GetToken(VBAExpressionParser.DEFDBL, 0); }
		public ITerminalNode NEXT() { return GetToken(VBAExpressionParser.NEXT, 0); }
		public ITerminalNode FUNCTION() { return GetToken(VBAExpressionParser.FUNCTION, 0); }
		public ITerminalNode RSET() { return GetToken(VBAExpressionParser.RSET, 0); }
		public ITerminalNode GOTO() { return GetToken(VBAExpressionParser.GOTO, 0); }
		public ITerminalNode REDIM() { return GetToken(VBAExpressionParser.REDIM, 0); }
		public ITerminalNode SELECT() { return GetToken(VBAExpressionParser.SELECT, 0); }
		public ITerminalNode UNLOCK() { return GetToken(VBAExpressionParser.UNLOCK, 0); }
		public ITerminalNode SET() { return GetToken(VBAExpressionParser.SET, 0); }
		public StatementKeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statementKeyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterStatementKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitStatementKeyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatementKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementKeywordContext statementKeyword() {
		StatementKeywordContext _localctx = new StatementKeywordContext(_ctx, State);
		EnterRule(_localctx, 82, RULE_statementKeyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 576;
			_la = _input.La(1);
			if ( !(((((_la - 22)) & ~0x3f) == 0 && ((1L << (_la - 22)) & ((1L << (EXIT - 22)) | (1L << (OPTION - 22)) | (1L << (CALL - 22)) | (1L << (CASE - 22)) | (1L << (CLOSE - 22)) | (1L << (CONST - 22)) | (1L << (DECLARE - 22)) | (1L << (DEFBOOL - 22)) | (1L << (DEFBYTE - 22)) | (1L << (DEFDATE - 22)) | (1L << (DEFDBL - 22)) | (1L << (DEFCUR - 22)) | (1L << (DEFINT - 22)) | (1L << (DEFLNG - 22)) | (1L << (DEFLNGLNG - 22)) | (1L << (DEFLNGPTR - 22)) | (1L << (DEFOBJ - 22)) | (1L << (DEFSNG - 22)) | (1L << (DEFSTR - 22)) | (1L << (DEFVAR - 22)) | (1L << (DIM - 22)) | (1L << (DO - 22)))) != 0) || ((((_la - 87)) & ~0x3f) == 0 && ((1L << (_la - 87)) & ((1L << (ELSE - 87)) | (1L << (ELSEIF - 87)) | (1L << (END_IF - 87)) | (1L << (ENUM - 87)) | (1L << (ERASE - 87)) | (1L << (EVENT - 87)) | (1L << (FRIEND - 87)) | (1L << (FOR - 87)) | (1L << (FUNCTION - 87)) | (1L << (GET - 87)) | (1L << (GLOBAL - 87)) | (1L << (GOSUB - 87)) | (1L << (GOTO - 87)) | (1L << (IF - 87)) | (1L << (IMPLEMENTS - 87)) | (1L << (INPUT - 87)) | (1L << (LOCK - 87)) | (1L << (LOOP - 87)) | (1L << (LET - 87)) | (1L << (LSET - 87)) | (1L << (NEXT - 87)) | (1L << (ON - 87)) | (1L << (OPEN - 87)))) != 0) || ((((_la - 156)) & ~0x3f) == 0 && ((1L << (_la - 156)) & ((1L << (PRINT - 156)) | (1L << (PRIVATE - 156)) | (1L << (PUBLIC - 156)) | (1L << (PUT - 156)) | (1L << (RAISEEVENT - 156)) | (1L << (REDIM - 156)) | (1L << (RESUME - 156)) | (1L << (RETURN - 156)) | (1L << (RSET - 156)) | (1L << (SEEK - 156)) | (1L << (SELECT - 156)) | (1L << (SET - 156)) | (1L << (STATIC - 156)) | (1L << (STOP - 156)) | (1L << (SUB - 156)) | (1L << (TYPE - 156)) | (1L << (UNLOCK - 156)) | (1L << (WEND - 156)) | (1L << (WHILE - 156)) | (1L << (WITH - 156)) | (1L << (WRITE - 156)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RemKeywordContext : ParserRuleContext {
		public ITerminalNode REM() { return GetToken(VBAExpressionParser.REM, 0); }
		public RemKeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_remKeyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterRemKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitRemKeyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRemKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RemKeywordContext remKeyword() {
		RemKeywordContext _localctx = new RemKeywordContext(_ctx, State);
		EnterRule(_localctx, 84, RULE_remKeyword);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 578; Match(REM);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MarkerKeywordContext : ParserRuleContext {
		public ITerminalNode CASE() { return GetToken(VBAExpressionParser.CASE, 0); }
		public ITerminalNode ELSE() { return GetToken(VBAExpressionParser.ELSE, 0); }
		public ITerminalNode THEN() { return GetToken(VBAExpressionParser.THEN, 0); }
		public ITerminalNode WRITE() { return GetToken(VBAExpressionParser.WRITE, 0); }
		public ITerminalNode PRESERVE() { return GetToken(VBAExpressionParser.PRESERVE, 0); }
		public ITerminalNode SPC() { return GetToken(VBAExpressionParser.SPC, 0); }
		public ITerminalNode TO() { return GetToken(VBAExpressionParser.TO, 0); }
		public ITerminalNode EACH() { return GetToken(VBAExpressionParser.EACH, 0); }
		public ITerminalNode SHARED() { return GetToken(VBAExpressionParser.SHARED, 0); }
		public ITerminalNode ANY() { return GetToken(VBAExpressionParser.ANY, 0); }
		public ITerminalNode NEW() { return GetToken(VBAExpressionParser.NEW, 0); }
		public ITerminalNode AS() { return GetToken(VBAExpressionParser.AS, 0); }
		public ITerminalNode BYVAL() { return GetToken(VBAExpressionParser.BYVAL, 0); }
		public ITerminalNode IN() { return GetToken(VBAExpressionParser.IN, 0); }
		public ITerminalNode TAB() { return GetToken(VBAExpressionParser.TAB, 0); }
		public ITerminalNode BYREF() { return GetToken(VBAExpressionParser.BYREF, 0); }
		public ITerminalNode OPTIONAL() { return GetToken(VBAExpressionParser.OPTIONAL, 0); }
		public ITerminalNode UNTIL() { return GetToken(VBAExpressionParser.UNTIL, 0); }
		public ITerminalNode PARAMARRAY() { return GetToken(VBAExpressionParser.PARAMARRAY, 0); }
		public ITerminalNode WITHEVENTS() { return GetToken(VBAExpressionParser.WITHEVENTS, 0); }
		public MarkerKeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_markerKeyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterMarkerKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitMarkerKeyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMarkerKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MarkerKeywordContext markerKeyword() {
		MarkerKeywordContext _localctx = new MarkerKeywordContext(_ctx, State);
		EnterRule(_localctx, 86, RULE_markerKeyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 580;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ANY) | (1L << AS) | (1L << BYVAL) | (1L << BYREF) | (1L << CASE))) != 0) || ((((_la - 86)) & ~0x3f) == 0 && ((1L << (_la - 86)) & ((1L << (EACH - 86)) | (1L << (ELSE - 86)) | (1L << (IN - 86)) | (1L << (NEW - 86)) | (1L << (OPTIONAL - 86)))) != 0) || ((((_la - 154)) & ~0x3f) == 0 && ((1L << (_la - 154)) & ((1L << (PARAMARRAY - 154)) | (1L << (PRESERVE - 154)) | (1L << (SHARED - 154)) | (1L << (SPC - 154)) | (1L << (TAB - 154)) | (1L << (THEN - 154)) | (1L << (TO - 154)) | (1L << (UNTIL - 154)) | (1L << (WITHEVENTS - 154)) | (1L << (WRITE - 154)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OperatorIdentifierContext : ParserRuleContext {
		public ITerminalNode NOT() { return GetToken(VBAExpressionParser.NOT, 0); }
		public ITerminalNode IS() { return GetToken(VBAExpressionParser.IS, 0); }
		public ITerminalNode XOR() { return GetToken(VBAExpressionParser.XOR, 0); }
		public ITerminalNode EQV() { return GetToken(VBAExpressionParser.EQV, 0); }
		public ITerminalNode ADDRESSOF() { return GetToken(VBAExpressionParser.ADDRESSOF, 0); }
		public ITerminalNode AND() { return GetToken(VBAExpressionParser.AND, 0); }
		public ITerminalNode TYPEOF() { return GetToken(VBAExpressionParser.TYPEOF, 0); }
		public ITerminalNode LIKE() { return GetToken(VBAExpressionParser.LIKE, 0); }
		public ITerminalNode MOD() { return GetToken(VBAExpressionParser.MOD, 0); }
		public ITerminalNode OR() { return GetToken(VBAExpressionParser.OR, 0); }
		public ITerminalNode IMP() { return GetToken(VBAExpressionParser.IMP, 0); }
		public ITerminalNode NEW() { return GetToken(VBAExpressionParser.NEW, 0); }
		public OperatorIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_operatorIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterOperatorIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitOperatorIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOperatorIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OperatorIdentifierContext operatorIdentifier() {
		OperatorIdentifierContext _localctx = new OperatorIdentifierContext(_ctx, State);
		EnterRule(_localctx, 88, RULE_operatorIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 582;
			_la = _input.La(1);
			if ( !(_la==ADDRESSOF || _la==AND || ((((_la - 100)) & ~0x3f) == 0 && ((1L << (_la - 100)) & ((1L << (EQV - 100)) | (1L << (IMP - 100)) | (1L << (IS - 100)) | (1L << (LIKE - 100)) | (1L << (MOD - 100)) | (1L << (NEW - 100)) | (1L << (NOT - 100)) | (1L << (OR - 100)))) != 0) || _la==TYPEOF || _la==XOR) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedNameContext : ParserRuleContext {
		public ITerminalNode ME() { return GetToken(VBAExpressionParser.ME, 0); }
		public ReservedProcedureNameContext reservedProcedureName() {
			return GetRuleContext<ReservedProcedureNameContext>(0);
		}
		public ReservedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedNameContext reservedName() {
		ReservedNameContext _localctx = new ReservedNameContext(_ctx, State);
		EnterRule(_localctx, 90, RULE_reservedName);
		try {
			State = 586;
			switch (_input.La(1)) {
			case ME:
				EnterOuterAlt(_localctx, 1);
				{
				State = 584; Match(ME);
				}
				break;
			case ABS:
			case CBOOL:
			case CBYTE:
			case CCUR:
			case CDATE:
			case CDBL:
			case CDEC:
			case CINT:
			case CLNG:
			case CLNGLNG:
			case CLNGPTR:
			case CSNG:
			case CSTR:
			case CVAR:
			case CVERR:
			case DEBUG:
			case DOEVENTS:
			case FIX:
			case INT:
			case LEN:
			case LENB:
			case MIDB:
			case MIDBTYPESUFFIX:
			case MIDTYPESUFFIX:
			case PSET:
			case SCALE:
			case SGN:
			case ACCESS:
			case APPEND:
			case BINARY:
			case END_SELECT:
			case END_WITH:
			case END:
			case ERROR:
			case EXIT_DO:
			case EXIT_FOR:
			case EXIT_FUNCTION:
			case EXIT_PROPERTY:
			case EXIT_SUB:
			case LINE_INPUT:
			case LOCK_READ:
			case LOCK_WRITE:
			case LOCK_READ_WRITE:
			case MID:
			case ON_ERROR:
			case OUTPUT:
			case RANDOM:
			case READ:
			case READ_WRITE:
			case RESET:
			case SHARED:
			case STEP:
			case WIDTH:
			case WRITE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 585; reservedProcedureName();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedProcedureNameContext : ParserRuleContext {
		public ITerminalNode LOCK_WRITE() { return GetToken(VBAExpressionParser.LOCK_WRITE, 0); }
		public ITerminalNode CLNGLNG() { return GetToken(VBAExpressionParser.CLNGLNG, 0); }
		public ITerminalNode RESET() { return GetToken(VBAExpressionParser.RESET, 0); }
		public ITerminalNode END_SELECT() { return GetToken(VBAExpressionParser.END_SELECT, 0); }
		public ITerminalNode ON_ERROR() { return GetToken(VBAExpressionParser.ON_ERROR, 0); }
		public ITerminalNode SHARED() { return GetToken(VBAExpressionParser.SHARED, 0); }
		public ITerminalNode LENB() { return GetToken(VBAExpressionParser.LENB, 0); }
		public ITerminalNode APPEND() { return GetToken(VBAExpressionParser.APPEND, 0); }
		public ITerminalNode SCALE() { return GetToken(VBAExpressionParser.SCALE, 0); }
		public ITerminalNode MIDTYPESUFFIX() { return GetToken(VBAExpressionParser.MIDTYPESUFFIX, 0); }
		public ITerminalNode DEBUG() { return GetToken(VBAExpressionParser.DEBUG, 0); }
		public ITerminalNode CLNGPTR() { return GetToken(VBAExpressionParser.CLNGPTR, 0); }
		public ITerminalNode EXIT_DO() { return GetToken(VBAExpressionParser.EXIT_DO, 0); }
		public ITerminalNode CDEC() { return GetToken(VBAExpressionParser.CDEC, 0); }
		public ITerminalNode WIDTH() { return GetToken(VBAExpressionParser.WIDTH, 0); }
		public ITerminalNode CSNG() { return GetToken(VBAExpressionParser.CSNG, 0); }
		public ITerminalNode STEP() { return GetToken(VBAExpressionParser.STEP, 0); }
		public ITerminalNode BINARY() { return GetToken(VBAExpressionParser.BINARY, 0); }
		public ITerminalNode RANDOM() { return GetToken(VBAExpressionParser.RANDOM, 0); }
		public ITerminalNode CBOOL() { return GetToken(VBAExpressionParser.CBOOL, 0); }
		public ITerminalNode MIDBTYPESUFFIX() { return GetToken(VBAExpressionParser.MIDBTYPESUFFIX, 0); }
		public ITerminalNode SGN() { return GetToken(VBAExpressionParser.SGN, 0); }
		public ITerminalNode CBYTE() { return GetToken(VBAExpressionParser.CBYTE, 0); }
		public ITerminalNode CVERR() { return GetToken(VBAExpressionParser.CVERR, 0); }
		public ITerminalNode FIX() { return GetToken(VBAExpressionParser.FIX, 0); }
		public ITerminalNode CVAR() { return GetToken(VBAExpressionParser.CVAR, 0); }
		public ITerminalNode CSTR() { return GetToken(VBAExpressionParser.CSTR, 0); }
		public ITerminalNode CDATE() { return GetToken(VBAExpressionParser.CDATE, 0); }
		public ITerminalNode CINT() { return GetToken(VBAExpressionParser.CINT, 0); }
		public ITerminalNode ERROR() { return GetToken(VBAExpressionParser.ERROR, 0); }
		public ITerminalNode ABS() { return GetToken(VBAExpressionParser.ABS, 0); }
		public ITerminalNode READ() { return GetToken(VBAExpressionParser.READ, 0); }
		public ITerminalNode INT() { return GetToken(VBAExpressionParser.INT, 0); }
		public ITerminalNode LOCK_READ() { return GetToken(VBAExpressionParser.LOCK_READ, 0); }
		public ITerminalNode DOEVENTS() { return GetToken(VBAExpressionParser.DOEVENTS, 0); }
		public ITerminalNode OUTPUT() { return GetToken(VBAExpressionParser.OUTPUT, 0); }
		public ITerminalNode LINE_INPUT() { return GetToken(VBAExpressionParser.LINE_INPUT, 0); }
		public ITerminalNode MID() { return GetToken(VBAExpressionParser.MID, 0); }
		public ITerminalNode ACCESS() { return GetToken(VBAExpressionParser.ACCESS, 0); }
		public ITerminalNode EXIT_SUB() { return GetToken(VBAExpressionParser.EXIT_SUB, 0); }
		public ITerminalNode LOCK_READ_WRITE() { return GetToken(VBAExpressionParser.LOCK_READ_WRITE, 0); }
		public ITerminalNode MIDB() { return GetToken(VBAExpressionParser.MIDB, 0); }
		public ITerminalNode WRITE() { return GetToken(VBAExpressionParser.WRITE, 0); }
		public ITerminalNode LEN() { return GetToken(VBAExpressionParser.LEN, 0); }
		public ITerminalNode CCUR() { return GetToken(VBAExpressionParser.CCUR, 0); }
		public ITerminalNode EXIT_FOR() { return GetToken(VBAExpressionParser.EXIT_FOR, 0); }
		public ITerminalNode END_WITH() { return GetToken(VBAExpressionParser.END_WITH, 0); }
		public ITerminalNode EXIT_PROPERTY() { return GetToken(VBAExpressionParser.EXIT_PROPERTY, 0); }
		public ITerminalNode END() { return GetToken(VBAExpressionParser.END, 0); }
		public ITerminalNode PSET() { return GetToken(VBAExpressionParser.PSET, 0); }
		public ITerminalNode EXIT_FUNCTION() { return GetToken(VBAExpressionParser.EXIT_FUNCTION, 0); }
		public ITerminalNode READ_WRITE() { return GetToken(VBAExpressionParser.READ_WRITE, 0); }
		public ITerminalNode CDBL() { return GetToken(VBAExpressionParser.CDBL, 0); }
		public ITerminalNode CLNG() { return GetToken(VBAExpressionParser.CLNG, 0); }
		public ReservedProcedureNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedProcedureName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedProcedureName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedProcedureName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedProcedureName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedProcedureNameContext reservedProcedureName() {
		ReservedProcedureNameContext _localctx = new ReservedProcedureNameContext(_ctx, State);
		EnterRule(_localctx, 92, RULE_reservedProcedureName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 588;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABS) | (1L << CBOOL) | (1L << CBYTE) | (1L << CCUR) | (1L << CDATE) | (1L << CDBL) | (1L << CDEC) | (1L << CINT) | (1L << CLNG) | (1L << CLNGLNG) | (1L << CLNGPTR) | (1L << CSNG) | (1L << CSTR) | (1L << CVAR) | (1L << CVERR) | (1L << DEBUG) | (1L << DOEVENTS) | (1L << FIX) | (1L << INT) | (1L << LEN) | (1L << LENB) | (1L << MIDB) | (1L << MIDBTYPESUFFIX) | (1L << MIDTYPESUFFIX) | (1L << PSET) | (1L << SCALE) | (1L << SGN) | (1L << ACCESS) | (1L << APPEND) | (1L << BINARY))) != 0) || ((((_la - 94)) & ~0x3f) == 0 && ((1L << (_la - 94)) & ((1L << (END_SELECT - 94)) | (1L << (END_WITH - 94)) | (1L << (END - 94)) | (1L << (ERROR - 94)) | (1L << (EXIT_DO - 94)) | (1L << (EXIT_FOR - 94)) | (1L << (EXIT_FUNCTION - 94)) | (1L << (EXIT_PROPERTY - 94)) | (1L << (EXIT_SUB - 94)) | (1L << (LINE_INPUT - 94)) | (1L << (LOCK_READ - 94)) | (1L << (LOCK_WRITE - 94)) | (1L << (LOCK_READ_WRITE - 94)) | (1L << (MID - 94)) | (1L << (ON_ERROR - 94)) | (1L << (OUTPUT - 94)))) != 0) || ((((_la - 164)) & ~0x3f) == 0 && ((1L << (_la - 164)) & ((1L << (RANDOM - 164)) | (1L << (READ - 164)) | (1L << (READ_WRITE - 164)) | (1L << (RESET - 164)) | (1L << (SHARED - 164)) | (1L << (STEP - 164)) | (1L << (WIDTH - 164)) | (1L << (WRITE - 164)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SpecialFormContext : ParserRuleContext {
		public ITerminalNode INPUTB() { return GetToken(VBAExpressionParser.INPUTB, 0); }
		public ITerminalNode SCALE() { return GetToken(VBAExpressionParser.SCALE, 0); }
		public ITerminalNode ARRAY() { return GetToken(VBAExpressionParser.ARRAY, 0); }
		public ITerminalNode LBOUND() { return GetToken(VBAExpressionParser.LBOUND, 0); }
		public ITerminalNode UBOUND() { return GetToken(VBAExpressionParser.UBOUND, 0); }
		public ITerminalNode INPUT() { return GetToken(VBAExpressionParser.INPUT, 0); }
		public ITerminalNode CIRCLE() { return GetToken(VBAExpressionParser.CIRCLE, 0); }
		public SpecialFormContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_specialForm; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterSpecialForm(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitSpecialForm(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSpecialForm(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SpecialFormContext specialForm() {
		SpecialFormContext _localctx = new SpecialFormContext(_ctx, State);
		EnterRule(_localctx, 94, RULE_specialForm);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 590;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ARRAY) | (1L << CIRCLE) | (1L << INPUTB) | (1L << LBOUND) | (1L << SCALE) | (1L << UBOUND))) != 0) || _la==INPUT) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedTypeIdentifierContext : ParserRuleContext {
		public ITerminalNode INTEGER() { return GetToken(VBAExpressionParser.INTEGER, 0); }
		public ITerminalNode LONGLONG() { return GetToken(VBAExpressionParser.LONGLONG, 0); }
		public ITerminalNode VARIANT() { return GetToken(VBAExpressionParser.VARIANT, 0); }
		public ITerminalNode LONGPTR() { return GetToken(VBAExpressionParser.LONGPTR, 0); }
		public ITerminalNode BYTE() { return GetToken(VBAExpressionParser.BYTE, 0); }
		public ITerminalNode STRING() { return GetToken(VBAExpressionParser.STRING, 0); }
		public ITerminalNode BOOLEAN() { return GetToken(VBAExpressionParser.BOOLEAN, 0); }
		public ITerminalNode CURRENCY() { return GetToken(VBAExpressionParser.CURRENCY, 0); }
		public ITerminalNode DOUBLE() { return GetToken(VBAExpressionParser.DOUBLE, 0); }
		public ITerminalNode ANY() { return GetToken(VBAExpressionParser.ANY, 0); }
		public ITerminalNode LONG() { return GetToken(VBAExpressionParser.LONG, 0); }
		public ITerminalNode DATE() { return GetToken(VBAExpressionParser.DATE, 0); }
		public ITerminalNode SINGLE() { return GetToken(VBAExpressionParser.SINGLE, 0); }
		public ReservedTypeIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedTypeIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedTypeIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedTypeIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedTypeIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedTypeIdentifierContext reservedTypeIdentifier() {
		ReservedTypeIdentifierContext _localctx = new ReservedTypeIdentifierContext(_ctx, State);
		EnterRule(_localctx, 96, RULE_reservedTypeIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 592;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ANY) | (1L << CURRENCY) | (1L << LONGLONG) | (1L << LONGPTR) | (1L << BOOLEAN) | (1L << BYTE))) != 0) || ((((_la - 68)) & ~0x3f) == 0 && ((1L << (_la - 68)) & ((1L << (DATE - 68)) | (1L << (DOUBLE - 68)) | (1L << (INTEGER - 68)) | (1L << (LONG - 68)))) != 0) || ((((_la - 178)) & ~0x3f) == 0 && ((1L << (_la - 178)) & ((1L << (SINGLE - 178)) | (1L << (STRING - 178)) | (1L << (VARIANT - 178)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UncategorizedKeywordContext : ParserRuleContext {
		public ITerminalNode TAB() { return GetToken(VBAExpressionParser.TAB, 0); }
		public ITerminalNode LIB() { return GetToken(VBAExpressionParser.LIB, 0); }
		public ITerminalNode VERSION() { return GetToken(VBAExpressionParser.VERSION, 0); }
		public ITerminalNode ON() { return GetToken(VBAExpressionParser.ON, 0); }
		public ITerminalNode COLLECTION() { return GetToken(VBAExpressionParser.COLLECTION, 0); }
		public ITerminalNode ALIAS() { return GetToken(VBAExpressionParser.ALIAS, 0); }
		public ITerminalNode ATTRIBUTE() { return GetToken(VBAExpressionParser.ATTRIBUTE, 0); }
		public ITerminalNode BEGIN() { return GetToken(VBAExpressionParser.BEGIN, 0); }
		public ITerminalNode CLASS() { return GetToken(VBAExpressionParser.CLASS, 0); }
		public UncategorizedKeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_uncategorizedKeyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterUncategorizedKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitUncategorizedKeyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUncategorizedKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UncategorizedKeywordContext uncategorizedKeyword() {
		UncategorizedKeywordContext _localctx = new UncategorizedKeywordContext(_ctx, State);
		EnterRule(_localctx, 98, RULE_uncategorizedKeyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 594;
			_la = _input.La(1);
			if ( !(((((_la - 51)) & ~0x3f) == 0 && ((1L << (_la - 51)) & ((1L << (ALIAS - 51)) | (1L << (ATTRIBUTE - 51)) | (1L << (BEGIN - 51)) | (1L << (CLASS - 51)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (LIB - 128)) | (1L << (ON - 128)) | (1L << (TAB - 128)))) != 0) || _la==VERSION || _la==COLLECTION) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralIdentifierContext : ParserRuleContext {
		public ObjectLiteralIdentifierContext objectLiteralIdentifier() {
			return GetRuleContext<ObjectLiteralIdentifierContext>(0);
		}
		public BooleanLiteralIdentifierContext booleanLiteralIdentifier() {
			return GetRuleContext<BooleanLiteralIdentifierContext>(0);
		}
		public VariantLiteralIdentifierContext variantLiteralIdentifier() {
			return GetRuleContext<VariantLiteralIdentifierContext>(0);
		}
		public LiteralIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literalIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLiteralIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLiteralIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralIdentifierContext literalIdentifier() {
		LiteralIdentifierContext _localctx = new LiteralIdentifierContext(_ctx, State);
		EnterRule(_localctx, 100, RULE_literalIdentifier);
		try {
			State = 599;
			switch (_input.La(1)) {
			case FALSE:
			case TRUE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 596; booleanLiteralIdentifier();
				}
				break;
			case NOTHING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 597; objectLiteralIdentifier();
				}
				break;
			case EMPTY:
			case NULL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 598; variantLiteralIdentifier();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BooleanLiteralIdentifierContext : ParserRuleContext {
		public ITerminalNode FALSE() { return GetToken(VBAExpressionParser.FALSE, 0); }
		public ITerminalNode TRUE() { return GetToken(VBAExpressionParser.TRUE, 0); }
		public BooleanLiteralIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_booleanLiteralIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterBooleanLiteralIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitBooleanLiteralIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBooleanLiteralIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BooleanLiteralIdentifierContext booleanLiteralIdentifier() {
		BooleanLiteralIdentifierContext _localctx = new BooleanLiteralIdentifierContext(_ctx, State);
		EnterRule(_localctx, 102, RULE_booleanLiteralIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 601;
			_la = _input.La(1);
			if ( !(_la==FALSE || _la==TRUE) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectLiteralIdentifierContext : ParserRuleContext {
		public ITerminalNode NOTHING() { return GetToken(VBAExpressionParser.NOTHING, 0); }
		public ObjectLiteralIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectLiteralIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterObjectLiteralIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitObjectLiteralIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObjectLiteralIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ObjectLiteralIdentifierContext objectLiteralIdentifier() {
		ObjectLiteralIdentifierContext _localctx = new ObjectLiteralIdentifierContext(_ctx, State);
		EnterRule(_localctx, 104, RULE_objectLiteralIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 603; Match(NOTHING);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariantLiteralIdentifierContext : ParserRuleContext {
		public ITerminalNode NULL() { return GetToken(VBAExpressionParser.NULL, 0); }
		public ITerminalNode EMPTY() { return GetToken(VBAExpressionParser.EMPTY, 0); }
		public VariantLiteralIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variantLiteralIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterVariantLiteralIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitVariantLiteralIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariantLiteralIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariantLiteralIdentifierContext variantLiteralIdentifier() {
		VariantLiteralIdentifierContext _localctx = new VariantLiteralIdentifierContext(_ctx, State);
		EnterRule(_localctx, 106, RULE_variantLiteralIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 605;
			_la = _input.La(1);
			if ( !(_la==EMPTY || _la==NULL) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhiteSpaceContext : ParserRuleContext {
		public ITerminalNode WS(int i) {
			return GetToken(VBAExpressionParser.WS, i);
		}
		public IReadOnlyList<ITerminalNode> WS() { return GetTokens(VBAExpressionParser.WS); }
		public IReadOnlyList<ITerminalNode> LINE_CONTINUATION() { return GetTokens(VBAExpressionParser.LINE_CONTINUATION); }
		public ITerminalNode LINE_CONTINUATION(int i) {
			return GetToken(VBAExpressionParser.LINE_CONTINUATION, i);
		}
		public WhiteSpaceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whiteSpace; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterWhiteSpace(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitWhiteSpace(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhiteSpace(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhiteSpaceContext whiteSpace() {
		WhiteSpaceContext _localctx = new WhiteSpaceContext(_ctx, State);
		EnterRule(_localctx, 108, RULE_whiteSpace);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 608;
			_errHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 607;
					_la = _input.La(1);
					if ( !(_la==WS || _la==LINE_CONTINUATION) ) {
					_errHandler.RecoverInline(this);
					}
					Consume();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 610;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,86,_ctx);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 13: return expression_sempred((ExpressionContext)_localctx, predIndex);

		case 19: return lExpression_sempred((LExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(_ctx, 15);

		case 1: return Precpred(_ctx, 13);

		case 2: return Precpred(_ctx, 12);

		case 3: return Precpred(_ctx, 11);

		case 4: return Precpred(_ctx, 10);

		case 5: return Precpred(_ctx, 9);

		case 6: return Precpred(_ctx, 8);

		case 7: return Precpred(_ctx, 6);

		case 8: return Precpred(_ctx, 5);

		case 9: return Precpred(_ctx, 4);

		case 10: return Precpred(_ctx, 3);

		case 11: return Precpred(_ctx, 2);
		}
		return true;
	}
	private bool lExpression_sempred(LExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 16: return Precpred(_ctx, 5);

		case 17: return Precpred(_ctx, 4);

		case 12: return Precpred(_ctx, 9);

		case 13: return Precpred(_ctx, 8);

		case 14: return Precpred(_ctx, 7);

		case 15: return Precpred(_ctx, 6);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\xF3\x267\x4\x2"+
		"\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4"+
		"\t\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10"+
		"\t\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x4\x16\t\x16\x4\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B"+
		"\t\x1B\x4\x1C\t\x1C\x4\x1D\t\x1D\x4\x1E\t\x1E\x4\x1F\t\x1F\x4 \t \x4!"+
		"\t!\x4\"\t\"\x4#\t#\x4$\t$\x4%\t%\x4&\t&\x4\'\t\'\x4(\t(\x4)\t)\x4*\t"+
		"*\x4+\t+\x4,\t,\x4-\t-\x4.\t.\x4/\t/\x4\x30\t\x30\x4\x31\t\x31\x4\x32"+
		"\t\x32\x4\x33\t\x33\x4\x34\t\x34\x4\x35\t\x35\x4\x36\t\x36\x4\x37\t\x37"+
		"\x4\x38\t\x38\x3\x2\x3\x2\x5\x2s\n\x2\x3\x2\x3\x2\x3\x3\x3\x3\x3\x3\x5"+
		"\x3z\n\x3\x3\x3\x3\x3\x3\x3\x5\x3\x7F\n\x3\x3\x4\x3\x4\x5\x4\x83\n\x4"+
		"\x3\x5\x3\x5\x5\x5\x87\n\x5\x3\x6\x3\x6\x5\x6\x8B\n\x6\x3\a\x3\a\x3\b"+
		"\x3\b\x3\b\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x5\t\x9B\n\t\x3"+
		"\n\x3\n\x3\n\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x5\v\xA8\n\v\x3\f"+
		"\x3\f\x3\r\x3\r\x3\xE\x3\xE\x3\xE\x5\xE\xB1\n\xE\x3\xE\x3\xE\x5\xE\xB5"+
		"\n\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x5\xE\xBC\n\xE\x3\xE\x3\xE\x5\xE\xC0"+
		"\n\xE\x3\xE\x5\xE\xC3\n\xE\x3\xF\x3\xF\x3\xF\x5\xF\xC8\n\xF\x3\xF\x3\xF"+
		"\x3\xF\x5\xF\xCD\n\xF\x3\xF\x3\xF\x3\xF\x3\xF\x5\xF\xD3\n\xF\x3\xF\x3"+
		"\xF\x5\xF\xD7\n\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x5\xF\xDE\n\xF\x3\xF"+
		"\x3\xF\x5\xF\xE2\n\xF\x3\xF\x3\xF\x5\xF\xE6\n\xF\x3\xF\x3\xF\x3\xF\x5"+
		"\xF\xEB\n\xF\x3\xF\x3\xF\x5\xF\xEF\n\xF\x3\xF\x3\xF\x3\xF\x5\xF\xF4\n"+
		"\xF\x3\xF\x3\xF\x5\xF\xF8\n\xF\x3\xF\x3\xF\x3\xF\x5\xF\xFD\n\xF\x3\xF"+
		"\x3\xF\x5\xF\x101\n\xF\x3\xF\x3\xF\x3\xF\x5\xF\x106\n\xF\x3\xF\x3\xF\x5"+
		"\xF\x10A\n\xF\x3\xF\x3\xF\x3\xF\x5\xF\x10F\n\xF\x3\xF\x3\xF\x5\xF\x113"+
		"\n\xF\x3\xF\x3\xF\x3\xF\x5\xF\x118\n\xF\x3\xF\x3\xF\x5\xF\x11C\n\xF\x3"+
		"\xF\x3\xF\x3\xF\x5\xF\x121\n\xF\x3\xF\x3\xF\x5\xF\x125\n\xF\x3\xF\x3\xF"+
		"\x3\xF\x5\xF\x12A\n\xF\x3\xF\x3\xF\x5\xF\x12E\n\xF\x3\xF\x3\xF\x3\xF\x5"+
		"\xF\x133\n\xF\x3\xF\x3\xF\x5\xF\x137\n\xF\x3\xF\x3\xF\x3\xF\x5\xF\x13C"+
		"\n\xF\x3\xF\x3\xF\x5\xF\x140\n\xF\x3\xF\x3\xF\x3\xF\x5\xF\x145\n\xF\x3"+
		"\xF\x3\xF\x5\xF\x149\n\xF\x3\xF\a\xF\x14C\n\xF\f\xF\xE\xF\x14F\v\xF\x3"+
		"\x10\x3\x10\x3\x10\x3\x10\x3\x10\x5\x10\x156\n\x10\x5\x10\x158\n\x10\x3"+
		"\x11\x3\x11\x3\x12\x3\x12\x5\x12\x15E\n\x12\x3\x12\x3\x12\x5\x12\x162"+
		"\n\x12\x3\x12\x3\x12\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13"+
		"\x3\x13\x3\x14\x3\x14\x3\x14\x3\x14\x3\x15\x3\x15\x3\x15\x3\x15\x5\x15"+
		"\x176\n\x15\x3\x15\x3\x15\x5\x15\x17A\n\x15\x3\x15\x3\x15\x5\x15\x17E"+
		"\n\x15\x3\x15\x5\x15\x181\n\x15\x3\x15\x5\x15\x184\n\x15\x3\x15\x3\x15"+
		"\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x5\x15\x18D\n\x15\x3\x15\x3\x15\x3"+
		"\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3"+
		"\x15\x3\x15\a\x15\x19D\n\x15\f\x15\xE\x15\x1A0\v\x15\x3\x16\x3\x16\x3"+
		"\x16\x3\x16\x3\x16\x3\x16\x3\x16\x5\x16\x1A9\n\x16\x3\x16\x3\x16\x3\x16"+
		"\x5\x16\x1AE\n\x16\x3\x17\x3\x17\x5\x17\x1B2\n\x17\x3\x17\x3\x17\x5\x17"+
		"\x1B6\n\x17\x3\x17\x5\x17\x1B9\n\x17\x3\x17\x5\x17\x1BC\n\x17\x3\x17\x3"+
		"\x17\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3"+
		"\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x5\x18\x1CF\n\x18\x3\x19\x3\x19"+
		"\x3\x1A\x5\x1A\x1D4\n\x1A\x3\x1A\x5\x1A\x1D7\n\x1A\x3\x1A\x3\x1A\x5\x1A"+
		"\x1DB\n\x1A\a\x1A\x1DD\n\x1A\f\x1A\xE\x1A\x1E0\v\x1A\x3\x1A\x3\x1A\x5"+
		"\x1A\x1E4\n\x1A\x3\x1A\x5\x1A\x1E7\n\x1A\x3\x1A\x3\x1A\x5\x1A\x1EB\n\x1A"+
		"\a\x1A\x1ED\n\x1A\f\x1A\xE\x1A\x1F0\v\x1A\x3\x1A\x5\x1A\x1F3\n\x1A\x3"+
		"\x1B\x3\x1B\x3\x1C\x3\x1C\x3\x1D\x3\x1D\x5\x1D\x1FB\n\x1D\x3\x1D\x3\x1D"+
		"\x5\x1D\x1FF\n\x1D\x3\x1D\a\x1D\x202\n\x1D\f\x1D\xE\x1D\x205\v\x1D\x3"+
		"\x1E\x3\x1E\x5\x1E\x209\n\x1E\x3\x1E\x3\x1E\x5\x1E\x20D\n\x1E\x3\x1E\x3"+
		"\x1E\x3\x1F\x3\x1F\x5\x1F\x213\n\x1F\x3\x1F\x3\x1F\x5\x1F\x217\n\x1F\x3"+
		" \x3 \x3!\x3!\x3\"\x3\"\x5\"\x21F\n\"\x3#\x3#\x3#\x3$\x3$\x3$\x3%\x3%"+
		"\x3&\x3&\x5&\x22B\n&\x3\'\x3\'\x5\'\x22F\n\'\x3(\x3(\x3(\x3(\x3)\x3)\x5"+
		")\x237\n)\x3*\x3*\x3*\x3*\x3*\x3*\x3*\x3*\x5*\x241\n*\x3+\x3+\x3,\x3,"+
		"\x3-\x3-\x3.\x3.\x3/\x3/\x5/\x24D\n/\x3\x30\x3\x30\x3\x31\x3\x31\x3\x32"+
		"\x3\x32\x3\x33\x3\x33\x3\x34\x3\x34\x3\x34\x5\x34\x25A\n\x34\x3\x35\x3"+
		"\x35\x3\x36\x3\x36\x3\x37\x3\x37\x3\x38\x6\x38\x263\n\x38\r\x38\xE\x38"+
		"\x264\x3\x38\x2\x2\x4\x1C(\x39\x2\x2\x4\x2\x6\x2\b\x2\n\x2\f\x2\xE\x2"+
		"\x10\x2\x12\x2\x14\x2\x16\x2\x18\x2\x1A\x2\x1C\x2\x1E\x2 \x2\"\x2$\x2"+
		"&\x2(\x2*\x2,\x2.\x2\x30\x2\x32\x2\x34\x2\x36\x2\x38\x2:\x2<\x2>\x2@\x2"+
		"\x42\x2\x44\x2\x46\x2H\x2J\x2L\x2N\x2P\x2R\x2T\x2V\x2X\x2Z\x2\\\x2^\x2"+
		"`\x2\x62\x2\x64\x2\x66\x2h\x2j\x2l\x2n\x2\x2\x12\x5\x2,,.\x32\xDA\xDA"+
		"\x5\x2;;\x45\x45\xBC\xBC\x4\x2\xCE\xCE\xD7\xD7\x4\x2\xD6\xD6\xD9\xD9\a"+
		"\x2||\x83\x83\xD0\xD3\xD5\xD5\xD8\xD8\x3\x2\xE4\xE7\"\x2\x18\x18$$@\x41"+
		"\x43\x44GVYZ^^\x65\x65ggiipwyy{{~~\x80\x81\x88\x88\x8C\x8C\x91\x91\x94"+
		"\x94\x9E\x9F\xA4\xA5\xA7\xA7\xAA\xAA\xAD\xB2\xB6\xB6\xB8\xB8\xBA\xBA\xC0"+
		"\xC0\xC2\xC2\xC6\xC7\xC9\xC9\xCB\xCB\x11\x2\x4\x4\x39\x39=>\x41\x41XY"+
		"zz\x8D\x8D\x95\x95\x9C\x9D\xB3\xB3\xB5\xB5\xBB\xBB\xBD\xBE\xC3\xC3\xCA"+
		"\xCB\r\x2\x34\x34\x36\x36\x66\x66xx||\x83\x83\x8B\x8B\x8D\x8E\x9A\x9A"+
		"\xC1\xC1\xCC\xCC\x1D\x2\x3\x3\x6\f\xE\x12\x14\x17\x19\x19\x1B\x1B\x1D"+
		"\x1E!#%\'\x33\x33\x38\x38;;``\x63\x64hhjn\x84\x87\x8A\x8A\x92\x92\x9B"+
		"\x9B\xA6\xA6\xA8\xA9\xAC\xAC\xB3\xB3\xB7\xB7\xC8\xC8\xCB\xCB\t\x2\x5\x5"+
		"\r\r\x1A\x1A\x1C\x1C&&(({{\xE\x2\x4\x4\x13\x13\x1F <<??\x46\x46WW}}\x7F"+
		"\x7F\xB4\xB4\xB9\xB9\xC4\xC4\v\x2\x35\x35\x37\x37::\x42\x42\x82\x82\x91"+
		"\x91\xBB\xBB\xC5\xC5\xF3\xF3\x4\x2oo\xBF\xBF\x4\x2[[\x90\x90\x4\x2\xEC"+
		"\xEC\xEF\xEF\x2B4\x2r\x3\x2\x2\x2\x4y\x3\x2\x2\x2\x6\x82\x3\x2\x2\x2\b"+
		"\x86\x3\x2\x2\x2\n\x8A\x3\x2\x2\x2\f\x8C\x3\x2\x2\x2\xE\x8E\x3\x2\x2\x2"+
		"\x10\x9A\x3\x2\x2\x2\x12\x9C\x3\x2\x2\x2\x14\xA7\x3\x2\x2\x2\x16\xA9\x3"+
		"\x2\x2\x2\x18\xAB\x3\x2\x2\x2\x1A\xC2\x3\x2\x2\x2\x1C\xDD\x3\x2\x2\x2"+
		"\x1E\x157\x3\x2\x2\x2 \x159\x3\x2\x2\x2\"\x15B\x3\x2\x2\x2$\x165\x3\x2"+
		"\x2\x2&\x16D\x3\x2\x2\x2(\x175\x3\x2\x2\x2*\x1AD\x3\x2\x2\x2,\x1AF\x3"+
		"\x2\x2\x2.\x1CE\x3\x2\x2\x2\x30\x1D0\x3\x2\x2\x2\x32\x1F2\x3\x2\x2\x2"+
		"\x34\x1F4\x3\x2\x2\x2\x36\x1F6\x3\x2\x2\x2\x38\x1F8\x3\x2\x2\x2:\x206"+
		"\x3\x2\x2\x2<\x216\x3\x2\x2\x2>\x218\x3\x2\x2\x2@\x21A\x3\x2\x2\x2\x42"+
		"\x21E\x3\x2\x2\x2\x44\x220\x3\x2\x2\x2\x46\x223\x3\x2\x2\x2H\x226\x3\x2"+
		"\x2\x2J\x22A\x3\x2\x2\x2L\x22E\x3\x2\x2\x2N\x230\x3\x2\x2\x2P\x236\x3"+
		"\x2\x2\x2R\x240\x3\x2\x2\x2T\x242\x3\x2\x2\x2V\x244\x3\x2\x2\x2X\x246"+
		"\x3\x2\x2\x2Z\x248\x3\x2\x2\x2\\\x24C\x3\x2\x2\x2^\x24E\x3\x2\x2\x2`\x250"+
		"\x3\x2\x2\x2\x62\x252\x3\x2\x2\x2\x64\x254\x3\x2\x2\x2\x66\x259\x3\x2"+
		"\x2\x2h\x25B\x3\x2\x2\x2j\x25D\x3\x2\x2\x2l\x25F\x3\x2\x2\x2n\x262\x3"+
		"\x2\x2\x2ps\x5\x1C\xF\x2qs\x5\x4\x3\x2rp\x3\x2\x2\x2rq\x3\x2\x2\x2st\x3"+
		"\x2\x2\x2tu\a\x2\x2\x3u\x3\x3\x2\x2\x2vz\x5*\x16\x2wz\x5> \x2xz\x5\x42"+
		"\"\x2yv\x3\x2\x2\x2yw\x3\x2\x2\x2yx\x3\x2\x2\x2z~\x3\x2\x2\x2{|\x5n\x38"+
		"\x2|}\x5\x30\x19\x2}\x7F\x3\x2\x2\x2~{\x3\x2\x2\x2~\x7F\x3\x2\x2\x2\x7F"+
		"\x5\x3\x2\x2\x2\x80\x83\x5\b\x5\x2\x81\x83\x5\n\x6\x2\x82\x80\x3\x2\x2"+
		"\x2\x82\x81\x3\x2\x2\x2\x83\a\x3\x2\x2\x2\x84\x87\x5\x10\t\x2\x85\x87"+
		"\x5\x12\n\x2\x86\x84\x3\x2\x2\x2\x86\x85\x3\x2\x2\x2\x87\t\x3\x2\x2\x2"+
		"\x88\x8B\x5\f\a\x2\x89\x8B\x5\xE\b\x2\x8A\x88\x3\x2\x2\x2\x8A\x89\x3\x2"+
		"\x2\x2\x8B\v\x3\x2\x2\x2\x8C\x8D\x5R*\x2\x8D\r\x3\x2\x2\x2\x8E\x8F\x5"+
		"R*\x2\x8F\x90\x5\x16\f\x2\x90\xF\x3\x2\x2\x2\x91\x9B\a\xEE\x2\x2\x92\x9B"+
		"\a\xF1\x2\x2\x93\x9B\x5^\x30\x2\x94\x9B\x5`\x31\x2\x95\x9B\x5\x18\r\x2"+
		"\x96\x9B\a\xF2\x2\x2\x97\x9B\x5\x64\x33\x2\x98\x9B\ah\x2\x2\x99\x9B\x5"+
		"\x62\x32\x2\x9A\x91\x3\x2\x2\x2\x9A\x92\x3\x2\x2\x2\x9A\x93\x3\x2\x2\x2"+
		"\x9A\x94\x3\x2\x2\x2\x9A\x95\x3\x2\x2\x2\x9A\x96\x3\x2\x2\x2\x9A\x97\x3"+
		"\x2\x2\x2\x9A\x98\x3\x2\x2\x2\x9A\x99\x3\x2\x2\x2\x9B\x11\x3\x2\x2\x2"+
		"\x9C\x9D\x5\x14\v\x2\x9D\x9E\x5\x16\f\x2\x9E\x13\x3\x2\x2\x2\x9F\xA8\a"+
		"\xEE\x2\x2\xA0\xA8\x5^\x30\x2\xA1\xA8\x5`\x31\x2\xA2\xA8\x5\x18\r\x2\xA3"+
		"\xA8\a\xF2\x2\x2\xA4\xA8\x5\x64\x33\x2\xA5\xA8\ah\x2\x2\xA6\xA8\x5\x62"+
		"\x32\x2\xA7\x9F\x3\x2\x2\x2\xA7\xA0\x3\x2\x2\x2\xA7\xA1\x3\x2\x2\x2\xA7"+
		"\xA2\x3\x2\x2\x2\xA7\xA3\x3\x2\x2\x2\xA7\xA4\x3\x2\x2\x2\xA7\xA5\x3\x2"+
		"\x2\x2\xA7\xA6\x3\x2\x2\x2\xA8\x15\x3\x2\x2\x2\xA9\xAA\t\x2\x2\x2\xAA"+
		"\x17\x3\x2\x2\x2\xAB\xAC\t\x3\x2\x2\xAC\x19\x3\x2\x2\x2\xAD\xC3\x5\x62"+
		"\x32\x2\xAE\xB0\a\xE1\x2\x2\xAF\xB1\x5n\x38\x2\xB0\xAF\x3\x2\x2\x2\xB0"+
		"\xB1\x3\x2\x2\x2\xB1\xB2\x3\x2\x2\x2\xB2\xB4\x5\x62\x32\x2\xB3\xB5\x5"+
		"n\x38\x2\xB4\xB3\x3\x2\x2\x2\xB4\xB5\x3\x2\x2\x2\xB5\xB6\x3\x2\x2\x2\xB6"+
		"\xB7\a\xE2\x2\x2\xB7\xC3\x3\x2\x2\x2\xB8\xC3\a\xF2\x2\x2\xB9\xBB\a\xE1"+
		"\x2\x2\xBA\xBC\x5n\x38\x2\xBB\xBA\x3\x2\x2\x2\xBB\xBC\x3\x2\x2\x2\xBC"+
		"\xBD\x3\x2\x2\x2\xBD\xBF\a\xF2\x2\x2\xBE\xC0\x5n\x38\x2\xBF\xBE\x3\x2"+
		"\x2\x2\xBF\xC0\x3\x2\x2\x2\xC0\xC1\x3\x2\x2\x2\xC1\xC3\a\xE2\x2\x2\xC2"+
		"\xAD\x3\x2\x2\x2\xC2\xAE\x3\x2\x2\x2\xC2\xB8\x3\x2\x2\x2\xC2\xB9\x3\x2"+
		"\x2\x2\xC3\x1B\x3\x2\x2\x2\xC4\xC5\b\xF\x1\x2\xC5\xC7\a\xD6\x2\x2\xC6"+
		"\xC8\x5n\x38\x2\xC7\xC6\x3\x2\x2\x2\xC7\xC8\x3\x2\x2\x2\xC8\xC9\x3\x2"+
		"\x2\x2\xC9\xDE\x5\x1C\xF\x10\xCA\xCC\a\x8E\x2\x2\xCB\xCD\x5n\x38\x2\xCC"+
		"\xCB\x3\x2\x2\x2\xCC\xCD\x3\x2\x2\x2\xCD\xCE\x3\x2\x2\x2\xCE\xDE\x5\x1C"+
		"\xF\t\xCF\xDE\x5(\x15\x2\xD0\xD2\a\xD4\x2\x2\xD1\xD3\x5n\x38\x2\xD2\xD1"+
		"\x3\x2\x2\x2\xD2\xD3\x3\x2\x2\x2\xD3\xD4\x3\x2\x2\x2\xD4\xD6\x5\x1C\xF"+
		"\x2\xD5\xD7\x5n\x38\x2\xD6\xD5\x3\x2\x2\x2\xD6\xD7\x3\x2\x2\x2\xD7\xD8"+
		"\x3\x2\x2\x2\xD8\xD9\a\xDB\x2\x2\xD9\xDE\x3\x2\x2\x2\xDA\xDE\x5$\x13\x2"+
		"\xDB\xDE\x5&\x14\x2\xDC\xDE\x5\x1E\x10\x2\xDD\xC4\x3\x2\x2\x2\xDD\xCA"+
		"\x3\x2\x2\x2\xDD\xCF\x3\x2\x2\x2\xDD\xD0\x3\x2\x2\x2\xDD\xDA\x3\x2\x2"+
		"\x2\xDD\xDB\x3\x2\x2\x2\xDD\xDC\x3\x2\x2\x2\xDE\x14D\x3\x2\x2\x2\xDF\xE1"+
		"\f\x11\x2\x2\xE0\xE2\x5n\x38\x2\xE1\xE0\x3\x2\x2\x2\xE1\xE2\x3\x2\x2\x2"+
		"\xE2\xE3\x3\x2\x2\x2\xE3\xE5\a\xDA\x2\x2\xE4\xE6\x5n\x38\x2\xE5\xE4\x3"+
		"\x2\x2\x2\xE5\xE6\x3\x2\x2\x2\xE6\xE7\x3\x2\x2\x2\xE7\x14C\x5\x1C\xF\x12"+
		"\xE8\xEA\f\xF\x2\x2\xE9\xEB\x5n\x38\x2\xEA\xE9\x3\x2\x2\x2\xEA\xEB\x3"+
		"\x2\x2\x2\xEB\xEC\x3\x2\x2\x2\xEC\xEE\t\x4\x2\x2\xED\xEF\x5n\x38\x2\xEE"+
		"\xED\x3\x2\x2\x2\xEE\xEF\x3\x2\x2\x2\xEF\xF0\x3\x2\x2\x2\xF0\x14C\x5\x1C"+
		"\xF\x10\xF1\xF3\f\xE\x2\x2\xF2\xF4\x5n\x38\x2\xF3\xF2\x3\x2\x2\x2\xF3"+
		"\xF4\x3\x2\x2\x2\xF4\xF5\x3\x2\x2\x2\xF5\xF7\a\xCF\x2\x2\xF6\xF8\x5n\x38"+
		"\x2\xF7\xF6\x3\x2\x2\x2\xF7\xF8\x3\x2\x2\x2\xF8\xF9\x3\x2\x2\x2\xF9\x14C"+
		"\x5\x1C\xF\xF\xFA\xFC\f\r\x2\x2\xFB\xFD\x5n\x38\x2\xFC\xFB\x3\x2\x2\x2"+
		"\xFC\xFD\x3\x2\x2\x2\xFD\xFE\x3\x2\x2\x2\xFE\x100\a\x8B\x2\x2\xFF\x101"+
		"\x5n\x38\x2\x100\xFF\x3\x2\x2\x2\x100\x101\x3\x2\x2\x2\x101\x102\x3\x2"+
		"\x2\x2\x102\x14C\x5\x1C\xF\xE\x103\x105\f\f\x2\x2\x104\x106\x5n\x38\x2"+
		"\x105\x104\x3\x2\x2\x2\x105\x106\x3\x2\x2\x2\x106\x107\x3\x2\x2\x2\x107"+
		"\x109\t\x5\x2\x2\x108\x10A\x5n\x38\x2\x109\x108\x3\x2\x2\x2\x109\x10A"+
		"\x3\x2\x2\x2\x10A\x10B\x3\x2\x2\x2\x10B\x14C\x5\x1C\xF\r\x10C\x10E\f\v"+
		"\x2\x2\x10D\x10F\x5n\x38\x2\x10E\x10D\x3\x2\x2\x2\x10E\x10F\x3\x2\x2\x2"+
		"\x10F\x110\x3\x2\x2\x2\x110\x112\a\x32\x2\x2\x111\x113\x5n\x38\x2\x112"+
		"\x111\x3\x2\x2\x2\x112\x113\x3\x2\x2\x2\x113\x114\x3\x2\x2\x2\x114\x14C"+
		"\x5\x1C\xF\f\x115\x117\f\n\x2\x2\x116\x118\x5n\x38\x2\x117\x116\x3\x2"+
		"\x2\x2\x117\x118\x3\x2\x2\x2\x118\x119\x3\x2\x2\x2\x119\x11B\t\x6\x2\x2"+
		"\x11A\x11C\x5n\x38\x2\x11B\x11A\x3\x2\x2\x2\x11B\x11C\x3\x2\x2\x2\x11C"+
		"\x11D\x3\x2\x2\x2\x11D\x14C\x5\x1C\xF\v\x11E\x120\f\b\x2\x2\x11F\x121"+
		"\x5n\x38\x2\x120\x11F\x3\x2\x2\x2\x120\x121\x3\x2\x2\x2\x121\x122\x3\x2"+
		"\x2\x2\x122\x124\a\x36\x2\x2\x123\x125\x5n\x38\x2\x124\x123\x3\x2\x2\x2"+
		"\x124\x125\x3\x2\x2\x2\x125\x126\x3\x2\x2\x2\x126\x14C\x5\x1C\xF\t\x127"+
		"\x129\f\a\x2\x2\x128\x12A\x5n\x38\x2\x129\x128\x3\x2\x2\x2\x129\x12A\x3"+
		"\x2\x2\x2\x12A\x12B\x3\x2\x2\x2\x12B\x12D\a\x9A\x2\x2\x12C\x12E\x5n\x38"+
		"\x2\x12D\x12C\x3\x2\x2\x2\x12D\x12E\x3\x2\x2\x2\x12E\x12F\x3\x2\x2\x2"+
		"\x12F\x14C\x5\x1C\xF\b\x130\x132\f\x6\x2\x2\x131\x133\x5n\x38\x2\x132"+
		"\x131\x3\x2\x2\x2\x132\x133\x3\x2\x2\x2\x133\x134\x3\x2\x2\x2\x134\x136"+
		"\a\xCC\x2\x2\x135\x137\x5n\x38\x2\x136\x135\x3\x2\x2\x2\x136\x137\x3\x2"+
		"\x2\x2\x137\x138\x3\x2\x2\x2\x138\x14C\x5\x1C\xF\a\x139\x13B\f\x5\x2\x2"+
		"\x13A\x13C\x5n\x38\x2\x13B\x13A\x3\x2\x2\x2\x13B\x13C\x3\x2\x2\x2\x13C"+
		"\x13D\x3\x2\x2\x2\x13D\x13F\a\x66\x2\x2\x13E\x140\x5n\x38\x2\x13F\x13E"+
		"\x3\x2\x2\x2\x13F\x140\x3\x2\x2\x2\x140\x141\x3\x2\x2\x2\x141\x14C\x5"+
		"\x1C\xF\x6\x142\x144\f\x4\x2\x2\x143\x145\x5n\x38\x2\x144\x143\x3\x2\x2"+
		"\x2\x144\x145\x3\x2\x2\x2\x145\x146\x3\x2\x2\x2\x146\x148\ax\x2\x2\x147"+
		"\x149\x5n\x38\x2\x148\x147\x3\x2\x2\x2\x148\x149\x3\x2\x2\x2\x149\x14A"+
		"\x3\x2\x2\x2\x14A\x14C\x5\x1C\xF\x5\x14B\xDF\x3\x2\x2\x2\x14B\xE8\x3\x2"+
		"\x2\x2\x14B\xF1\x3\x2\x2\x2\x14B\xFA\x3\x2\x2\x2\x14B\x103\x3\x2\x2\x2"+
		"\x14B\x10C\x3\x2\x2\x2\x14B\x115\x3\x2\x2\x2\x14B\x11E\x3\x2\x2\x2\x14B"+
		"\x127\x3\x2\x2\x2\x14B\x130\x3\x2\x2\x2\x14B\x139\x3\x2\x2\x2\x14B\x142"+
		"\x3\x2\x2\x2\x14C\x14F\x3\x2\x2\x2\x14D\x14B\x3\x2\x2\x2\x14D\x14E\x3"+
		"\x2\x2\x2\x14E\x1D\x3\x2\x2\x2\x14F\x14D\x3\x2\x2\x2\x150\x158\x5 \x11"+
		"\x2\x151\x158\a\xE8\x2\x2\x152\x158\a\xE3\x2\x2\x153\x155\x5\x66\x34\x2"+
		"\x154\x156\x5\x16\f\x2\x155\x154\x3\x2\x2\x2\x155\x156\x3\x2\x2\x2\x156"+
		"\x158\x3\x2\x2\x2\x157\x150\x3\x2\x2\x2\x157\x151\x3\x2\x2\x2\x157\x152"+
		"\x3\x2\x2\x2\x157\x153\x3\x2\x2\x2\x158\x1F\x3\x2\x2\x2\x159\x15A\t\a"+
		"\x2\x2\x15A!\x3\x2\x2\x2\x15B\x15D\a\xD4\x2\x2\x15C\x15E\x5n\x38\x2\x15D"+
		"\x15C\x3\x2\x2\x2\x15D\x15E\x3\x2\x2\x2\x15E\x15F\x3\x2\x2\x2\x15F\x161"+
		"\x5\x1C\xF\x2\x160\x162\x5n\x38\x2\x161\x160\x3\x2\x2\x2\x161\x162\x3"+
		"\x2\x2\x2\x162\x163\x3\x2\x2\x2\x163\x164\a\xDB\x2\x2\x164#\x3\x2\x2\x2"+
		"\x165\x166\a\xC1\x2\x2\x166\x167\x5n\x38\x2\x167\x168\x5\x1C\xF\x2\x168"+
		"\x169\x5n\x38\x2\x169\x16A\a|\x2\x2\x16A\x16B\x5n\x38\x2\x16B\x16C\x5"+
		"J&\x2\x16C%\x3\x2\x2\x2\x16D\x16E\a\x8D\x2\x2\x16E\x16F\x5n\x38\x2\x16F"+
		"\x170\x5J&\x2\x170\'\x3\x2\x2\x2\x171\x172\b\x15\x1\x2\x172\x176\x5@!"+
		"\x2\x173\x176\x5> \x2\x174\x176\x5\x42\"\x2\x175\x171\x3\x2\x2\x2\x175"+
		"\x173\x3\x2\x2\x2\x175\x174\x3\x2\x2\x2\x176\x19E\x3\x2\x2\x2\x177\x179"+
		"\f\v\x2\x2\x178\x17A\x5n\x38\x2\x179\x178\x3\x2\x2\x2\x179\x17A\x3\x2"+
		"\x2\x2\x17A\x17B\x3\x2\x2\x2\x17B\x17D\a\xD4\x2\x2\x17C\x17E\x5n\x38\x2"+
		"\x17D\x17C\x3\x2\x2\x2\x17D\x17E\x3\x2\x2\x2\x17E\x180\x3\x2\x2\x2\x17F"+
		"\x181\x5\x30\x19\x2\x180\x17F\x3\x2\x2\x2\x180\x181\x3\x2\x2\x2\x181\x183"+
		"\x3\x2\x2\x2\x182\x184\x5n\x38\x2\x183\x182\x3\x2\x2\x2\x183\x184\x3\x2"+
		"\x2\x2\x184\x185\x3\x2\x2\x2\x185\x19D\a\xDB\x2\x2\x186\x187\f\n\x2\x2"+
		"\x187\x188\a-\x2\x2\x188\x19D\x5\x6\x4\x2\x189\x18A\f\t\x2\x2\x18A\x18C"+
		"\a\xEF\x2\x2\x18B\x18D\x5n\x38\x2\x18C\x18B\x3\x2\x2\x2\x18C\x18D\x3\x2"+
		"\x2\x2\x18D\x18E\x3\x2\x2\x2\x18E\x18F\a-\x2\x2\x18F\x19D\x5\x6\x4\x2"+
		"\x190\x191\f\b\x2\x2\x191\x192\a,\x2\x2\x192\x19D\x5\x6\x4\x2\x193\x194"+
		"\f\a\x2\x2\x194\x195\a\xEF\x2\x2\x195\x196\a,\x2\x2\x196\x19D\x5\x6\x4"+
		"\x2\x197\x198\f\x6\x2\x2\x198\x199\a\xEF\x2\x2\x199\x19A\a,\x2\x2\x19A"+
		"\x19B\a\xEF\x2\x2\x19B\x19D\x5\x6\x4\x2\x19C\x177\x3\x2\x2\x2\x19C\x186"+
		"\x3\x2\x2\x2\x19C\x189\x3\x2\x2\x2\x19C\x190\x3\x2\x2\x2\x19C\x193\x3"+
		"\x2\x2\x2\x19C\x197\x3\x2\x2\x2\x19D\x1A0\x3\x2\x2\x2\x19E\x19C\x3\x2"+
		"\x2\x2\x19E\x19F\x3\x2\x2\x2\x19F)\x3\x2\x2\x2\x1A0\x19E\x3\x2\x2\x2\x1A1"+
		"\x1A2\x5(\x15\x2\x1A2\x1A3\a-\x2\x2\x1A3\x1A4\x5\x6\x4\x2\x1A4\x1AE\x3"+
		"\x2\x2\x2\x1A5\x1A6\x5(\x15\x2\x1A6\x1A8\a\xEF\x2\x2\x1A7\x1A9\x5n\x38"+
		"\x2\x1A8\x1A7\x3\x2\x2\x2\x1A8\x1A9\x3\x2\x2\x2\x1A9\x1AA\x3\x2\x2\x2"+
		"\x1AA\x1AB\a-\x2\x2\x1AB\x1AC\x5\x6\x4\x2\x1AC\x1AE\x3\x2\x2\x2\x1AD\x1A1"+
		"\x3\x2\x2\x2\x1AD\x1A5\x3\x2\x2\x2\x1AE+\x3\x2\x2\x2\x1AF\x1B1\x5(\x15"+
		"\x2\x1B0\x1B2\x5n\x38\x2\x1B1\x1B0\x3\x2\x2\x2\x1B1\x1B2\x3\x2\x2\x2\x1B2"+
		"\x1B3\x3\x2\x2\x2\x1B3\x1B5\a\xD4\x2\x2\x1B4\x1B6\x5n\x38\x2\x1B5\x1B4"+
		"\x3\x2\x2\x2\x1B5\x1B6\x3\x2\x2\x2\x1B6\x1B8\x3\x2\x2\x2\x1B7\x1B9\x5"+
		"\x30\x19\x2\x1B8\x1B7\x3\x2\x2\x2\x1B8\x1B9\x3\x2\x2\x2\x1B9\x1BB\x3\x2"+
		"\x2\x2\x1BA\x1BC\x5n\x38\x2\x1BB\x1BA\x3\x2\x2\x2\x1BB\x1BC\x3\x2\x2\x2"+
		"\x1BC\x1BD\x3\x2\x2\x2\x1BD\x1BE\a\xDB\x2\x2\x1BE-\x3\x2\x2\x2\x1BF\x1C0"+
		"\x5(\x15\x2\x1C0\x1C1\a,\x2\x2\x1C1\x1C2\x5\x6\x4\x2\x1C2\x1CF\x3\x2\x2"+
		"\x2\x1C3\x1C4\x5(\x15\x2\x1C4\x1C5\a\xEF\x2\x2\x1C5\x1C6\a,\x2\x2\x1C6"+
		"\x1C7\x5\x6\x4\x2\x1C7\x1CF\x3\x2\x2\x2\x1C8\x1C9\x5(\x15\x2\x1C9\x1CA"+
		"\a\xEF\x2\x2\x1CA\x1CB\a,\x2\x2\x1CB\x1CC\a\xEF\x2\x2\x1CC\x1CD\x5\x6"+
		"\x4\x2\x1CD\x1CF\x3\x2\x2\x2\x1CE\x1BF\x3\x2\x2\x2\x1CE\x1C3\x3\x2\x2"+
		"\x2\x1CE\x1C8\x3\x2\x2\x2\x1CF/\x3\x2\x2\x2\x1D0\x1D1\x5\x32\x1A\x2\x1D1"+
		"\x31\x3\x2\x2\x2\x1D2\x1D4\x5\x34\x1B\x2\x1D3\x1D2\x3\x2\x2\x2\x1D3\x1D4"+
		"\x3\x2\x2\x2\x1D4\x1D6\x3\x2\x2\x2\x1D5\x1D7\x5n\x38\x2\x1D6\x1D5\x3\x2"+
		"\x2\x2\x1D6\x1D7\x3\x2\x2\x2\x1D7\x1D8\x3\x2\x2\x2\x1D8\x1DA\a)\x2\x2"+
		"\x1D9\x1DB\x5n\x38\x2\x1DA\x1D9\x3\x2\x2\x2\x1DA\x1DB\x3\x2\x2\x2\x1DB"+
		"\x1DD\x3\x2\x2\x2\x1DC\x1D3\x3\x2\x2\x2\x1DD\x1E0\x3\x2\x2\x2\x1DE\x1DC"+
		"\x3\x2\x2\x2\x1DE\x1DF\x3\x2\x2\x2\x1DF\x1E1\x3\x2\x2\x2\x1E0\x1DE\x3"+
		"\x2\x2\x2\x1E1\x1F3\x5\x36\x1C\x2\x1E2\x1E4\x5\x34\x1B\x2\x1E3\x1E2\x3"+
		"\x2\x2\x2\x1E3\x1E4\x3\x2\x2\x2\x1E4\x1E6\x3\x2\x2\x2\x1E5\x1E7\x5n\x38"+
		"\x2\x1E6\x1E5\x3\x2\x2\x2\x1E6\x1E7\x3\x2\x2\x2\x1E7\x1E8\x3\x2\x2\x2"+
		"\x1E8\x1EA\a)\x2\x2\x1E9\x1EB\x5n\x38\x2\x1EA\x1E9\x3\x2\x2\x2\x1EA\x1EB"+
		"\x3\x2\x2\x2\x1EB\x1ED\x3\x2\x2\x2\x1EC\x1E3\x3\x2\x2\x2\x1ED\x1F0\x3"+
		"\x2\x2\x2\x1EE\x1EC\x3\x2\x2\x2\x1EE\x1EF\x3\x2\x2\x2\x1EF\x1F1\x3\x2"+
		"\x2\x2\x1F0\x1EE\x3\x2\x2\x2\x1F1\x1F3\x5\x38\x1D\x2\x1F2\x1DE\x3\x2\x2"+
		"\x2\x1F2\x1EE\x3\x2\x2\x2\x1F3\x33\x3\x2\x2\x2\x1F4\x1F5\x5<\x1F\x2\x1F5"+
		"\x35\x3\x2\x2\x2\x1F6\x1F7\x5<\x1F\x2\x1F7\x37\x3\x2\x2\x2\x1F8\x203\x5"+
		":\x1E\x2\x1F9\x1FB\x5n\x38\x2\x1FA\x1F9\x3\x2\x2\x2\x1FA\x1FB\x3\x2\x2"+
		"\x2\x1FB\x1FC\x3\x2\x2\x2\x1FC\x1FE\a)\x2\x2\x1FD\x1FF\x5n\x38\x2\x1FE"+
		"\x1FD\x3\x2\x2\x2\x1FE\x1FF\x3\x2\x2\x2\x1FF\x200\x3\x2\x2\x2\x200\x202"+
		"\x5:\x1E\x2\x201\x1FA\x3\x2\x2\x2\x202\x205\x3\x2\x2\x2\x203\x201\x3\x2"+
		"\x2\x2\x203\x204\x3\x2\x2\x2\x204\x39\x3\x2\x2\x2\x205\x203\x3\x2\x2\x2"+
		"\x206\x208\x5\x6\x4\x2\x207\x209\x5n\x38\x2\x208\x207\x3\x2\x2\x2\x208"+
		"\x209\x3\x2\x2\x2\x209\x20A\x3\x2\x2\x2\x20A\x20C\a\xCD\x2\x2\x20B\x20D"+
		"\x5n\x38\x2\x20C\x20B\x3\x2\x2\x2\x20C\x20D\x3\x2\x2\x2\x20D\x20E\x3\x2"+
		"\x2\x2\x20E\x20F\x5<\x1F\x2\x20F;\x3\x2\x2\x2\x210\x211\a=\x2\x2\x211"+
		"\x213\x5n\x38\x2\x212\x210\x3\x2\x2\x2\x212\x213\x3\x2\x2\x2\x213\x214"+
		"\x3\x2\x2\x2\x214\x217\x5\x1C\xF\x2\x215\x217\x5N(\x2\x216\x212\x3\x2"+
		"\x2\x2\x216\x215\x3\x2\x2\x2\x217=\x3\x2\x2\x2\x218\x219\x5\b\x5\x2\x219"+
		"?\x3\x2\x2\x2\x21A\x21B\a\x89\x2\x2\x21B\x41\x3\x2\x2\x2\x21C\x21F\x5"+
		"\x44#\x2\x21D\x21F\x5\x46$\x2\x21E\x21C\x3\x2\x2\x2\x21E\x21D\x3\x2\x2"+
		"\x2\x21F\x43\x3\x2\x2\x2\x220\x221\a-\x2\x2\x221\x222\x5\x6\x4\x2\x222"+
		"\x45\x3\x2\x2\x2\x223\x224\a,\x2\x2\x224\x225\x5\x6\x4\x2\x225G\x3\x2"+
		"\x2\x2\x226\x227\x5\x1C\xF\x2\x227I\x3\x2\x2\x2\x228\x22B\x5\x1A\xE\x2"+
		"\x229\x22B\x5L\'\x2\x22A\x228\x3\x2\x2\x2\x22A\x229\x3\x2\x2\x2\x22BK"+
		"\x3\x2\x2\x2\x22C\x22F\x5> \x2\x22D\x22F\x5*\x16\x2\x22E\x22C\x3\x2\x2"+
		"\x2\x22E\x22D\x3\x2\x2\x2\x22FM\x3\x2\x2\x2\x230\x231\a\x34\x2\x2\x231"+
		"\x232\x5n\x38\x2\x232\x233\x5P)\x2\x233O\x3\x2\x2\x2\x234\x237\x5*\x16"+
		"\x2\x235\x237\x5> \x2\x236\x234\x3\x2\x2\x2\x236\x235\x3\x2\x2\x2\x237"+
		"Q\x3\x2\x2\x2\x238\x241\x5T+\x2\x239\x241\x5X-\x2\x23A\x241\x5Z.\x2\x23B"+
		"\x241\x5`\x31\x2\x23C\x241\x5\\/\x2\x23D\x241\x5\x66\x34\x2\x23E\x241"+
		"\x5V,\x2\x23F\x241\x5\x62\x32\x2\x240\x238\x3\x2\x2\x2\x240\x239\x3\x2"+
		"\x2\x2\x240\x23A\x3\x2\x2\x2\x240\x23B\x3\x2\x2\x2\x240\x23C\x3\x2\x2"+
		"\x2\x240\x23D\x3\x2\x2\x2\x240\x23E\x3\x2\x2\x2\x240\x23F\x3\x2\x2\x2"+
		"\x241S\x3\x2\x2\x2\x242\x243\t\b\x2\x2\x243U\x3\x2\x2\x2\x244\x245\a\xAB"+
		"\x2\x2\x245W\x3\x2\x2\x2\x246\x247\t\t\x2\x2\x247Y\x3\x2\x2\x2\x248\x249"+
		"\t\n\x2\x2\x249[\x3\x2\x2\x2\x24A\x24D\a\x89\x2\x2\x24B\x24D\x5^\x30\x2"+
		"\x24C\x24A\x3\x2\x2\x2\x24C\x24B\x3\x2\x2\x2\x24D]\x3\x2\x2\x2\x24E\x24F"+
		"\t\v\x2\x2\x24F_\x3\x2\x2\x2\x250\x251\t\f\x2\x2\x251\x61\x3\x2\x2\x2"+
		"\x252\x253\t\r\x2\x2\x253\x63\x3\x2\x2\x2\x254\x255\t\xE\x2\x2\x255\x65"+
		"\x3\x2\x2\x2\x256\x25A\x5h\x35\x2\x257\x25A\x5j\x36\x2\x258\x25A\x5l\x37"+
		"\x2\x259\x256\x3\x2\x2\x2\x259\x257\x3\x2\x2\x2\x259\x258\x3\x2\x2\x2"+
		"\x25Ag\x3\x2\x2\x2\x25B\x25C\t\xF\x2\x2\x25Ci\x3\x2\x2\x2\x25D\x25E\a"+
		"\x8F\x2\x2\x25Ek\x3\x2\x2\x2\x25F\x260\t\x10\x2\x2\x260m\x3\x2\x2\x2\x261"+
		"\x263\t\x11\x2\x2\x262\x261\x3\x2\x2\x2\x263\x264\x3\x2\x2\x2\x264\x262"+
		"\x3\x2\x2\x2\x264\x265\x3\x2\x2\x2\x265o\x3\x2\x2\x2Yry~\x82\x86\x8A\x9A"+
		"\xA7\xB0\xB4\xBB\xBF\xC2\xC7\xCC\xD2\xD6\xDD\xE1\xE5\xEA\xEE\xF3\xF7\xFC"+
		"\x100\x105\x109\x10E\x112\x117\x11B\x120\x124\x129\x12D\x132\x136\x13B"+
		"\x13F\x144\x148\x14B\x14D\x155\x157\x15D\x161\x175\x179\x17D\x180\x183"+
		"\x18C\x19C\x19E\x1A8\x1AD\x1B1\x1B5\x1B8\x1BB\x1CE\x1D3\x1D6\x1DA\x1DE"+
		"\x1E3\x1E6\x1EA\x1EE\x1F2\x1FA\x1FE\x203\x208\x20C\x212\x216\x21E\x22A"+
		"\x22E\x236\x240\x24C\x259\x264";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace Rubberduck.Parsing.Binding
