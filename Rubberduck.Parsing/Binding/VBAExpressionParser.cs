//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\Splinter\Documents\Visual Studio 2015\Projects\RubberduckParserTest\RubberduckParserTest\VBAExpressionParser.g4 by ANTLR 4.3

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

namespace Rubberduck.Parsing.Binding {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.3")]
[System.CLSCompliant(false)]
public partial class VBAExpressionParser : Parser {
	public const int
		PRINT=156, ELSEIF=88, CBYTE=5, CLOSE=65, STATIC=180, MINUS=212, OPTION_EXPLICIT=149, 
		L_SQUARE_BRACKET=223, DOEVENTS=21, HASHENDIF=222, DATELITERAL=230, ERROR=102, 
		NOTHING=141, EACH=86, SUB=184, STOP=182, LPAREN=210, MID=136, CVERR=19, 
		AS=55, END_PROPERTY=93, AT=45, DATABASE=67, GOSUB=115, CSNG=15, HASHCONST=218, 
		POW=216, DOLLAR=47, PROPERTY_LET=159, THEN=187, XOR=202, EXIT_FOR=105, 
		DEFINT=75, HASHIF=219, UNLOCK=192, CALL=62, LOCK_READ=131, SET=176, LOCK_READ_WRITE=133, 
		ABS=1, LSET=134, RAISEEVENT=165, MIDBTYPESUFFIX=32, SEEK=174, LONG=125, 
		CBOOL=4, LIB=128, DIM=83, APPEND=54, OPEN=146, DIV=204, PROPERTY_SET=160, 
		CDBL=8, PERCENT=46, END_SELECT=94, STRING=183, HASHELSEIF=220, SGN=37, 
		REM=169, TO=188, DEFDBL=73, BYVAL=59, FRIEND=110, LOOP=126, CLASS=64, 
		DO=84, VARIANT=194, END_WITH=97, DEFBOOL=70, OPTIONAL=147, ADDRESSOF=50, 
		CONST=66, RSET=173, INTEGER=123, CDEC=9, ATTRIBUTE=53, OUTPUT=153, FOR=111, 
		PTRSAFE=161, EQ=206, BOOLEAN=58, CIRCLE=11, END_FUNCTION=91, DEFSNG=80, 
		DEFBYTE=71, NOT=140, CINT=10, END=98, PRESERVE=155, ON_LOCAL_ERROR=145, 
		FLOATLITERAL=228, HASHELSE=221, BINARY=57, LENB=28, RETURN=172, EXCLAMATIONPOINT=42, 
		NEXT=138, GLOBAL=114, INPUTB=24, IDENTIFIER=236, WS=234, EMPTY=89, CURRENCY=17, 
		CCUR=6, MOD=137, WITHEVENTS=200, COLON=40, DEFLNGLNG=77, STEP=181, OPTION_BASE=148, 
		GT=208, PUT=163, WITH=199, CSTR=16, LOCK_WRITE=132, LINE_CONTINUATION=237, 
		TYPEOF=191, DEFVAR=82, DEFLNG=76, UBOUND=38, FALSE=109, ERRORCHAR=238, 
		UNDERSCORE=233, INTEGERLITERAL=229, END_IF=92, LOCK=124, TEXT=186, SINGLEQUOTE=232, 
		MULT=213, SEMICOLON=41, BYTE=61, HEXLITERAL=227, ELSE=87, IF=117, TYPE=190, 
		AMPERSAND=48, DEFLNGPTR=78, ENUM=99, DEFOBJ=79, IN=120, OPTION=34, DOT=43, 
		EXIT_DO=104, GUIDLITERAL=235, IS=122, EQV=100, WEND=196, FUNCTION=112, 
		HASH=44, CASE=63, GEQ=207, GET=113, PUBLIC=162, ON_ERROR=144, EXIT=22, 
		MIDB=31, END_ENUM=90, GOTO=116, INTDIV=205, LONGPTR=30, WIDTH=198, BEGIN=56, 
		EXIT_SUB=108, ASSIGN=203, WRITE=201, DOUBLE=85, EXIT_PROPERTY=107, COMMA=39, 
		RANDOM=164, PROPERTY_GET=158, SELECT=175, PRIVATE=157, ERASE=101, TAB=185, 
		BYREF=60, VERSION=195, NEQ=214, END_TYPE=96, NEW=139, ARRAY=3, INPUT=121, 
		SINGLE=178, ALIAS=51, SPC=179, LT=211, RESET=170, END_SUB=95, EVENT=103, 
		READ_WRITE=167, OPTION_COMPARE=150, ME=135, SCALE=36, CDATE=7, MIDTYPESUFFIX=33, 
		NULL=142, NEWLINE=231, TRUE=189, RPAREN=217, IMP=118, STRINGLITERAL=225, 
		OCTLITERAL=226, READ=166, DATE=68, LIKE=129, AND=52, OPTION_PRIVATE_MODULE=151, 
		CLNGLNG=13, PLUS=215, ANY=2, RESUME=171, INT=25, SHARED=177, EXIT_FUNCTION=106, 
		PSET=35, ACCESS=49, LINE_INPUT=130, ON=143, OR=152, PARAMARRAY=154, LBOUND=26, 
		R_SQUARE_BRACKET=224, IMPLEMENTS=119, UNTIL=193, DEBUG=20, DEFCUR=74, 
		CLNGPTR=14, LONGLONG=29, DECLARE=69, DEFDATE=72, FIX=23, LEN=27, REDIM=168, 
		LEQ=209, DEFSTR=81, LET=127, WHILE=197, CVAR=18, CLNG=12, FOREIGNNAME=239, 
		OBJECT=240, COLLECTION=241;
	public static readonly string[] tokenNames = {
		"<INVALID>", "ABS", "ANY", "ARRAY", "CBOOL", "CBYTE", "CCUR", "CDATE", 
		"CDBL", "CDEC", "CINT", "CIRCLE", "CLNG", "CLNGLNG", "CLNGPTR", "CSNG", 
		"CSTR", "CURRENCY", "CVAR", "CVERR", "DEBUG", "DOEVENTS", "EXIT", "FIX", 
		"INPUTB", "INT", "LBOUND", "LEN", "LENB", "LONGLONG", "LONGPTR", "MIDB", 
		"MIDBTYPESUFFIX", "MIDTYPESUFFIX", "OPTION", "PSET", "SCALE", "SGN", "UBOUND", 
		"','", "':'", "';'", "'!'", "'.'", "'#'", "'@'", "'%'", "'$'", "'&'", 
		"ACCESS", "ADDRESSOF", "ALIAS", "AND", "ATTRIBUTE", "APPEND", "AS", "BEGIN", 
		"BINARY", "BOOLEAN", "BYVAL", "BYREF", "BYTE", "CALL", "CASE", "CLASS", 
		"CLOSE", "CONST", "DATABASE", "DATE", "DECLARE", "DEFBOOL", "DEFBYTE", 
		"DEFDATE", "DEFDBL", "DEFCUR", "DEFINT", "DEFLNG", "DEFLNGLNG", "DEFLNGPTR", 
		"DEFOBJ", "DEFSNG", "DEFSTR", "DEFVAR", "DIM", "DO", "DOUBLE", "EACH", 
		"ELSE", "ELSEIF", "EMPTY", "END_ENUM", "END_FUNCTION", "END_IF", "END_PROPERTY", 
		"END_SELECT", "END_SUB", "END_TYPE", "END_WITH", "END", "ENUM", "EQV", 
		"ERASE", "ERROR", "EVENT", "EXIT_DO", "EXIT_FOR", "EXIT_FUNCTION", "EXIT_PROPERTY", 
		"EXIT_SUB", "FALSE", "FRIEND", "FOR", "FUNCTION", "GET", "GLOBAL", "GOSUB", 
		"GOTO", "IF", "IMP", "IMPLEMENTS", "IN", "INPUT", "IS", "INTEGER", "LOCK", 
		"LONG", "LOOP", "LET", "LIB", "LIKE", "LINE_INPUT", "LOCK_READ", "LOCK_WRITE", 
		"LOCK_READ_WRITE", "LSET", "ME", "MID", "MOD", "NEXT", "NEW", "NOT", "NOTHING", 
		"NULL", "ON", "ON_ERROR", "ON_LOCAL_ERROR", "OPEN", "OPTIONAL", "OPTION_BASE", 
		"OPTION_EXPLICIT", "OPTION_COMPARE", "OPTION_PRIVATE_MODULE", "OR", "OUTPUT", 
		"PARAMARRAY", "PRESERVE", "PRINT", "PRIVATE", "PROPERTY_GET", "PROPERTY_LET", 
		"PROPERTY_SET", "PTRSAFE", "PUBLIC", "PUT", "RANDOM", "RAISEEVENT", "READ", 
		"READ_WRITE", "REDIM", "REM", "RESET", "RESUME", "RETURN", "RSET", "SEEK", 
		"SELECT", "SET", "SHARED", "SINGLE", "SPC", "STATIC", "STEP", "STOP", 
		"STRING", "SUB", "TAB", "TEXT", "THEN", "TO", "TRUE", "TYPE", "TYPEOF", 
		"UNLOCK", "UNTIL", "VARIANT", "VERSION", "WEND", "WHILE", "WIDTH", "WITH", 
		"WITHEVENTS", "WRITE", "XOR", "':='", "'/'", "'\\'", "'='", "GEQ", "'>'", 
		"LEQ", "'('", "'<'", "'-'", "'*'", "NEQ", "'+'", "'^'", "')'", "HASHCONST", 
		"HASHIF", "HASHELSEIF", "HASHELSE", "HASHENDIF", "'['", "']'", "STRINGLITERAL", 
		"OCTLITERAL", "HEXLITERAL", "FLOATLITERAL", "INTEGERLITERAL", "DATELITERAL", 
		"NEWLINE", "'''", "'_'", "WS", "GUIDLITERAL", "IDENTIFIER", "LINE_CONTINUATION", 
		"ERRORCHAR", "FOREIGNNAME", "OBJECT", "COLLECTION"
	};
	public const int
		RULE_startRule = 0, RULE_callStmt = 1, RULE_unrestrictedName = 2, RULE_name = 3, 
		RULE_reservedIdentifierName = 4, RULE_reservedUntypedName = 5, RULE_reservedTypedName = 6, 
		RULE_untypedName = 7, RULE_typedName = 8, RULE_typedNameValue = 9, RULE_typeSuffix = 10, 
		RULE_optionCompareArgument = 11, RULE_builtInType = 12, RULE_expression = 13, 
		RULE_literalExpression = 14, RULE_numberLiteral = 15, RULE_parenthesizedExpression = 16, 
		RULE_typeOfIsExpression = 17, RULE_newExpression = 18, RULE_lExpression = 19, 
		RULE_memberAccessExpression = 20, RULE_indexExpression = 21, RULE_dictionaryAccessExpression = 22, 
		RULE_argumentList = 23, RULE_positionalOrNamedArgumentList = 24, RULE_positionalArgument = 25, 
		RULE_requiredPositionalArgument = 26, RULE_namedArgumentList = 27, RULE_namedArgument = 28, 
		RULE_argumentExpression = 29, RULE_simpleNameExpression = 30, RULE_instanceExpression = 31, 
		RULE_withExpression = 32, RULE_withMemberAccessExpression = 33, RULE_withDictionaryAccessExpression = 34, 
		RULE_constantExpression = 35, RULE_typeExpression = 36, RULE_definedTypeExpression = 37, 
		RULE_addressOfExpression = 38, RULE_procedurePointerExpression = 39, RULE_reservedIdentifier = 40, 
		RULE_statementKeyword = 41, RULE_remKeyword = 42, RULE_markerKeyword = 43, 
		RULE_operatorIdentifier = 44, RULE_reservedName = 45, RULE_reservedProcedureName = 46, 
		RULE_specialForm = 47, RULE_reservedTypeIdentifier = 48, RULE_uncategorizedKeyword = 49, 
		RULE_literalIdentifier = 50, RULE_booleanLiteralIdentifier = 51, RULE_objectLiteralIdentifier = 52, 
		RULE_variantLiteralIdentifier = 53, RULE_whiteSpace = 54;
	public static readonly string[] ruleNames = {
		"startRule", "callStmt", "unrestrictedName", "name", "reservedIdentifierName", 
		"reservedUntypedName", "reservedTypedName", "untypedName", "typedName", 
		"typedNameValue", "typeSuffix", "optionCompareArgument", "builtInType", 
		"expression", "literalExpression", "numberLiteral", "parenthesizedExpression", 
		"typeOfIsExpression", "newExpression", "lExpression", "memberAccessExpression", 
		"indexExpression", "dictionaryAccessExpression", "argumentList", "positionalOrNamedArgumentList", 
		"positionalArgument", "requiredPositionalArgument", "namedArgumentList", 
		"namedArgument", "argumentExpression", "simpleNameExpression", "instanceExpression", 
		"withExpression", "withMemberAccessExpression", "withDictionaryAccessExpression", 
		"constantExpression", "typeExpression", "definedTypeExpression", "addressOfExpression", 
		"procedurePointerExpression", "reservedIdentifier", "statementKeyword", 
		"remKeyword", "markerKeyword", "operatorIdentifier", "reservedName", "reservedProcedureName", 
		"specialForm", "reservedTypeIdentifier", "uncategorizedKeyword", "literalIdentifier", 
		"booleanLiteralIdentifier", "objectLiteralIdentifier", "variantLiteralIdentifier", 
		"whiteSpace"
	};

	public override string GrammarFileName { get { return "VBAExpressionParser.g4"; } }

	public override string[] TokenNames { get { return tokenNames; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public VBAExpressionParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class StartRuleContext : ParserRuleContext {
		public CallStmtContext callStmt() {
			return GetRuleContext<CallStmtContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(VBAExpressionParser.Eof, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public StartRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_startRule; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterStartRule(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitStartRule(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStartRule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StartRuleContext startRule() {
		StartRuleContext _localctx = new StartRuleContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_startRule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 112;
			switch ( Interpreter.AdaptivePredict(_input,0,_ctx) ) {
			case 1:
				{
				State = 110; expression(0);
				}
				break;

			case 2:
				{
				State = 111; callStmt();
				}
				break;
			}
			State = 114; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CallStmtContext : ParserRuleContext {
		public MemberAccessExpressionContext memberAccessExpression() {
			return GetRuleContext<MemberAccessExpressionContext>(0);
		}
		public WithExpressionContext withExpression() {
			return GetRuleContext<WithExpressionContext>(0);
		}
		public SimpleNameExpressionContext simpleNameExpression() {
			return GetRuleContext<SimpleNameExpressionContext>(0);
		}
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		public CallStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_callStmt; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterCallStmt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitCallStmt(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCallStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CallStmtContext callStmt() {
		CallStmtContext _localctx = new CallStmtContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_callStmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 119;
			switch ( Interpreter.AdaptivePredict(_input,1,_ctx) ) {
			case 1:
				{
				State = 116; memberAccessExpression();
				}
				break;

			case 2:
				{
				State = 117; simpleNameExpression();
				}
				break;

			case 3:
				{
				State = 118; withExpression();
				}
				break;
			}
			State = 124;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 121; whiteSpace();
				State = 122; argumentList();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnrestrictedNameContext : ParserRuleContext {
		public ReservedIdentifierNameContext reservedIdentifierName() {
			return GetRuleContext<ReservedIdentifierNameContext>(0);
		}
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public UnrestrictedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unrestrictedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterUnrestrictedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitUnrestrictedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnrestrictedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnrestrictedNameContext unrestrictedName() {
		UnrestrictedNameContext _localctx = new UnrestrictedNameContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_unrestrictedName);
		try {
			State = 128;
			switch ( Interpreter.AdaptivePredict(_input,3,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 126; name();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 127; reservedIdentifierName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NameContext : ParserRuleContext {
		public TypedNameContext typedName() {
			return GetRuleContext<TypedNameContext>(0);
		}
		public UntypedNameContext untypedName() {
			return GetRuleContext<UntypedNameContext>(0);
		}
		public NameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NameContext name() {
		NameContext _localctx = new NameContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_name);
		try {
			State = 132;
			switch ( Interpreter.AdaptivePredict(_input,4,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 130; untypedName();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 131; typedName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedIdentifierNameContext : ParserRuleContext {
		public ReservedTypedNameContext reservedTypedName() {
			return GetRuleContext<ReservedTypedNameContext>(0);
		}
		public ReservedUntypedNameContext reservedUntypedName() {
			return GetRuleContext<ReservedUntypedNameContext>(0);
		}
		public ReservedIdentifierNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedIdentifierName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedIdentifierName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedIdentifierName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedIdentifierName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedIdentifierNameContext reservedIdentifierName() {
		ReservedIdentifierNameContext _localctx = new ReservedIdentifierNameContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_reservedIdentifierName);
		try {
			State = 136;
			switch ( Interpreter.AdaptivePredict(_input,5,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 134; reservedUntypedName();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 135; reservedTypedName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedUntypedNameContext : ParserRuleContext {
		public ReservedIdentifierContext reservedIdentifier() {
			return GetRuleContext<ReservedIdentifierContext>(0);
		}
		public ReservedUntypedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedUntypedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedUntypedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedUntypedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedUntypedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedUntypedNameContext reservedUntypedName() {
		ReservedUntypedNameContext _localctx = new ReservedUntypedNameContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_reservedUntypedName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 138; reservedIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedTypedNameContext : ParserRuleContext {
		public TypeSuffixContext typeSuffix() {
			return GetRuleContext<TypeSuffixContext>(0);
		}
		public ReservedIdentifierContext reservedIdentifier() {
			return GetRuleContext<ReservedIdentifierContext>(0);
		}
		public ReservedTypedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedTypedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedTypedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedTypedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedTypedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedTypedNameContext reservedTypedName() {
		ReservedTypedNameContext _localctx = new ReservedTypedNameContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_reservedTypedName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 140; reservedIdentifier();
			State = 141; typeSuffix();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UntypedNameContext : ParserRuleContext {
		public UncategorizedKeywordContext uncategorizedKeyword() {
			return GetRuleContext<UncategorizedKeywordContext>(0);
		}
		public ITerminalNode FOREIGNNAME() { return GetToken(VBAExpressionParser.FOREIGNNAME, 0); }
		public SpecialFormContext specialForm() {
			return GetRuleContext<SpecialFormContext>(0);
		}
		public ITerminalNode OBJECT() { return GetToken(VBAExpressionParser.OBJECT, 0); }
		public ITerminalNode ERROR() { return GetToken(VBAExpressionParser.ERROR, 0); }
		public OptionCompareArgumentContext optionCompareArgument() {
			return GetRuleContext<OptionCompareArgumentContext>(0);
		}
		public ReservedTypeIdentifierContext reservedTypeIdentifier() {
			return GetRuleContext<ReservedTypeIdentifierContext>(0);
		}
		public ITerminalNode IDENTIFIER() { return GetToken(VBAExpressionParser.IDENTIFIER, 0); }
		public ReservedProcedureNameContext reservedProcedureName() {
			return GetRuleContext<ReservedProcedureNameContext>(0);
		}
		public UntypedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_untypedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterUntypedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitUntypedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUntypedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UntypedNameContext untypedName() {
		UntypedNameContext _localctx = new UntypedNameContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_untypedName);
		try {
			State = 152;
			switch ( Interpreter.AdaptivePredict(_input,6,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 143; Match(IDENTIFIER);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 144; Match(FOREIGNNAME);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 145; reservedProcedureName();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 146; specialForm();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 147; optionCompareArgument();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 148; Match(OBJECT);
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 149; uncategorizedKeyword();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 150; Match(ERROR);
				}
				break;

			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 151; reservedTypeIdentifier();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypedNameContext : ParserRuleContext {
		public TypeSuffixContext typeSuffix() {
			return GetRuleContext<TypeSuffixContext>(0);
		}
		public TypedNameValueContext typedNameValue() {
			return GetRuleContext<TypedNameValueContext>(0);
		}
		public TypedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypedNameContext typedName() {
		TypedNameContext _localctx = new TypedNameContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_typedName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 154; typedNameValue();
			State = 155; typeSuffix();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypedNameValueContext : ParserRuleContext {
		public UncategorizedKeywordContext uncategorizedKeyword() {
			return GetRuleContext<UncategorizedKeywordContext>(0);
		}
		public SpecialFormContext specialForm() {
			return GetRuleContext<SpecialFormContext>(0);
		}
		public ITerminalNode OBJECT() { return GetToken(VBAExpressionParser.OBJECT, 0); }
		public ITerminalNode ERROR() { return GetToken(VBAExpressionParser.ERROR, 0); }
		public OptionCompareArgumentContext optionCompareArgument() {
			return GetRuleContext<OptionCompareArgumentContext>(0);
		}
		public ReservedTypeIdentifierContext reservedTypeIdentifier() {
			return GetRuleContext<ReservedTypeIdentifierContext>(0);
		}
		public ITerminalNode IDENTIFIER() { return GetToken(VBAExpressionParser.IDENTIFIER, 0); }
		public ReservedProcedureNameContext reservedProcedureName() {
			return GetRuleContext<ReservedProcedureNameContext>(0);
		}
		public TypedNameValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typedNameValue; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypedNameValue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypedNameValue(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypedNameValue(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypedNameValueContext typedNameValue() {
		TypedNameValueContext _localctx = new TypedNameValueContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_typedNameValue);
		try {
			State = 165;
			switch ( Interpreter.AdaptivePredict(_input,7,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 157; Match(IDENTIFIER);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 158; reservedProcedureName();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 159; specialForm();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 160; optionCompareArgument();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 161; Match(OBJECT);
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 162; uncategorizedKeyword();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 163; Match(ERROR);
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 164; reservedTypeIdentifier();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeSuffixContext : ParserRuleContext {
		public ITerminalNode AT() { return GetToken(VBAExpressionParser.AT, 0); }
		public ITerminalNode DOLLAR() { return GetToken(VBAExpressionParser.DOLLAR, 0); }
		public ITerminalNode EXCLAMATIONPOINT() { return GetToken(VBAExpressionParser.EXCLAMATIONPOINT, 0); }
		public ITerminalNode AMPERSAND() { return GetToken(VBAExpressionParser.AMPERSAND, 0); }
		public ITerminalNode PERCENT() { return GetToken(VBAExpressionParser.PERCENT, 0); }
		public ITerminalNode POW() { return GetToken(VBAExpressionParser.POW, 0); }
		public ITerminalNode HASH() { return GetToken(VBAExpressionParser.HASH, 0); }
		public TypeSuffixContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeSuffix; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypeSuffix(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypeSuffix(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeSuffix(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeSuffixContext typeSuffix() {
		TypeSuffixContext _localctx = new TypeSuffixContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_typeSuffix);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 167;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << EXCLAMATIONPOINT) | (1L << HASH) | (1L << AT) | (1L << PERCENT) | (1L << DOLLAR) | (1L << AMPERSAND))) != 0) || _la==POW) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OptionCompareArgumentContext : ParserRuleContext {
		public ITerminalNode TEXT() { return GetToken(VBAExpressionParser.TEXT, 0); }
		public ITerminalNode DATABASE() { return GetToken(VBAExpressionParser.DATABASE, 0); }
		public ITerminalNode BINARY() { return GetToken(VBAExpressionParser.BINARY, 0); }
		public OptionCompareArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_optionCompareArgument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterOptionCompareArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitOptionCompareArgument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOptionCompareArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OptionCompareArgumentContext optionCompareArgument() {
		OptionCompareArgumentContext _localctx = new OptionCompareArgumentContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_optionCompareArgument);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 169;
			_la = _input.La(1);
			if ( !(_la==BINARY || _la==DATABASE || _la==TEXT) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BuiltInTypeContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode OBJECT() { return GetToken(VBAExpressionParser.OBJECT, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ReservedTypeIdentifierContext reservedTypeIdentifier() {
			return GetRuleContext<ReservedTypeIdentifierContext>(0);
		}
		public ITerminalNode L_SQUARE_BRACKET() { return GetToken(VBAExpressionParser.L_SQUARE_BRACKET, 0); }
		public ITerminalNode R_SQUARE_BRACKET() { return GetToken(VBAExpressionParser.R_SQUARE_BRACKET, 0); }
		public BuiltInTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_builtInType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterBuiltInType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitBuiltInType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltInType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BuiltInTypeContext builtInType() {
		BuiltInTypeContext _localctx = new BuiltInTypeContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_builtInType);
		int _la;
		try {
			State = 192;
			switch ( Interpreter.AdaptivePredict(_input,12,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 171; reservedTypeIdentifier();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 172; Match(L_SQUARE_BRACKET);
				State = 174;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 173; whiteSpace();
					}
				}

				State = 176; reservedTypeIdentifier();
				State = 178;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 177; whiteSpace();
					}
				}

				State = 180; Match(R_SQUARE_BRACKET);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 182; Match(OBJECT);
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 183; Match(L_SQUARE_BRACKET);
				State = 185;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 184; whiteSpace();
					}
				}

				State = 187; Match(OBJECT);
				State = 189;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 188; whiteSpace();
					}
				}

				State = 191; Match(R_SQUARE_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
	 
		public ExpressionContext() { }
		public virtual void CopyFrom(ExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class UnaryMinusOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public ITerminalNode MINUS() { return GetToken(VBAExpressionParser.MINUS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public UnaryMinusOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterUnaryMinusOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitUnaryMinusOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryMinusOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NewExprContext : ExpressionContext {
		public NewExpressionContext newExpression() {
			return GetRuleContext<NewExpressionContext>(0);
		}
		public NewExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterNewExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitNewExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNewExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PowOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode POW() { return GetToken(VBAExpressionParser.POW, 0); }
		public PowOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterPowOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitPowOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPowOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AddOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode PLUS() { return GetToken(VBAExpressionParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(VBAExpressionParser.MINUS, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public AddOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterAddOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitAddOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAddOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TypeOfIsExprContext : ExpressionContext {
		public TypeOfIsExpressionContext typeOfIsExpression() {
			return GetRuleContext<TypeOfIsExpressionContext>(0);
		}
		public TypeOfIsExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypeOfIsExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypeOfIsExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeOfIsExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class IntDivOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode INTDIV() { return GetToken(VBAExpressionParser.INTDIV, 0); }
		public IntDivOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterIntDivOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitIntDivOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIntDivOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalImpOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode IMP() { return GetToken(VBAExpressionParser.IMP, 0); }
		public LogicalImpOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalImpOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalImpOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalImpOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ConcatOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode AMPERSAND() { return GetToken(VBAExpressionParser.AMPERSAND, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ConcatOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterConcatOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitConcatOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConcatOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MarkedFileNumberExprContext : ExpressionContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode HASH() { return GetToken(VBAExpressionParser.HASH, 0); }
		public MarkedFileNumberExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterMarkedFileNumberExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitMarkedFileNumberExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMarkedFileNumberExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ModOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode MOD() { return GetToken(VBAExpressionParser.MOD, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ModOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterModOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitModOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LExprContext : ExpressionContext {
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public LExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MultOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode MULT() { return GetToken(VBAExpressionParser.MULT, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode DIV() { return GetToken(VBAExpressionParser.DIV, 0); }
		public MultOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterMultOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitMultOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalXorOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode XOR() { return GetToken(VBAExpressionParser.XOR, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public LogicalXorOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalXorOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalXorOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalXorOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalAndOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode AND() { return GetToken(VBAExpressionParser.AND, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public LogicalAndOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalAndOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalAndOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalAndOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalOrOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode OR() { return GetToken(VBAExpressionParser.OR, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public LogicalOrOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalOrOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalOrOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalOrOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RelationalOpContext : ExpressionContext {
		public ITerminalNode GEQ() { return GetToken(VBAExpressionParser.GEQ, 0); }
		public ITerminalNode NEQ() { return GetToken(VBAExpressionParser.NEQ, 0); }
		public ITerminalNode IS() { return GetToken(VBAExpressionParser.IS, 0); }
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode LEQ() { return GetToken(VBAExpressionParser.LEQ, 0); }
		public ITerminalNode LT() { return GetToken(VBAExpressionParser.LT, 0); }
		public ITerminalNode GT() { return GetToken(VBAExpressionParser.GT, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode EQ() { return GetToken(VBAExpressionParser.EQ, 0); }
		public ITerminalNode LIKE() { return GetToken(VBAExpressionParser.LIKE, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public RelationalOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterRelationalOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitRelationalOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelationalOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalEqvOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode EQV() { return GetToken(VBAExpressionParser.EQV, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public LogicalEqvOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalEqvOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalEqvOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalEqvOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ParenthesizedExprContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode LPAREN() { return GetToken(VBAExpressionParser.LPAREN, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode RPAREN() { return GetToken(VBAExpressionParser.RPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ParenthesizedExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterParenthesizedExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitParenthesizedExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthesizedExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LiteralExprContext : ExpressionContext {
		public LiteralExpressionContext literalExpression() {
			return GetRuleContext<LiteralExpressionContext>(0);
		}
		public LiteralExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLiteralExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLiteralExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalNotOpContext : ExpressionContext {
		public ITerminalNode NOT() { return GetToken(VBAExpressionParser.NOT, 0); }
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public LogicalNotOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalNotOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalNotOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalNotOp(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(_ctx, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 26;
		EnterRecursionRule(_localctx, 26, RULE_expression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 221;
			switch (_input.La(1)) {
			case MINUS:
				{
				_localctx = new UnaryMinusOpContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;

				State = 195; Match(MINUS);
				State = 197;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 196; whiteSpace();
					}
				}

				State = 199; expression(15);
				}
				break;
			case NOT:
				{
				_localctx = new LogicalNotOpContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 200; Match(NOT);
				State = 202;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 201; whiteSpace();
					}
				}

				State = 204; expression(8);
				}
				break;
			case HASH:
				{
				_localctx = new MarkedFileNumberExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 205; Match(HASH);
				State = 206; expression(1);
				}
				break;
			case ABS:
			case ANY:
			case ARRAY:
			case CBOOL:
			case CBYTE:
			case CCUR:
			case CDATE:
			case CDBL:
			case CDEC:
			case CINT:
			case CIRCLE:
			case CLNG:
			case CLNGLNG:
			case CLNGPTR:
			case CSNG:
			case CSTR:
			case CURRENCY:
			case CVAR:
			case CVERR:
			case DEBUG:
			case DOEVENTS:
			case FIX:
			case INPUTB:
			case INT:
			case LBOUND:
			case LEN:
			case LENB:
			case LONGLONG:
			case LONGPTR:
			case MIDB:
			case MIDBTYPESUFFIX:
			case MIDTYPESUFFIX:
			case PSET:
			case SCALE:
			case SGN:
			case UBOUND:
			case EXCLAMATIONPOINT:
			case DOT:
			case ACCESS:
			case ALIAS:
			case ATTRIBUTE:
			case APPEND:
			case BEGIN:
			case BINARY:
			case BOOLEAN:
			case BYTE:
			case CLASS:
			case CLOSE:
			case DATABASE:
			case DATE:
			case DOUBLE:
			case END_SELECT:
			case END_WITH:
			case END:
			case ERROR:
			case EXIT_DO:
			case EXIT_FOR:
			case EXIT_FUNCTION:
			case EXIT_PROPERTY:
			case EXIT_SUB:
			case GET:
			case INPUT:
			case INTEGER:
			case LOCK:
			case LONG:
			case LIB:
			case LINE_INPUT:
			case LOCK_READ:
			case LOCK_WRITE:
			case LOCK_READ_WRITE:
			case ME:
			case MID:
			case ON:
			case ON_ERROR:
			case OPEN:
			case OUTPUT:
			case PUT:
			case RANDOM:
			case READ:
			case READ_WRITE:
			case RESET:
			case SEEK:
			case SHARED:
			case SINGLE:
			case STEP:
			case STRING:
			case TAB:
			case TEXT:
			case UNLOCK:
			case VARIANT:
			case VERSION:
			case WIDTH:
			case WRITE:
			case IDENTIFIER:
			case FOREIGNNAME:
			case OBJECT:
			case COLLECTION:
				{
				_localctx = new LExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 207; lExpression(0);
				}
				break;
			case LPAREN:
				{
				_localctx = new ParenthesizedExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 208; Match(LPAREN);
				State = 210;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 209; whiteSpace();
					}
				}

				State = 212; expression(0);
				State = 214;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 213; whiteSpace();
					}
				}

				State = 216; Match(RPAREN);
				}
				break;
			case TYPEOF:
				{
				_localctx = new TypeOfIsExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 218; typeOfIsExpression();
				}
				break;
			case NEW:
				{
				_localctx = new NewExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 219; newExpression();
				}
				break;
			case EMPTY:
			case FALSE:
			case NOTHING:
			case NULL:
			case TRUE:
			case STRINGLITERAL:
			case OCTLITERAL:
			case HEXLITERAL:
			case FLOATLITERAL:
			case INTEGERLITERAL:
			case DATELITERAL:
				{
				_localctx = new LiteralExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 220; literalExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			_ctx.stop = _input.Lt(-1);
			State = 333;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,43,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 331;
					switch ( Interpreter.AdaptivePredict(_input,42,_ctx) ) {
					case 1:
						{
						_localctx = new PowOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 223;
						if (!(Precpred(_ctx, 16))) throw new FailedPredicateException(this, "Precpred(_ctx, 16)");
						State = 225;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 224; whiteSpace();
							}
						}

						State = 227; Match(POW);
						State = 229;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 228; whiteSpace();
							}
						}

						State = 231; expression(17);
						}
						break;

					case 2:
						{
						_localctx = new MultOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 232;
						if (!(Precpred(_ctx, 14))) throw new FailedPredicateException(this, "Precpred(_ctx, 14)");
						State = 234;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 233; whiteSpace();
							}
						}

						State = 236;
						_la = _input.La(1);
						if ( !(_la==DIV || _la==MULT) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 238;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 237; whiteSpace();
							}
						}

						State = 240; expression(15);
						}
						break;

					case 3:
						{
						_localctx = new IntDivOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 241;
						if (!(Precpred(_ctx, 13))) throw new FailedPredicateException(this, "Precpred(_ctx, 13)");
						State = 243;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 242; whiteSpace();
							}
						}

						State = 245; Match(INTDIV);
						State = 247;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 246; whiteSpace();
							}
						}

						State = 249; expression(14);
						}
						break;

					case 4:
						{
						_localctx = new ModOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 250;
						if (!(Precpred(_ctx, 12))) throw new FailedPredicateException(this, "Precpred(_ctx, 12)");
						State = 252;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 251; whiteSpace();
							}
						}

						State = 254; Match(MOD);
						State = 256;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 255; whiteSpace();
							}
						}

						State = 258; expression(13);
						}
						break;

					case 5:
						{
						_localctx = new AddOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 259;
						if (!(Precpred(_ctx, 11))) throw new FailedPredicateException(this, "Precpred(_ctx, 11)");
						State = 261;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 260; whiteSpace();
							}
						}

						State = 263;
						_la = _input.La(1);
						if ( !(_la==MINUS || _la==PLUS) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 265;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 264; whiteSpace();
							}
						}

						State = 267; expression(12);
						}
						break;

					case 6:
						{
						_localctx = new ConcatOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 268;
						if (!(Precpred(_ctx, 10))) throw new FailedPredicateException(this, "Precpred(_ctx, 10)");
						State = 270;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 269; whiteSpace();
							}
						}

						State = 272; Match(AMPERSAND);
						State = 274;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 273; whiteSpace();
							}
						}

						State = 276; expression(11);
						}
						break;

					case 7:
						{
						_localctx = new RelationalOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 277;
						if (!(Precpred(_ctx, 9))) throw new FailedPredicateException(this, "Precpred(_ctx, 9)");
						State = 279;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 278; whiteSpace();
							}
						}

						State = 281;
						_la = _input.La(1);
						if ( !(_la==IS || _la==LIKE || ((((_la - 206)) & ~0x3f) == 0 && ((1L << (_la - 206)) & ((1L << (EQ - 206)) | (1L << (GEQ - 206)) | (1L << (GT - 206)) | (1L << (LEQ - 206)) | (1L << (LT - 206)) | (1L << (NEQ - 206)))) != 0)) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 283;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 282; whiteSpace();
							}
						}

						State = 285; expression(10);
						}
						break;

					case 8:
						{
						_localctx = new LogicalAndOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 286;
						if (!(Precpred(_ctx, 7))) throw new FailedPredicateException(this, "Precpred(_ctx, 7)");
						State = 288;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 287; whiteSpace();
							}
						}

						State = 290; Match(AND);
						State = 292;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 291; whiteSpace();
							}
						}

						State = 294; expression(8);
						}
						break;

					case 9:
						{
						_localctx = new LogicalOrOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 295;
						if (!(Precpred(_ctx, 6))) throw new FailedPredicateException(this, "Precpred(_ctx, 6)");
						State = 297;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 296; whiteSpace();
							}
						}

						State = 299; Match(OR);
						State = 301;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 300; whiteSpace();
							}
						}

						State = 303; expression(7);
						}
						break;

					case 10:
						{
						_localctx = new LogicalXorOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 304;
						if (!(Precpred(_ctx, 5))) throw new FailedPredicateException(this, "Precpred(_ctx, 5)");
						State = 306;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 305; whiteSpace();
							}
						}

						State = 308; Match(XOR);
						State = 310;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 309; whiteSpace();
							}
						}

						State = 312; expression(6);
						}
						break;

					case 11:
						{
						_localctx = new LogicalEqvOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 313;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 315;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 314; whiteSpace();
							}
						}

						State = 317; Match(EQV);
						State = 319;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 318; whiteSpace();
							}
						}

						State = 321; expression(5);
						}
						break;

					case 12:
						{
						_localctx = new LogicalImpOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 322;
						if (!(Precpred(_ctx, 3))) throw new FailedPredicateException(this, "Precpred(_ctx, 3)");
						State = 324;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 323; whiteSpace();
							}
						}

						State = 326; Match(IMP);
						State = 328;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 327; whiteSpace();
							}
						}

						State = 330; expression(4);
						}
						break;
					}
					} 
				}
				State = 335;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,43,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class LiteralExpressionContext : ParserRuleContext {
		public ITerminalNode STRINGLITERAL() { return GetToken(VBAExpressionParser.STRINGLITERAL, 0); }
		public TypeSuffixContext typeSuffix() {
			return GetRuleContext<TypeSuffixContext>(0);
		}
		public ITerminalNode DATELITERAL() { return GetToken(VBAExpressionParser.DATELITERAL, 0); }
		public NumberLiteralContext numberLiteral() {
			return GetRuleContext<NumberLiteralContext>(0);
		}
		public LiteralIdentifierContext literalIdentifier() {
			return GetRuleContext<LiteralIdentifierContext>(0);
		}
		public LiteralExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literalExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLiteralExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLiteralExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralExpressionContext literalExpression() {
		LiteralExpressionContext _localctx = new LiteralExpressionContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_literalExpression);
		try {
			State = 343;
			switch (_input.La(1)) {
			case OCTLITERAL:
			case HEXLITERAL:
			case FLOATLITERAL:
			case INTEGERLITERAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 336; numberLiteral();
				}
				break;
			case DATELITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 337; Match(DATELITERAL);
				}
				break;
			case STRINGLITERAL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 338; Match(STRINGLITERAL);
				}
				break;
			case EMPTY:
			case FALSE:
			case NOTHING:
			case NULL:
			case TRUE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 339; literalIdentifier();
				State = 341;
				switch ( Interpreter.AdaptivePredict(_input,44,_ctx) ) {
				case 1:
					{
					State = 340; typeSuffix();
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumberLiteralContext : ParserRuleContext {
		public ITerminalNode INTEGERLITERAL() { return GetToken(VBAExpressionParser.INTEGERLITERAL, 0); }
		public ITerminalNode FLOATLITERAL() { return GetToken(VBAExpressionParser.FLOATLITERAL, 0); }
		public ITerminalNode HEXLITERAL() { return GetToken(VBAExpressionParser.HEXLITERAL, 0); }
		public ITerminalNode OCTLITERAL() { return GetToken(VBAExpressionParser.OCTLITERAL, 0); }
		public NumberLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numberLiteral; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterNumberLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitNumberLiteral(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumberLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumberLiteralContext numberLiteral() {
		NumberLiteralContext _localctx = new NumberLiteralContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_numberLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 345;
			_la = _input.La(1);
			if ( !(((((_la - 226)) & ~0x3f) == 0 && ((1L << (_la - 226)) & ((1L << (OCTLITERAL - 226)) | (1L << (HEXLITERAL - 226)) | (1L << (FLOATLITERAL - 226)) | (1L << (INTEGERLITERAL - 226)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParenthesizedExpressionContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode LPAREN() { return GetToken(VBAExpressionParser.LPAREN, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode RPAREN() { return GetToken(VBAExpressionParser.RPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ParenthesizedExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parenthesizedExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterParenthesizedExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitParenthesizedExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthesizedExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParenthesizedExpressionContext parenthesizedExpression() {
		ParenthesizedExpressionContext _localctx = new ParenthesizedExpressionContext(_ctx, State);
		EnterRule(_localctx, 32, RULE_parenthesizedExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 347; Match(LPAREN);
			State = 349;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 348; whiteSpace();
				}
			}

			State = 351; expression(0);
			State = 353;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 352; whiteSpace();
				}
			}

			State = 355; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeOfIsExpressionContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode IS() { return GetToken(VBAExpressionParser.IS, 0); }
		public ITerminalNode TYPEOF() { return GetToken(VBAExpressionParser.TYPEOF, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public TypeExpressionContext typeExpression() {
			return GetRuleContext<TypeExpressionContext>(0);
		}
		public TypeOfIsExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeOfIsExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypeOfIsExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypeOfIsExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeOfIsExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeOfIsExpressionContext typeOfIsExpression() {
		TypeOfIsExpressionContext _localctx = new TypeOfIsExpressionContext(_ctx, State);
		EnterRule(_localctx, 34, RULE_typeOfIsExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 357; Match(TYPEOF);
			State = 358; whiteSpace();
			State = 359; expression(0);
			State = 360; whiteSpace();
			State = 361; Match(IS);
			State = 362; whiteSpace();
			State = 363; typeExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NewExpressionContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public ITerminalNode NEW() { return GetToken(VBAExpressionParser.NEW, 0); }
		public TypeExpressionContext typeExpression() {
			return GetRuleContext<TypeExpressionContext>(0);
		}
		public NewExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_newExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterNewExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitNewExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNewExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NewExpressionContext newExpression() {
		NewExpressionContext _localctx = new NewExpressionContext(_ctx, State);
		EnterRule(_localctx, 36, RULE_newExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 365; Match(NEW);
			State = 366; whiteSpace();
			State = 367; typeExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LExpressionContext : ParserRuleContext {
		public LExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lExpression; } }
	 
		public LExpressionContext() { }
		public virtual void CopyFrom(LExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class IndexExprContext : LExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode LPAREN() { return GetToken(VBAExpressionParser.LPAREN, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode RPAREN() { return GetToken(VBAExpressionParser.RPAREN, 0); }
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		public IndexExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterIndexExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitIndexExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SimpleNameExprContext : LExpressionContext {
		public SimpleNameExpressionContext simpleNameExpression() {
			return GetRuleContext<SimpleNameExpressionContext>(0);
		}
		public SimpleNameExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterSimpleNameExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitSimpleNameExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleNameExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MemberAccessExprContext : LExpressionContext {
		public ITerminalNode DOT() { return GetToken(VBAExpressionParser.DOT, 0); }
		public ITerminalNode LINE_CONTINUATION() { return GetToken(VBAExpressionParser.LINE_CONTINUATION, 0); }
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public MemberAccessExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterMemberAccessExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitMemberAccessExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemberAccessExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class InstanceExprContext : LExpressionContext {
		public InstanceExpressionContext instanceExpression() {
			return GetRuleContext<InstanceExpressionContext>(0);
		}
		public InstanceExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterInstanceExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitInstanceExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInstanceExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class WithExprContext : LExpressionContext {
		public WithExpressionContext withExpression() {
			return GetRuleContext<WithExpressionContext>(0);
		}
		public WithExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterWithExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitWithExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DictionaryAccessExprContext : LExpressionContext {
		public IReadOnlyList<ITerminalNode> LINE_CONTINUATION() { return GetTokens(VBAExpressionParser.LINE_CONTINUATION); }
		public ITerminalNode EXCLAMATIONPOINT() { return GetToken(VBAExpressionParser.EXCLAMATIONPOINT, 0); }
		public ITerminalNode LINE_CONTINUATION(int i) {
			return GetToken(VBAExpressionParser.LINE_CONTINUATION, i);
		}
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public DictionaryAccessExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterDictionaryAccessExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitDictionaryAccessExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDictionaryAccessExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LExpressionContext lExpression() {
		return lExpression(0);
	}

	private LExpressionContext lExpression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		LExpressionContext _localctx = new LExpressionContext(_ctx, _parentState);
		LExpressionContext _prevctx = _localctx;
		int _startState = 38;
		EnterRecursionRule(_localctx, 38, RULE_lExpression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 373;
			switch (_input.La(1)) {
			case ME:
				{
				_localctx = new InstanceExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;

				State = 370; instanceExpression();
				}
				break;
			case ABS:
			case ANY:
			case ARRAY:
			case CBOOL:
			case CBYTE:
			case CCUR:
			case CDATE:
			case CDBL:
			case CDEC:
			case CINT:
			case CIRCLE:
			case CLNG:
			case CLNGLNG:
			case CLNGPTR:
			case CSNG:
			case CSTR:
			case CURRENCY:
			case CVAR:
			case CVERR:
			case DEBUG:
			case DOEVENTS:
			case FIX:
			case INPUTB:
			case INT:
			case LBOUND:
			case LEN:
			case LENB:
			case LONGLONG:
			case LONGPTR:
			case MIDB:
			case MIDBTYPESUFFIX:
			case MIDTYPESUFFIX:
			case PSET:
			case SCALE:
			case SGN:
			case UBOUND:
			case ACCESS:
			case ALIAS:
			case ATTRIBUTE:
			case APPEND:
			case BEGIN:
			case BINARY:
			case BOOLEAN:
			case BYTE:
			case CLASS:
			case CLOSE:
			case DATABASE:
			case DATE:
			case DOUBLE:
			case END_SELECT:
			case END_WITH:
			case END:
			case ERROR:
			case EXIT_DO:
			case EXIT_FOR:
			case EXIT_FUNCTION:
			case EXIT_PROPERTY:
			case EXIT_SUB:
			case GET:
			case INPUT:
			case INTEGER:
			case LOCK:
			case LONG:
			case LIB:
			case LINE_INPUT:
			case LOCK_READ:
			case LOCK_WRITE:
			case LOCK_READ_WRITE:
			case MID:
			case ON:
			case ON_ERROR:
			case OPEN:
			case OUTPUT:
			case PUT:
			case RANDOM:
			case READ:
			case READ_WRITE:
			case RESET:
			case SEEK:
			case SHARED:
			case SINGLE:
			case STEP:
			case STRING:
			case TAB:
			case TEXT:
			case UNLOCK:
			case VARIANT:
			case VERSION:
			case WIDTH:
			case WRITE:
			case IDENTIFIER:
			case FOREIGNNAME:
			case OBJECT:
			case COLLECTION:
				{
				_localctx = new SimpleNameExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 371; simpleNameExpression();
				}
				break;
			case EXCLAMATIONPOINT:
			case DOT:
				{
				_localctx = new WithExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 372; withExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			_ctx.stop = _input.Lt(-1);
			State = 414;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,55,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 412;
					switch ( Interpreter.AdaptivePredict(_input,54,_ctx) ) {
					case 1:
						{
						_localctx = new IndexExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 375;
						if (!(Precpred(_ctx, 9))) throw new FailedPredicateException(this, "Precpred(_ctx, 9)");
						State = 377;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 376; whiteSpace();
							}
						}

						State = 379; Match(LPAREN);
						State = 381;
						switch ( Interpreter.AdaptivePredict(_input,50,_ctx) ) {
						case 1:
							{
							State = 380; whiteSpace();
							}
							break;
						}
						State = 384;
						switch ( Interpreter.AdaptivePredict(_input,51,_ctx) ) {
						case 1:
							{
							State = 383; argumentList();
							}
							break;
						}
						State = 387;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 386; whiteSpace();
							}
						}

						State = 389; Match(RPAREN);
						}
						break;

					case 2:
						{
						_localctx = new MemberAccessExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 390;
						if (!(Precpred(_ctx, 8))) throw new FailedPredicateException(this, "Precpred(_ctx, 8)");
						State = 391; Match(DOT);
						State = 392; unrestrictedName();
						}
						break;

					case 3:
						{
						_localctx = new MemberAccessExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 393;
						if (!(Precpred(_ctx, 7))) throw new FailedPredicateException(this, "Precpred(_ctx, 7)");
						State = 394; Match(LINE_CONTINUATION);
						State = 396;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 395; whiteSpace();
							}
						}

						State = 398; Match(DOT);
						State = 399; unrestrictedName();
						}
						break;

					case 4:
						{
						_localctx = new DictionaryAccessExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 400;
						if (!(Precpred(_ctx, 6))) throw new FailedPredicateException(this, "Precpred(_ctx, 6)");
						State = 401; Match(EXCLAMATIONPOINT);
						State = 402; unrestrictedName();
						}
						break;

					case 5:
						{
						_localctx = new DictionaryAccessExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 403;
						if (!(Precpred(_ctx, 5))) throw new FailedPredicateException(this, "Precpred(_ctx, 5)");
						State = 404; Match(LINE_CONTINUATION);
						State = 405; Match(EXCLAMATIONPOINT);
						State = 406; unrestrictedName();
						}
						break;

					case 6:
						{
						_localctx = new DictionaryAccessExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 407;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 408; Match(LINE_CONTINUATION);
						State = 409; Match(EXCLAMATIONPOINT);
						State = 410; Match(LINE_CONTINUATION);
						State = 411; unrestrictedName();
						}
						break;
					}
					} 
				}
				State = 416;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,55,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class MemberAccessExpressionContext : ParserRuleContext {
		public ITerminalNode DOT() { return GetToken(VBAExpressionParser.DOT, 0); }
		public ITerminalNode LINE_CONTINUATION() { return GetToken(VBAExpressionParser.LINE_CONTINUATION, 0); }
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public MemberAccessExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_memberAccessExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterMemberAccessExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitMemberAccessExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemberAccessExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MemberAccessExpressionContext memberAccessExpression() {
		MemberAccessExpressionContext _localctx = new MemberAccessExpressionContext(_ctx, State);
		EnterRule(_localctx, 40, RULE_memberAccessExpression);
		int _la;
		try {
			State = 429;
			switch ( Interpreter.AdaptivePredict(_input,57,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 417; lExpression(0);
				State = 418; Match(DOT);
				State = 419; unrestrictedName();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 421; lExpression(0);
				State = 422; Match(LINE_CONTINUATION);
				State = 424;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 423; whiteSpace();
					}
				}

				State = 426; Match(DOT);
				State = 427; unrestrictedName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexExpressionContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode LPAREN() { return GetToken(VBAExpressionParser.LPAREN, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode RPAREN() { return GetToken(VBAExpressionParser.RPAREN, 0); }
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		public IndexExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterIndexExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitIndexExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IndexExpressionContext indexExpression() {
		IndexExpressionContext _localctx = new IndexExpressionContext(_ctx, State);
		EnterRule(_localctx, 42, RULE_indexExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 431; lExpression(0);
			State = 433;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 432; whiteSpace();
				}
			}

			State = 435; Match(LPAREN);
			State = 437;
			switch ( Interpreter.AdaptivePredict(_input,59,_ctx) ) {
			case 1:
				{
				State = 436; whiteSpace();
				}
				break;
			}
			State = 440;
			switch ( Interpreter.AdaptivePredict(_input,60,_ctx) ) {
			case 1:
				{
				State = 439; argumentList();
				}
				break;
			}
			State = 443;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 442; whiteSpace();
				}
			}

			State = 445; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DictionaryAccessExpressionContext : ParserRuleContext {
		public IReadOnlyList<ITerminalNode> LINE_CONTINUATION() { return GetTokens(VBAExpressionParser.LINE_CONTINUATION); }
		public ITerminalNode EXCLAMATIONPOINT() { return GetToken(VBAExpressionParser.EXCLAMATIONPOINT, 0); }
		public ITerminalNode LINE_CONTINUATION(int i) {
			return GetToken(VBAExpressionParser.LINE_CONTINUATION, i);
		}
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public DictionaryAccessExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dictionaryAccessExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterDictionaryAccessExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitDictionaryAccessExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDictionaryAccessExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DictionaryAccessExpressionContext dictionaryAccessExpression() {
		DictionaryAccessExpressionContext _localctx = new DictionaryAccessExpressionContext(_ctx, State);
		EnterRule(_localctx, 44, RULE_dictionaryAccessExpression);
		try {
			State = 462;
			switch ( Interpreter.AdaptivePredict(_input,62,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 447; lExpression(0);
				State = 448; Match(EXCLAMATIONPOINT);
				State = 449; unrestrictedName();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 451; lExpression(0);
				State = 452; Match(LINE_CONTINUATION);
				State = 453; Match(EXCLAMATIONPOINT);
				State = 454; unrestrictedName();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 456; lExpression(0);
				State = 457; Match(LINE_CONTINUATION);
				State = 458; Match(EXCLAMATIONPOINT);
				State = 459; Match(LINE_CONTINUATION);
				State = 460; unrestrictedName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentListContext : ParserRuleContext {
		public PositionalOrNamedArgumentListContext positionalOrNamedArgumentList() {
			return GetRuleContext<PositionalOrNamedArgumentListContext>(0);
		}
		public ArgumentListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argumentList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterArgumentList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitArgumentList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgumentList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentListContext argumentList() {
		ArgumentListContext _localctx = new ArgumentListContext(_ctx, State);
		EnterRule(_localctx, 46, RULE_argumentList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 464; positionalOrNamedArgumentList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PositionalOrNamedArgumentListContext : ParserRuleContext {
		public RequiredPositionalArgumentContext requiredPositionalArgument() {
			return GetRuleContext<RequiredPositionalArgumentContext>(0);
		}
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public IReadOnlyList<ITerminalNode> COMMA() { return GetTokens(VBAExpressionParser.COMMA); }
		public IReadOnlyList<PositionalArgumentContext> positionalArgument() {
			return GetRuleContexts<PositionalArgumentContext>();
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public NamedArgumentListContext namedArgumentList() {
			return GetRuleContext<NamedArgumentListContext>(0);
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(VBAExpressionParser.COMMA, i);
		}
		public PositionalArgumentContext positionalArgument(int i) {
			return GetRuleContext<PositionalArgumentContext>(i);
		}
		public PositionalOrNamedArgumentListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_positionalOrNamedArgumentList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterPositionalOrNamedArgumentList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitPositionalOrNamedArgumentList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPositionalOrNamedArgumentList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PositionalOrNamedArgumentListContext positionalOrNamedArgumentList() {
		PositionalOrNamedArgumentListContext _localctx = new PositionalOrNamedArgumentListContext(_ctx, State);
		EnterRule(_localctx, 48, RULE_positionalOrNamedArgumentList);
		int _la;
		try {
			int _alt;
			State = 498;
			switch ( Interpreter.AdaptivePredict(_input,71,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 478;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,66,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 467;
						_la = _input.La(1);
						if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABS) | (1L << ANY) | (1L << ARRAY) | (1L << CBOOL) | (1L << CBYTE) | (1L << CCUR) | (1L << CDATE) | (1L << CDBL) | (1L << CDEC) | (1L << CINT) | (1L << CIRCLE) | (1L << CLNG) | (1L << CLNGLNG) | (1L << CLNGPTR) | (1L << CSNG) | (1L << CSTR) | (1L << CURRENCY) | (1L << CVAR) | (1L << CVERR) | (1L << DEBUG) | (1L << DOEVENTS) | (1L << FIX) | (1L << INPUTB) | (1L << INT) | (1L << LBOUND) | (1L << LEN) | (1L << LENB) | (1L << LONGLONG) | (1L << LONGPTR) | (1L << MIDB) | (1L << MIDBTYPESUFFIX) | (1L << MIDTYPESUFFIX) | (1L << PSET) | (1L << SCALE) | (1L << SGN) | (1L << UBOUND) | (1L << EXCLAMATIONPOINT) | (1L << DOT) | (1L << HASH) | (1L << ACCESS) | (1L << ADDRESSOF) | (1L << ALIAS) | (1L << ATTRIBUTE) | (1L << APPEND) | (1L << BEGIN) | (1L << BINARY) | (1L << BOOLEAN) | (1L << BYVAL) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CLASS - 64)) | (1L << (CLOSE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DOUBLE - 64)) | (1L << (EMPTY - 64)) | (1L << (END_SELECT - 64)) | (1L << (END_WITH - 64)) | (1L << (END - 64)) | (1L << (ERROR - 64)) | (1L << (EXIT_DO - 64)) | (1L << (EXIT_FOR - 64)) | (1L << (EXIT_FUNCTION - 64)) | (1L << (EXIT_PROPERTY - 64)) | (1L << (EXIT_SUB - 64)) | (1L << (FALSE - 64)) | (1L << (GET - 64)) | (1L << (INPUT - 64)) | (1L << (INTEGER - 64)) | (1L << (LOCK - 64)) | (1L << (LONG - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (LIB - 128)) | (1L << (LINE_INPUT - 128)) | (1L << (LOCK_READ - 128)) | (1L << (LOCK_WRITE - 128)) | (1L << (LOCK_READ_WRITE - 128)) | (1L << (ME - 128)) | (1L << (MID - 128)) | (1L << (NEW - 128)) | (1L << (NOT - 128)) | (1L << (NOTHING - 128)) | (1L << (NULL - 128)) | (1L << (ON - 128)) | (1L << (ON_ERROR - 128)) | (1L << (OPEN - 128)) | (1L << (OUTPUT - 128)) | (1L << (PUT - 128)) | (1L << (RANDOM - 128)) | (1L << (READ - 128)) | (1L << (READ_WRITE - 128)) | (1L << (RESET - 128)) | (1L << (SEEK - 128)) | (1L << (SHARED - 128)) | (1L << (SINGLE - 128)) | (1L << (STEP - 128)) | (1L << (STRING - 128)) | (1L << (TAB - 128)) | (1L << (TEXT - 128)) | (1L << (TRUE - 128)) | (1L << (TYPEOF - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (UNLOCK - 192)) | (1L << (VARIANT - 192)) | (1L << (VERSION - 192)) | (1L << (WIDTH - 192)) | (1L << (WRITE - 192)) | (1L << (LPAREN - 192)) | (1L << (MINUS - 192)) | (1L << (STRINGLITERAL - 192)) | (1L << (OCTLITERAL - 192)) | (1L << (HEXLITERAL - 192)) | (1L << (FLOATLITERAL - 192)) | (1L << (INTEGERLITERAL - 192)) | (1L << (DATELITERAL - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (FOREIGNNAME - 192)) | (1L << (OBJECT - 192)) | (1L << (COLLECTION - 192)))) != 0)) {
							{
							State = 466; positionalArgument();
							}
						}

						State = 470;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 469; whiteSpace();
							}
						}

						State = 472; Match(COMMA);
						State = 474;
						switch ( Interpreter.AdaptivePredict(_input,65,_ctx) ) {
						case 1:
							{
							State = 473; whiteSpace();
							}
							break;
						}
						}
						} 
					}
					State = 480;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,66,_ctx);
				}
				State = 481; requiredPositionalArgument();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 494;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,70,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 483;
						_la = _input.La(1);
						if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABS) | (1L << ANY) | (1L << ARRAY) | (1L << CBOOL) | (1L << CBYTE) | (1L << CCUR) | (1L << CDATE) | (1L << CDBL) | (1L << CDEC) | (1L << CINT) | (1L << CIRCLE) | (1L << CLNG) | (1L << CLNGLNG) | (1L << CLNGPTR) | (1L << CSNG) | (1L << CSTR) | (1L << CURRENCY) | (1L << CVAR) | (1L << CVERR) | (1L << DEBUG) | (1L << DOEVENTS) | (1L << FIX) | (1L << INPUTB) | (1L << INT) | (1L << LBOUND) | (1L << LEN) | (1L << LENB) | (1L << LONGLONG) | (1L << LONGPTR) | (1L << MIDB) | (1L << MIDBTYPESUFFIX) | (1L << MIDTYPESUFFIX) | (1L << PSET) | (1L << SCALE) | (1L << SGN) | (1L << UBOUND) | (1L << EXCLAMATIONPOINT) | (1L << DOT) | (1L << HASH) | (1L << ACCESS) | (1L << ADDRESSOF) | (1L << ALIAS) | (1L << ATTRIBUTE) | (1L << APPEND) | (1L << BEGIN) | (1L << BINARY) | (1L << BOOLEAN) | (1L << BYVAL) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CLASS - 64)) | (1L << (CLOSE - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DOUBLE - 64)) | (1L << (EMPTY - 64)) | (1L << (END_SELECT - 64)) | (1L << (END_WITH - 64)) | (1L << (END - 64)) | (1L << (ERROR - 64)) | (1L << (EXIT_DO - 64)) | (1L << (EXIT_FOR - 64)) | (1L << (EXIT_FUNCTION - 64)) | (1L << (EXIT_PROPERTY - 64)) | (1L << (EXIT_SUB - 64)) | (1L << (FALSE - 64)) | (1L << (GET - 64)) | (1L << (INPUT - 64)) | (1L << (INTEGER - 64)) | (1L << (LOCK - 64)) | (1L << (LONG - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (LIB - 128)) | (1L << (LINE_INPUT - 128)) | (1L << (LOCK_READ - 128)) | (1L << (LOCK_WRITE - 128)) | (1L << (LOCK_READ_WRITE - 128)) | (1L << (ME - 128)) | (1L << (MID - 128)) | (1L << (NEW - 128)) | (1L << (NOT - 128)) | (1L << (NOTHING - 128)) | (1L << (NULL - 128)) | (1L << (ON - 128)) | (1L << (ON_ERROR - 128)) | (1L << (OPEN - 128)) | (1L << (OUTPUT - 128)) | (1L << (PUT - 128)) | (1L << (RANDOM - 128)) | (1L << (READ - 128)) | (1L << (READ_WRITE - 128)) | (1L << (RESET - 128)) | (1L << (SEEK - 128)) | (1L << (SHARED - 128)) | (1L << (SINGLE - 128)) | (1L << (STEP - 128)) | (1L << (STRING - 128)) | (1L << (TAB - 128)) | (1L << (TEXT - 128)) | (1L << (TRUE - 128)) | (1L << (TYPEOF - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (UNLOCK - 192)) | (1L << (VARIANT - 192)) | (1L << (VERSION - 192)) | (1L << (WIDTH - 192)) | (1L << (WRITE - 192)) | (1L << (LPAREN - 192)) | (1L << (MINUS - 192)) | (1L << (STRINGLITERAL - 192)) | (1L << (OCTLITERAL - 192)) | (1L << (HEXLITERAL - 192)) | (1L << (FLOATLITERAL - 192)) | (1L << (INTEGERLITERAL - 192)) | (1L << (DATELITERAL - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (FOREIGNNAME - 192)) | (1L << (OBJECT - 192)) | (1L << (COLLECTION - 192)))) != 0)) {
							{
							State = 482; positionalArgument();
							}
						}

						State = 486;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 485; whiteSpace();
							}
						}

						State = 488; Match(COMMA);
						State = 490;
						switch ( Interpreter.AdaptivePredict(_input,69,_ctx) ) {
						case 1:
							{
							State = 489; whiteSpace();
							}
							break;
						}
						}
						} 
					}
					State = 496;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,70,_ctx);
				}
				State = 497; namedArgumentList();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PositionalArgumentContext : ParserRuleContext {
		public ArgumentExpressionContext argumentExpression() {
			return GetRuleContext<ArgumentExpressionContext>(0);
		}
		public PositionalArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_positionalArgument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterPositionalArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitPositionalArgument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPositionalArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PositionalArgumentContext positionalArgument() {
		PositionalArgumentContext _localctx = new PositionalArgumentContext(_ctx, State);
		EnterRule(_localctx, 50, RULE_positionalArgument);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 500; argumentExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RequiredPositionalArgumentContext : ParserRuleContext {
		public ArgumentExpressionContext argumentExpression() {
			return GetRuleContext<ArgumentExpressionContext>(0);
		}
		public RequiredPositionalArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_requiredPositionalArgument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterRequiredPositionalArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitRequiredPositionalArgument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRequiredPositionalArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RequiredPositionalArgumentContext requiredPositionalArgument() {
		RequiredPositionalArgumentContext _localctx = new RequiredPositionalArgumentContext(_ctx, State);
		EnterRule(_localctx, 52, RULE_requiredPositionalArgument);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 502; argumentExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NamedArgumentListContext : ParserRuleContext {
		public IReadOnlyList<NamedArgumentContext> namedArgument() {
			return GetRuleContexts<NamedArgumentContext>();
		}
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public IReadOnlyList<ITerminalNode> COMMA() { return GetTokens(VBAExpressionParser.COMMA); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public NamedArgumentContext namedArgument(int i) {
			return GetRuleContext<NamedArgumentContext>(i);
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(VBAExpressionParser.COMMA, i);
		}
		public NamedArgumentListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_namedArgumentList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterNamedArgumentList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitNamedArgumentList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamedArgumentList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NamedArgumentListContext namedArgumentList() {
		NamedArgumentListContext _localctx = new NamedArgumentListContext(_ctx, State);
		EnterRule(_localctx, 54, RULE_namedArgumentList);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 504; namedArgument();
			State = 515;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,74,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 506;
					_la = _input.La(1);
					if (_la==WS || _la==LINE_CONTINUATION) {
						{
						State = 505; whiteSpace();
						}
					}

					State = 508; Match(COMMA);
					State = 510;
					_la = _input.La(1);
					if (_la==WS || _la==LINE_CONTINUATION) {
						{
						State = 509; whiteSpace();
						}
					}

					State = 512; namedArgument();
					}
					} 
				}
				State = 517;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,74,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NamedArgumentContext : ParserRuleContext {
		public ITerminalNode ASSIGN() { return GetToken(VBAExpressionParser.ASSIGN, 0); }
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ArgumentExpressionContext argumentExpression() {
			return GetRuleContext<ArgumentExpressionContext>(0);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public NamedArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_namedArgument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterNamedArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitNamedArgument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamedArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NamedArgumentContext namedArgument() {
		NamedArgumentContext _localctx = new NamedArgumentContext(_ctx, State);
		EnterRule(_localctx, 56, RULE_namedArgument);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 518; unrestrictedName();
			State = 520;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 519; whiteSpace();
				}
			}

			State = 522; Match(ASSIGN);
			State = 524;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 523; whiteSpace();
				}
			}

			State = 526; argumentExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentExpressionContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public AddressOfExpressionContext addressOfExpression() {
			return GetRuleContext<AddressOfExpressionContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode BYVAL() { return GetToken(VBAExpressionParser.BYVAL, 0); }
		public ArgumentExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argumentExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterArgumentExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitArgumentExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgumentExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentExpressionContext argumentExpression() {
		ArgumentExpressionContext _localctx = new ArgumentExpressionContext(_ctx, State);
		EnterRule(_localctx, 58, RULE_argumentExpression);
		int _la;
		try {
			State = 534;
			switch (_input.La(1)) {
			case ABS:
			case ANY:
			case ARRAY:
			case CBOOL:
			case CBYTE:
			case CCUR:
			case CDATE:
			case CDBL:
			case CDEC:
			case CINT:
			case CIRCLE:
			case CLNG:
			case CLNGLNG:
			case CLNGPTR:
			case CSNG:
			case CSTR:
			case CURRENCY:
			case CVAR:
			case CVERR:
			case DEBUG:
			case DOEVENTS:
			case FIX:
			case INPUTB:
			case INT:
			case LBOUND:
			case LEN:
			case LENB:
			case LONGLONG:
			case LONGPTR:
			case MIDB:
			case MIDBTYPESUFFIX:
			case MIDTYPESUFFIX:
			case PSET:
			case SCALE:
			case SGN:
			case UBOUND:
			case EXCLAMATIONPOINT:
			case DOT:
			case HASH:
			case ACCESS:
			case ALIAS:
			case ATTRIBUTE:
			case APPEND:
			case BEGIN:
			case BINARY:
			case BOOLEAN:
			case BYVAL:
			case BYTE:
			case CLASS:
			case CLOSE:
			case DATABASE:
			case DATE:
			case DOUBLE:
			case EMPTY:
			case END_SELECT:
			case END_WITH:
			case END:
			case ERROR:
			case EXIT_DO:
			case EXIT_FOR:
			case EXIT_FUNCTION:
			case EXIT_PROPERTY:
			case EXIT_SUB:
			case FALSE:
			case GET:
			case INPUT:
			case INTEGER:
			case LOCK:
			case LONG:
			case LIB:
			case LINE_INPUT:
			case LOCK_READ:
			case LOCK_WRITE:
			case LOCK_READ_WRITE:
			case ME:
			case MID:
			case NEW:
			case NOT:
			case NOTHING:
			case NULL:
			case ON:
			case ON_ERROR:
			case OPEN:
			case OUTPUT:
			case PUT:
			case RANDOM:
			case READ:
			case READ_WRITE:
			case RESET:
			case SEEK:
			case SHARED:
			case SINGLE:
			case STEP:
			case STRING:
			case TAB:
			case TEXT:
			case TRUE:
			case TYPEOF:
			case UNLOCK:
			case VARIANT:
			case VERSION:
			case WIDTH:
			case WRITE:
			case LPAREN:
			case MINUS:
			case STRINGLITERAL:
			case OCTLITERAL:
			case HEXLITERAL:
			case FLOATLITERAL:
			case INTEGERLITERAL:
			case DATELITERAL:
			case IDENTIFIER:
			case FOREIGNNAME:
			case OBJECT:
			case COLLECTION:
				EnterOuterAlt(_localctx, 1);
				{
				State = 530;
				_la = _input.La(1);
				if (_la==BYVAL) {
					{
					State = 528; Match(BYVAL);
					State = 529; whiteSpace();
					}
				}

				State = 532; expression(0);
				}
				break;
			case ADDRESSOF:
				EnterOuterAlt(_localctx, 2);
				{
				State = 533; addressOfExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleNameExpressionContext : ParserRuleContext {
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public SimpleNameExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleNameExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterSimpleNameExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitSimpleNameExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleNameExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SimpleNameExpressionContext simpleNameExpression() {
		SimpleNameExpressionContext _localctx = new SimpleNameExpressionContext(_ctx, State);
		EnterRule(_localctx, 60, RULE_simpleNameExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 536; name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InstanceExpressionContext : ParserRuleContext {
		public ITerminalNode ME() { return GetToken(VBAExpressionParser.ME, 0); }
		public InstanceExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_instanceExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterInstanceExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitInstanceExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInstanceExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InstanceExpressionContext instanceExpression() {
		InstanceExpressionContext _localctx = new InstanceExpressionContext(_ctx, State);
		EnterRule(_localctx, 62, RULE_instanceExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 538; Match(ME);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithExpressionContext : ParserRuleContext {
		public WithDictionaryAccessExpressionContext withDictionaryAccessExpression() {
			return GetRuleContext<WithDictionaryAccessExpressionContext>(0);
		}
		public WithMemberAccessExpressionContext withMemberAccessExpression() {
			return GetRuleContext<WithMemberAccessExpressionContext>(0);
		}
		public WithExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterWithExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitWithExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WithExpressionContext withExpression() {
		WithExpressionContext _localctx = new WithExpressionContext(_ctx, State);
		EnterRule(_localctx, 64, RULE_withExpression);
		try {
			State = 542;
			switch (_input.La(1)) {
			case DOT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 540; withMemberAccessExpression();
				}
				break;
			case EXCLAMATIONPOINT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 541; withDictionaryAccessExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithMemberAccessExpressionContext : ParserRuleContext {
		public ITerminalNode DOT() { return GetToken(VBAExpressionParser.DOT, 0); }
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public WithMemberAccessExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withMemberAccessExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterWithMemberAccessExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitWithMemberAccessExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithMemberAccessExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WithMemberAccessExpressionContext withMemberAccessExpression() {
		WithMemberAccessExpressionContext _localctx = new WithMemberAccessExpressionContext(_ctx, State);
		EnterRule(_localctx, 66, RULE_withMemberAccessExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 544; Match(DOT);
			State = 545; unrestrictedName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithDictionaryAccessExpressionContext : ParserRuleContext {
		public ITerminalNode EXCLAMATIONPOINT() { return GetToken(VBAExpressionParser.EXCLAMATIONPOINT, 0); }
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public WithDictionaryAccessExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withDictionaryAccessExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterWithDictionaryAccessExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitWithDictionaryAccessExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithDictionaryAccessExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WithDictionaryAccessExpressionContext withDictionaryAccessExpression() {
		WithDictionaryAccessExpressionContext _localctx = new WithDictionaryAccessExpressionContext(_ctx, State);
		EnterRule(_localctx, 68, RULE_withDictionaryAccessExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 547; Match(EXCLAMATIONPOINT);
			State = 548; unrestrictedName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantExpressionContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ConstantExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constantExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterConstantExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitConstantExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstantExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantExpressionContext constantExpression() {
		ConstantExpressionContext _localctx = new ConstantExpressionContext(_ctx, State);
		EnterRule(_localctx, 70, RULE_constantExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 550; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeExpressionContext : ParserRuleContext {
		public DefinedTypeExpressionContext definedTypeExpression() {
			return GetRuleContext<DefinedTypeExpressionContext>(0);
		}
		public BuiltInTypeContext builtInType() {
			return GetRuleContext<BuiltInTypeContext>(0);
		}
		public TypeExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypeExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypeExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeExpressionContext typeExpression() {
		TypeExpressionContext _localctx = new TypeExpressionContext(_ctx, State);
		EnterRule(_localctx, 72, RULE_typeExpression);
		try {
			State = 554;
			switch ( Interpreter.AdaptivePredict(_input,80,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 552; builtInType();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 553; definedTypeExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DefinedTypeExpressionContext : ParserRuleContext {
		public MemberAccessExpressionContext memberAccessExpression() {
			return GetRuleContext<MemberAccessExpressionContext>(0);
		}
		public SimpleNameExpressionContext simpleNameExpression() {
			return GetRuleContext<SimpleNameExpressionContext>(0);
		}
		public DefinedTypeExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_definedTypeExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterDefinedTypeExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitDefinedTypeExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefinedTypeExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DefinedTypeExpressionContext definedTypeExpression() {
		DefinedTypeExpressionContext _localctx = new DefinedTypeExpressionContext(_ctx, State);
		EnterRule(_localctx, 74, RULE_definedTypeExpression);
		try {
			State = 558;
			switch ( Interpreter.AdaptivePredict(_input,81,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 556; simpleNameExpression();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 557; memberAccessExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AddressOfExpressionContext : ParserRuleContext {
		public ITerminalNode ADDRESSOF() { return GetToken(VBAExpressionParser.ADDRESSOF, 0); }
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public ProcedurePointerExpressionContext procedurePointerExpression() {
			return GetRuleContext<ProcedurePointerExpressionContext>(0);
		}
		public AddressOfExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_addressOfExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterAddressOfExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitAddressOfExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAddressOfExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AddressOfExpressionContext addressOfExpression() {
		AddressOfExpressionContext _localctx = new AddressOfExpressionContext(_ctx, State);
		EnterRule(_localctx, 76, RULE_addressOfExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 560; Match(ADDRESSOF);
			State = 561; whiteSpace();
			State = 562; procedurePointerExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedurePointerExpressionContext : ParserRuleContext {
		public MemberAccessExpressionContext memberAccessExpression() {
			return GetRuleContext<MemberAccessExpressionContext>(0);
		}
		public SimpleNameExpressionContext simpleNameExpression() {
			return GetRuleContext<SimpleNameExpressionContext>(0);
		}
		public ProcedurePointerExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedurePointerExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterProcedurePointerExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitProcedurePointerExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProcedurePointerExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProcedurePointerExpressionContext procedurePointerExpression() {
		ProcedurePointerExpressionContext _localctx = new ProcedurePointerExpressionContext(_ctx, State);
		EnterRule(_localctx, 78, RULE_procedurePointerExpression);
		try {
			State = 566;
			switch ( Interpreter.AdaptivePredict(_input,82,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 564; memberAccessExpression();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 565; simpleNameExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedIdentifierContext : ParserRuleContext {
		public MarkerKeywordContext markerKeyword() {
			return GetRuleContext<MarkerKeywordContext>(0);
		}
		public SpecialFormContext specialForm() {
			return GetRuleContext<SpecialFormContext>(0);
		}
		public ReservedTypeIdentifierContext reservedTypeIdentifier() {
			return GetRuleContext<ReservedTypeIdentifierContext>(0);
		}
		public OperatorIdentifierContext operatorIdentifier() {
			return GetRuleContext<OperatorIdentifierContext>(0);
		}
		public RemKeywordContext remKeyword() {
			return GetRuleContext<RemKeywordContext>(0);
		}
		public ReservedNameContext reservedName() {
			return GetRuleContext<ReservedNameContext>(0);
		}
		public StatementKeywordContext statementKeyword() {
			return GetRuleContext<StatementKeywordContext>(0);
		}
		public LiteralIdentifierContext literalIdentifier() {
			return GetRuleContext<LiteralIdentifierContext>(0);
		}
		public ReservedIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedIdentifierContext reservedIdentifier() {
		ReservedIdentifierContext _localctx = new ReservedIdentifierContext(_ctx, State);
		EnterRule(_localctx, 80, RULE_reservedIdentifier);
		try {
			State = 576;
			switch ( Interpreter.AdaptivePredict(_input,83,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 568; statementKeyword();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 569; markerKeyword();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 570; operatorIdentifier();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 571; specialForm();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 572; reservedName();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 573; literalIdentifier();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 574; remKeyword();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 575; reservedTypeIdentifier();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementKeywordContext : ParserRuleContext {
		public ITerminalNode CASE() { return GetToken(VBAExpressionParser.CASE, 0); }
		public ITerminalNode DEFOBJ() { return GetToken(VBAExpressionParser.DEFOBJ, 0); }
		public ITerminalNode ELSE() { return GetToken(VBAExpressionParser.ELSE, 0); }
		public ITerminalNode IF() { return GetToken(VBAExpressionParser.IF, 0); }
		public ITerminalNode ERASE() { return GetToken(VBAExpressionParser.ERASE, 0); }
		public ITerminalNode END_IF() { return GetToken(VBAExpressionParser.END_IF, 0); }
		public ITerminalNode RAISEEVENT() { return GetToken(VBAExpressionParser.RAISEEVENT, 0); }
		public ITerminalNode STOP() { return GetToken(VBAExpressionParser.STOP, 0); }
		public ITerminalNode PRIVATE() { return GetToken(VBAExpressionParser.PRIVATE, 0); }
		public ITerminalNode DEFBYTE() { return GetToken(VBAExpressionParser.DEFBYTE, 0); }
		public ITerminalNode DEFSNG() { return GetToken(VBAExpressionParser.DEFSNG, 0); }
		public ITerminalNode GOSUB() { return GetToken(VBAExpressionParser.GOSUB, 0); }
		public ITerminalNode RETURN() { return GetToken(VBAExpressionParser.RETURN, 0); }
		public ITerminalNode ENUM() { return GetToken(VBAExpressionParser.ENUM, 0); }
		public ITerminalNode GLOBAL() { return GetToken(VBAExpressionParser.GLOBAL, 0); }
		public ITerminalNode WEND() { return GetToken(VBAExpressionParser.WEND, 0); }
		public ITerminalNode DEFSTR() { return GetToken(VBAExpressionParser.DEFSTR, 0); }
		public ITerminalNode DEFLNGLNG() { return GetToken(VBAExpressionParser.DEFLNGLNG, 0); }
		public ITerminalNode DEFVAR() { return GetToken(VBAExpressionParser.DEFVAR, 0); }
		public ITerminalNode EVENT() { return GetToken(VBAExpressionParser.EVENT, 0); }
		public ITerminalNode CONST() { return GetToken(VBAExpressionParser.CONST, 0); }
		public ITerminalNode ELSEIF() { return GetToken(VBAExpressionParser.ELSEIF, 0); }
		public ITerminalNode PRINT() { return GetToken(VBAExpressionParser.PRINT, 0); }
		public ITerminalNode DEFINT() { return GetToken(VBAExpressionParser.DEFINT, 0); }
		public ITerminalNode SUB() { return GetToken(VBAExpressionParser.SUB, 0); }
		public ITerminalNode FOR() { return GetToken(VBAExpressionParser.FOR, 0); }
		public ITerminalNode LSET() { return GetToken(VBAExpressionParser.LSET, 0); }
		public ITerminalNode LOOP() { return GetToken(VBAExpressionParser.LOOP, 0); }
		public ITerminalNode DEFCUR() { return GetToken(VBAExpressionParser.DEFCUR, 0); }
		public ITerminalNode PUBLIC() { return GetToken(VBAExpressionParser.PUBLIC, 0); }
		public ITerminalNode DEFDATE() { return GetToken(VBAExpressionParser.DEFDATE, 0); }
		public ITerminalNode LET() { return GetToken(VBAExpressionParser.LET, 0); }
		public ITerminalNode FRIEND() { return GetToken(VBAExpressionParser.FRIEND, 0); }
		public ITerminalNode TYPE() { return GetToken(VBAExpressionParser.TYPE, 0); }
		public ITerminalNode CALL() { return GetToken(VBAExpressionParser.CALL, 0); }
		public ITerminalNode DEFBOOL() { return GetToken(VBAExpressionParser.DEFBOOL, 0); }
		public ITerminalNode STATIC() { return GetToken(VBAExpressionParser.STATIC, 0); }
		public ITerminalNode DO() { return GetToken(VBAExpressionParser.DO, 0); }
		public ITerminalNode DIM() { return GetToken(VBAExpressionParser.DIM, 0); }
		public ITerminalNode OPTION() { return GetToken(VBAExpressionParser.OPTION, 0); }
		public ITerminalNode DEFLNG() { return GetToken(VBAExpressionParser.DEFLNG, 0); }
		public ITerminalNode IMPLEMENTS() { return GetToken(VBAExpressionParser.IMPLEMENTS, 0); }
		public ITerminalNode ON() { return GetToken(VBAExpressionParser.ON, 0); }
		public ITerminalNode WITH() { return GetToken(VBAExpressionParser.WITH, 0); }
		public ITerminalNode DECLARE() { return GetToken(VBAExpressionParser.DECLARE, 0); }
		public ITerminalNode RESUME() { return GetToken(VBAExpressionParser.RESUME, 0); }
		public ITerminalNode DEFLNGPTR() { return GetToken(VBAExpressionParser.DEFLNGPTR, 0); }
		public ITerminalNode WHILE() { return GetToken(VBAExpressionParser.WHILE, 0); }
		public ITerminalNode EXIT() { return GetToken(VBAExpressionParser.EXIT, 0); }
		public ITerminalNode DEFDBL() { return GetToken(VBAExpressionParser.DEFDBL, 0); }
		public ITerminalNode NEXT() { return GetToken(VBAExpressionParser.NEXT, 0); }
		public ITerminalNode FUNCTION() { return GetToken(VBAExpressionParser.FUNCTION, 0); }
		public ITerminalNode RSET() { return GetToken(VBAExpressionParser.RSET, 0); }
		public ITerminalNode GOTO() { return GetToken(VBAExpressionParser.GOTO, 0); }
		public ITerminalNode REDIM() { return GetToken(VBAExpressionParser.REDIM, 0); }
		public ITerminalNode SELECT() { return GetToken(VBAExpressionParser.SELECT, 0); }
		public ITerminalNode SET() { return GetToken(VBAExpressionParser.SET, 0); }
		public StatementKeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statementKeyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterStatementKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitStatementKeyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatementKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementKeywordContext statementKeyword() {
		StatementKeywordContext _localctx = new StatementKeywordContext(_ctx, State);
		EnterRule(_localctx, 82, RULE_statementKeyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 578;
			_la = _input.La(1);
			if ( !(((((_la - 22)) & ~0x3f) == 0 && ((1L << (_la - 22)) & ((1L << (EXIT - 22)) | (1L << (OPTION - 22)) | (1L << (CALL - 22)) | (1L << (CASE - 22)) | (1L << (CONST - 22)) | (1L << (DECLARE - 22)) | (1L << (DEFBOOL - 22)) | (1L << (DEFBYTE - 22)) | (1L << (DEFDATE - 22)) | (1L << (DEFDBL - 22)) | (1L << (DEFCUR - 22)) | (1L << (DEFINT - 22)) | (1L << (DEFLNG - 22)) | (1L << (DEFLNGLNG - 22)) | (1L << (DEFLNGPTR - 22)) | (1L << (DEFOBJ - 22)) | (1L << (DEFSNG - 22)) | (1L << (DEFSTR - 22)) | (1L << (DEFVAR - 22)) | (1L << (DIM - 22)) | (1L << (DO - 22)))) != 0) || ((((_la - 87)) & ~0x3f) == 0 && ((1L << (_la - 87)) & ((1L << (ELSE - 87)) | (1L << (ELSEIF - 87)) | (1L << (END_IF - 87)) | (1L << (ENUM - 87)) | (1L << (ERASE - 87)) | (1L << (EVENT - 87)) | (1L << (FRIEND - 87)) | (1L << (FOR - 87)) | (1L << (FUNCTION - 87)) | (1L << (GLOBAL - 87)) | (1L << (GOSUB - 87)) | (1L << (GOTO - 87)) | (1L << (IF - 87)) | (1L << (IMPLEMENTS - 87)) | (1L << (LOOP - 87)) | (1L << (LET - 87)) | (1L << (LSET - 87)) | (1L << (NEXT - 87)) | (1L << (ON - 87)))) != 0) || ((((_la - 156)) & ~0x3f) == 0 && ((1L << (_la - 156)) & ((1L << (PRINT - 156)) | (1L << (PRIVATE - 156)) | (1L << (PUBLIC - 156)) | (1L << (RAISEEVENT - 156)) | (1L << (REDIM - 156)) | (1L << (RESUME - 156)) | (1L << (RETURN - 156)) | (1L << (RSET - 156)) | (1L << (SELECT - 156)) | (1L << (SET - 156)) | (1L << (STATIC - 156)) | (1L << (STOP - 156)) | (1L << (SUB - 156)) | (1L << (TYPE - 156)) | (1L << (WEND - 156)) | (1L << (WHILE - 156)) | (1L << (WITH - 156)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RemKeywordContext : ParserRuleContext {
		public ITerminalNode REM() { return GetToken(VBAExpressionParser.REM, 0); }
		public RemKeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_remKeyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterRemKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitRemKeyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRemKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RemKeywordContext remKeyword() {
		RemKeywordContext _localctx = new RemKeywordContext(_ctx, State);
		EnterRule(_localctx, 84, RULE_remKeyword);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 580; Match(REM);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MarkerKeywordContext : ParserRuleContext {
		public ITerminalNode CASE() { return GetToken(VBAExpressionParser.CASE, 0); }
		public ITerminalNode ELSE() { return GetToken(VBAExpressionParser.ELSE, 0); }
		public ITerminalNode THEN() { return GetToken(VBAExpressionParser.THEN, 0); }
		public ITerminalNode WRITE() { return GetToken(VBAExpressionParser.WRITE, 0); }
		public ITerminalNode PRESERVE() { return GetToken(VBAExpressionParser.PRESERVE, 0); }
		public ITerminalNode SPC() { return GetToken(VBAExpressionParser.SPC, 0); }
		public ITerminalNode TO() { return GetToken(VBAExpressionParser.TO, 0); }
		public ITerminalNode EACH() { return GetToken(VBAExpressionParser.EACH, 0); }
		public ITerminalNode SHARED() { return GetToken(VBAExpressionParser.SHARED, 0); }
		public ITerminalNode ANY() { return GetToken(VBAExpressionParser.ANY, 0); }
		public ITerminalNode NEW() { return GetToken(VBAExpressionParser.NEW, 0); }
		public ITerminalNode AS() { return GetToken(VBAExpressionParser.AS, 0); }
		public ITerminalNode BYVAL() { return GetToken(VBAExpressionParser.BYVAL, 0); }
		public ITerminalNode IN() { return GetToken(VBAExpressionParser.IN, 0); }
		public ITerminalNode TAB() { return GetToken(VBAExpressionParser.TAB, 0); }
		public ITerminalNode BYREF() { return GetToken(VBAExpressionParser.BYREF, 0); }
		public ITerminalNode OPTIONAL() { return GetToken(VBAExpressionParser.OPTIONAL, 0); }
		public ITerminalNode UNTIL() { return GetToken(VBAExpressionParser.UNTIL, 0); }
		public ITerminalNode PARAMARRAY() { return GetToken(VBAExpressionParser.PARAMARRAY, 0); }
		public ITerminalNode WITHEVENTS() { return GetToken(VBAExpressionParser.WITHEVENTS, 0); }
		public MarkerKeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_markerKeyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterMarkerKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitMarkerKeyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMarkerKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MarkerKeywordContext markerKeyword() {
		MarkerKeywordContext _localctx = new MarkerKeywordContext(_ctx, State);
		EnterRule(_localctx, 86, RULE_markerKeyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 582;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ANY) | (1L << AS) | (1L << BYVAL) | (1L << BYREF) | (1L << CASE))) != 0) || ((((_la - 86)) & ~0x3f) == 0 && ((1L << (_la - 86)) & ((1L << (EACH - 86)) | (1L << (ELSE - 86)) | (1L << (IN - 86)) | (1L << (NEW - 86)) | (1L << (OPTIONAL - 86)))) != 0) || ((((_la - 154)) & ~0x3f) == 0 && ((1L << (_la - 154)) & ((1L << (PARAMARRAY - 154)) | (1L << (PRESERVE - 154)) | (1L << (SHARED - 154)) | (1L << (SPC - 154)) | (1L << (TAB - 154)) | (1L << (THEN - 154)) | (1L << (TO - 154)) | (1L << (UNTIL - 154)) | (1L << (WITHEVENTS - 154)) | (1L << (WRITE - 154)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OperatorIdentifierContext : ParserRuleContext {
		public ITerminalNode NOT() { return GetToken(VBAExpressionParser.NOT, 0); }
		public ITerminalNode IS() { return GetToken(VBAExpressionParser.IS, 0); }
		public ITerminalNode XOR() { return GetToken(VBAExpressionParser.XOR, 0); }
		public ITerminalNode EQV() { return GetToken(VBAExpressionParser.EQV, 0); }
		public ITerminalNode ADDRESSOF() { return GetToken(VBAExpressionParser.ADDRESSOF, 0); }
		public ITerminalNode AND() { return GetToken(VBAExpressionParser.AND, 0); }
		public ITerminalNode TYPEOF() { return GetToken(VBAExpressionParser.TYPEOF, 0); }
		public ITerminalNode LIKE() { return GetToken(VBAExpressionParser.LIKE, 0); }
		public ITerminalNode MOD() { return GetToken(VBAExpressionParser.MOD, 0); }
		public ITerminalNode OR() { return GetToken(VBAExpressionParser.OR, 0); }
		public ITerminalNode IMP() { return GetToken(VBAExpressionParser.IMP, 0); }
		public ITerminalNode NEW() { return GetToken(VBAExpressionParser.NEW, 0); }
		public OperatorIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_operatorIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterOperatorIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitOperatorIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOperatorIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OperatorIdentifierContext operatorIdentifier() {
		OperatorIdentifierContext _localctx = new OperatorIdentifierContext(_ctx, State);
		EnterRule(_localctx, 88, RULE_operatorIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 584;
			_la = _input.La(1);
			if ( !(_la==ADDRESSOF || _la==AND || ((((_la - 100)) & ~0x3f) == 0 && ((1L << (_la - 100)) & ((1L << (EQV - 100)) | (1L << (IMP - 100)) | (1L << (IS - 100)) | (1L << (LIKE - 100)) | (1L << (MOD - 100)) | (1L << (NEW - 100)) | (1L << (NOT - 100)) | (1L << (OR - 100)))) != 0) || _la==TYPEOF || _la==XOR) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedNameContext : ParserRuleContext {
		public ITerminalNode ME() { return GetToken(VBAExpressionParser.ME, 0); }
		public ReservedProcedureNameContext reservedProcedureName() {
			return GetRuleContext<ReservedProcedureNameContext>(0);
		}
		public ReservedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedNameContext reservedName() {
		ReservedNameContext _localctx = new ReservedNameContext(_ctx, State);
		EnterRule(_localctx, 90, RULE_reservedName);
		try {
			State = 588;
			switch (_input.La(1)) {
			case ME:
				EnterOuterAlt(_localctx, 1);
				{
				State = 586; Match(ME);
				}
				break;
			case ABS:
			case CBOOL:
			case CBYTE:
			case CCUR:
			case CDATE:
			case CDBL:
			case CDEC:
			case CINT:
			case CLNG:
			case CLNGLNG:
			case CLNGPTR:
			case CSNG:
			case CSTR:
			case CVAR:
			case CVERR:
			case DEBUG:
			case DOEVENTS:
			case FIX:
			case INT:
			case LEN:
			case LENB:
			case MIDB:
			case MIDBTYPESUFFIX:
			case MIDTYPESUFFIX:
			case PSET:
			case SCALE:
			case SGN:
			case ACCESS:
			case APPEND:
			case BINARY:
			case CLOSE:
			case END_SELECT:
			case END_WITH:
			case END:
			case ERROR:
			case EXIT_DO:
			case EXIT_FOR:
			case EXIT_FUNCTION:
			case EXIT_PROPERTY:
			case EXIT_SUB:
			case GET:
			case INPUT:
			case LOCK:
			case LINE_INPUT:
			case LOCK_READ:
			case LOCK_WRITE:
			case LOCK_READ_WRITE:
			case MID:
			case ON_ERROR:
			case OPEN:
			case OUTPUT:
			case PUT:
			case RANDOM:
			case READ:
			case READ_WRITE:
			case RESET:
			case SEEK:
			case SHARED:
			case STEP:
			case UNLOCK:
			case WIDTH:
			case WRITE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 587; reservedProcedureName();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedProcedureNameContext : ParserRuleContext {
		public ITerminalNode LOCK_WRITE() { return GetToken(VBAExpressionParser.LOCK_WRITE, 0); }
		public ITerminalNode CLNGLNG() { return GetToken(VBAExpressionParser.CLNGLNG, 0); }
		public ITerminalNode RESET() { return GetToken(VBAExpressionParser.RESET, 0); }
		public ITerminalNode END_SELECT() { return GetToken(VBAExpressionParser.END_SELECT, 0); }
		public ITerminalNode ON_ERROR() { return GetToken(VBAExpressionParser.ON_ERROR, 0); }
		public ITerminalNode WRITE(int i) {
			return GetToken(VBAExpressionParser.WRITE, i);
		}
		public ITerminalNode SHARED() { return GetToken(VBAExpressionParser.SHARED, 0); }
		public ITerminalNode LENB() { return GetToken(VBAExpressionParser.LENB, 0); }
		public ITerminalNode APPEND() { return GetToken(VBAExpressionParser.APPEND, 0); }
		public ITerminalNode SCALE() { return GetToken(VBAExpressionParser.SCALE, 0); }
		public ITerminalNode MIDTYPESUFFIX() { return GetToken(VBAExpressionParser.MIDTYPESUFFIX, 0); }
		public ITerminalNode DEBUG() { return GetToken(VBAExpressionParser.DEBUG, 0); }
		public ITerminalNode CLNGPTR() { return GetToken(VBAExpressionParser.CLNGPTR, 0); }
		public ITerminalNode LOCK() { return GetToken(VBAExpressionParser.LOCK, 0); }
		public ITerminalNode EXIT_DO() { return GetToken(VBAExpressionParser.EXIT_DO, 0); }
		public ITerminalNode CDEC() { return GetToken(VBAExpressionParser.CDEC, 0); }
		public ITerminalNode WIDTH() { return GetToken(VBAExpressionParser.WIDTH, 0); }
		public ITerminalNode CSNG() { return GetToken(VBAExpressionParser.CSNG, 0); }
		public ITerminalNode STEP() { return GetToken(VBAExpressionParser.STEP, 0); }
		public ITerminalNode INPUT() { return GetToken(VBAExpressionParser.INPUT, 0); }
		public ITerminalNode SEEK() { return GetToken(VBAExpressionParser.SEEK, 0); }
		public ITerminalNode BINARY() { return GetToken(VBAExpressionParser.BINARY, 0); }
		public ITerminalNode RANDOM() { return GetToken(VBAExpressionParser.RANDOM, 0); }
		public ITerminalNode CBOOL() { return GetToken(VBAExpressionParser.CBOOL, 0); }
		public ITerminalNode MIDBTYPESUFFIX() { return GetToken(VBAExpressionParser.MIDBTYPESUFFIX, 0); }
		public ITerminalNode SGN() { return GetToken(VBAExpressionParser.SGN, 0); }
		public ITerminalNode CBYTE() { return GetToken(VBAExpressionParser.CBYTE, 0); }
		public ITerminalNode CVERR() { return GetToken(VBAExpressionParser.CVERR, 0); }
		public ITerminalNode FIX() { return GetToken(VBAExpressionParser.FIX, 0); }
		public ITerminalNode PUT() { return GetToken(VBAExpressionParser.PUT, 0); }
		public ITerminalNode CVAR() { return GetToken(VBAExpressionParser.CVAR, 0); }
		public ITerminalNode CSTR() { return GetToken(VBAExpressionParser.CSTR, 0); }
		public ITerminalNode CDATE() { return GetToken(VBAExpressionParser.CDATE, 0); }
		public ITerminalNode CINT() { return GetToken(VBAExpressionParser.CINT, 0); }
		public ITerminalNode ERROR() { return GetToken(VBAExpressionParser.ERROR, 0); }
		public ITerminalNode ABS() { return GetToken(VBAExpressionParser.ABS, 0); }
		public ITerminalNode READ() { return GetToken(VBAExpressionParser.READ, 0); }
		public ITerminalNode INT() { return GetToken(VBAExpressionParser.INT, 0); }
		public ITerminalNode OPEN() { return GetToken(VBAExpressionParser.OPEN, 0); }
		public ITerminalNode LOCK_READ() { return GetToken(VBAExpressionParser.LOCK_READ, 0); }
		public ITerminalNode DOEVENTS() { return GetToken(VBAExpressionParser.DOEVENTS, 0); }
		public ITerminalNode OUTPUT() { return GetToken(VBAExpressionParser.OUTPUT, 0); }
		public ITerminalNode CLOSE() { return GetToken(VBAExpressionParser.CLOSE, 0); }
		public ITerminalNode LINE_INPUT() { return GetToken(VBAExpressionParser.LINE_INPUT, 0); }
		public ITerminalNode MID() { return GetToken(VBAExpressionParser.MID, 0); }
		public ITerminalNode ACCESS() { return GetToken(VBAExpressionParser.ACCESS, 0); }
		public ITerminalNode EXIT_SUB() { return GetToken(VBAExpressionParser.EXIT_SUB, 0); }
		public ITerminalNode LOCK_READ_WRITE() { return GetToken(VBAExpressionParser.LOCK_READ_WRITE, 0); }
		public ITerminalNode MIDB() { return GetToken(VBAExpressionParser.MIDB, 0); }
		public IReadOnlyList<ITerminalNode> WRITE() { return GetTokens(VBAExpressionParser.WRITE); }
		public ITerminalNode LEN() { return GetToken(VBAExpressionParser.LEN, 0); }
		public ITerminalNode CCUR() { return GetToken(VBAExpressionParser.CCUR, 0); }
		public ITerminalNode EXIT_FOR() { return GetToken(VBAExpressionParser.EXIT_FOR, 0); }
		public ITerminalNode GET() { return GetToken(VBAExpressionParser.GET, 0); }
		public ITerminalNode END_WITH() { return GetToken(VBAExpressionParser.END_WITH, 0); }
		public ITerminalNode EXIT_PROPERTY() { return GetToken(VBAExpressionParser.EXIT_PROPERTY, 0); }
		public ITerminalNode END() { return GetToken(VBAExpressionParser.END, 0); }
		public ITerminalNode PSET() { return GetToken(VBAExpressionParser.PSET, 0); }
		public ITerminalNode EXIT_FUNCTION() { return GetToken(VBAExpressionParser.EXIT_FUNCTION, 0); }
		public ITerminalNode READ_WRITE() { return GetToken(VBAExpressionParser.READ_WRITE, 0); }
		public ITerminalNode UNLOCK() { return GetToken(VBAExpressionParser.UNLOCK, 0); }
		public ITerminalNode CDBL() { return GetToken(VBAExpressionParser.CDBL, 0); }
		public ITerminalNode CLNG() { return GetToken(VBAExpressionParser.CLNG, 0); }
		public ReservedProcedureNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedProcedureName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedProcedureName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedProcedureName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedProcedureName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedProcedureNameContext reservedProcedureName() {
		ReservedProcedureNameContext _localctx = new ReservedProcedureNameContext(_ctx, State);
		EnterRule(_localctx, 92, RULE_reservedProcedureName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 590;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABS) | (1L << CBOOL) | (1L << CBYTE) | (1L << CCUR) | (1L << CDATE) | (1L << CDBL) | (1L << CDEC) | (1L << CINT) | (1L << CLNG) | (1L << CLNGLNG) | (1L << CLNGPTR) | (1L << CSNG) | (1L << CSTR) | (1L << CVAR) | (1L << CVERR) | (1L << DEBUG) | (1L << DOEVENTS) | (1L << FIX) | (1L << INT) | (1L << LEN) | (1L << LENB) | (1L << MIDB) | (1L << MIDBTYPESUFFIX) | (1L << MIDTYPESUFFIX) | (1L << PSET) | (1L << SCALE) | (1L << SGN) | (1L << ACCESS) | (1L << APPEND) | (1L << BINARY))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CLOSE - 65)) | (1L << (END_SELECT - 65)) | (1L << (END_WITH - 65)) | (1L << (END - 65)) | (1L << (ERROR - 65)) | (1L << (EXIT_DO - 65)) | (1L << (EXIT_FOR - 65)) | (1L << (EXIT_FUNCTION - 65)) | (1L << (EXIT_PROPERTY - 65)) | (1L << (EXIT_SUB - 65)) | (1L << (GET - 65)) | (1L << (INPUT - 65)) | (1L << (LOCK - 65)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (LINE_INPUT - 130)) | (1L << (LOCK_READ - 130)) | (1L << (LOCK_WRITE - 130)) | (1L << (LOCK_READ_WRITE - 130)) | (1L << (MID - 130)) | (1L << (ON_ERROR - 130)) | (1L << (OPEN - 130)) | (1L << (OUTPUT - 130)) | (1L << (PUT - 130)) | (1L << (RANDOM - 130)) | (1L << (READ - 130)) | (1L << (READ_WRITE - 130)) | (1L << (RESET - 130)) | (1L << (SEEK - 130)) | (1L << (SHARED - 130)) | (1L << (STEP - 130)) | (1L << (UNLOCK - 130)))) != 0) || _la==WIDTH || _la==WRITE) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SpecialFormContext : ParserRuleContext {
		public ITerminalNode INPUTB() { return GetToken(VBAExpressionParser.INPUTB, 0); }
		public ITerminalNode SCALE() { return GetToken(VBAExpressionParser.SCALE, 0); }
		public ITerminalNode ARRAY() { return GetToken(VBAExpressionParser.ARRAY, 0); }
		public ITerminalNode LBOUND() { return GetToken(VBAExpressionParser.LBOUND, 0); }
		public ITerminalNode UBOUND() { return GetToken(VBAExpressionParser.UBOUND, 0); }
		public ITerminalNode INPUT() { return GetToken(VBAExpressionParser.INPUT, 0); }
		public ITerminalNode CIRCLE() { return GetToken(VBAExpressionParser.CIRCLE, 0); }
		public SpecialFormContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_specialForm; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterSpecialForm(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitSpecialForm(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSpecialForm(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SpecialFormContext specialForm() {
		SpecialFormContext _localctx = new SpecialFormContext(_ctx, State);
		EnterRule(_localctx, 94, RULE_specialForm);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 592;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ARRAY) | (1L << CIRCLE) | (1L << INPUTB) | (1L << LBOUND) | (1L << SCALE) | (1L << UBOUND))) != 0) || _la==INPUT) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedTypeIdentifierContext : ParserRuleContext {
		public ITerminalNode INTEGER() { return GetToken(VBAExpressionParser.INTEGER, 0); }
		public ITerminalNode LONGLONG() { return GetToken(VBAExpressionParser.LONGLONG, 0); }
		public ITerminalNode VARIANT() { return GetToken(VBAExpressionParser.VARIANT, 0); }
		public ITerminalNode LONGPTR() { return GetToken(VBAExpressionParser.LONGPTR, 0); }
		public ITerminalNode BYTE() { return GetToken(VBAExpressionParser.BYTE, 0); }
		public ITerminalNode STRING() { return GetToken(VBAExpressionParser.STRING, 0); }
		public ITerminalNode BOOLEAN() { return GetToken(VBAExpressionParser.BOOLEAN, 0); }
		public ITerminalNode CURRENCY() { return GetToken(VBAExpressionParser.CURRENCY, 0); }
		public ITerminalNode DOUBLE() { return GetToken(VBAExpressionParser.DOUBLE, 0); }
		public ITerminalNode ANY() { return GetToken(VBAExpressionParser.ANY, 0); }
		public ITerminalNode LONG() { return GetToken(VBAExpressionParser.LONG, 0); }
		public ITerminalNode DATE() { return GetToken(VBAExpressionParser.DATE, 0); }
		public ITerminalNode SINGLE() { return GetToken(VBAExpressionParser.SINGLE, 0); }
		public ReservedTypeIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedTypeIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedTypeIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedTypeIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedTypeIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedTypeIdentifierContext reservedTypeIdentifier() {
		ReservedTypeIdentifierContext _localctx = new ReservedTypeIdentifierContext(_ctx, State);
		EnterRule(_localctx, 96, RULE_reservedTypeIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 594;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ANY) | (1L << CURRENCY) | (1L << LONGLONG) | (1L << LONGPTR) | (1L << BOOLEAN) | (1L << BYTE))) != 0) || ((((_la - 68)) & ~0x3f) == 0 && ((1L << (_la - 68)) & ((1L << (DATE - 68)) | (1L << (DOUBLE - 68)) | (1L << (INTEGER - 68)) | (1L << (LONG - 68)))) != 0) || ((((_la - 178)) & ~0x3f) == 0 && ((1L << (_la - 178)) & ((1L << (SINGLE - 178)) | (1L << (STRING - 178)) | (1L << (VARIANT - 178)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UncategorizedKeywordContext : ParserRuleContext {
		public ITerminalNode TAB() { return GetToken(VBAExpressionParser.TAB, 0); }
		public ITerminalNode LIB() { return GetToken(VBAExpressionParser.LIB, 0); }
		public ITerminalNode VERSION() { return GetToken(VBAExpressionParser.VERSION, 0); }
		public ITerminalNode ON() { return GetToken(VBAExpressionParser.ON, 0); }
		public ITerminalNode COLLECTION() { return GetToken(VBAExpressionParser.COLLECTION, 0); }
		public ITerminalNode ALIAS() { return GetToken(VBAExpressionParser.ALIAS, 0); }
		public ITerminalNode ATTRIBUTE() { return GetToken(VBAExpressionParser.ATTRIBUTE, 0); }
		public ITerminalNode BEGIN() { return GetToken(VBAExpressionParser.BEGIN, 0); }
		public ITerminalNode CLASS() { return GetToken(VBAExpressionParser.CLASS, 0); }
		public UncategorizedKeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_uncategorizedKeyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterUncategorizedKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitUncategorizedKeyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUncategorizedKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UncategorizedKeywordContext uncategorizedKeyword() {
		UncategorizedKeywordContext _localctx = new UncategorizedKeywordContext(_ctx, State);
		EnterRule(_localctx, 98, RULE_uncategorizedKeyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 596;
			_la = _input.La(1);
			if ( !(((((_la - 51)) & ~0x3f) == 0 && ((1L << (_la - 51)) & ((1L << (ALIAS - 51)) | (1L << (ATTRIBUTE - 51)) | (1L << (BEGIN - 51)) | (1L << (CLASS - 51)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (LIB - 128)) | (1L << (ON - 128)) | (1L << (TAB - 128)))) != 0) || _la==VERSION || _la==COLLECTION) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralIdentifierContext : ParserRuleContext {
		public ObjectLiteralIdentifierContext objectLiteralIdentifier() {
			return GetRuleContext<ObjectLiteralIdentifierContext>(0);
		}
		public BooleanLiteralIdentifierContext booleanLiteralIdentifier() {
			return GetRuleContext<BooleanLiteralIdentifierContext>(0);
		}
		public VariantLiteralIdentifierContext variantLiteralIdentifier() {
			return GetRuleContext<VariantLiteralIdentifierContext>(0);
		}
		public LiteralIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literalIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLiteralIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLiteralIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralIdentifierContext literalIdentifier() {
		LiteralIdentifierContext _localctx = new LiteralIdentifierContext(_ctx, State);
		EnterRule(_localctx, 100, RULE_literalIdentifier);
		try {
			State = 601;
			switch (_input.La(1)) {
			case FALSE:
			case TRUE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 598; booleanLiteralIdentifier();
				}
				break;
			case NOTHING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 599; objectLiteralIdentifier();
				}
				break;
			case EMPTY:
			case NULL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 600; variantLiteralIdentifier();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BooleanLiteralIdentifierContext : ParserRuleContext {
		public ITerminalNode FALSE() { return GetToken(VBAExpressionParser.FALSE, 0); }
		public ITerminalNode TRUE() { return GetToken(VBAExpressionParser.TRUE, 0); }
		public BooleanLiteralIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_booleanLiteralIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterBooleanLiteralIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitBooleanLiteralIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBooleanLiteralIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BooleanLiteralIdentifierContext booleanLiteralIdentifier() {
		BooleanLiteralIdentifierContext _localctx = new BooleanLiteralIdentifierContext(_ctx, State);
		EnterRule(_localctx, 102, RULE_booleanLiteralIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 603;
			_la = _input.La(1);
			if ( !(_la==FALSE || _la==TRUE) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectLiteralIdentifierContext : ParserRuleContext {
		public ITerminalNode NOTHING() { return GetToken(VBAExpressionParser.NOTHING, 0); }
		public ObjectLiteralIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectLiteralIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterObjectLiteralIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitObjectLiteralIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObjectLiteralIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ObjectLiteralIdentifierContext objectLiteralIdentifier() {
		ObjectLiteralIdentifierContext _localctx = new ObjectLiteralIdentifierContext(_ctx, State);
		EnterRule(_localctx, 104, RULE_objectLiteralIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 605; Match(NOTHING);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariantLiteralIdentifierContext : ParserRuleContext {
		public ITerminalNode NULL() { return GetToken(VBAExpressionParser.NULL, 0); }
		public ITerminalNode EMPTY() { return GetToken(VBAExpressionParser.EMPTY, 0); }
		public VariantLiteralIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variantLiteralIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterVariantLiteralIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitVariantLiteralIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariantLiteralIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariantLiteralIdentifierContext variantLiteralIdentifier() {
		VariantLiteralIdentifierContext _localctx = new VariantLiteralIdentifierContext(_ctx, State);
		EnterRule(_localctx, 106, RULE_variantLiteralIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 607;
			_la = _input.La(1);
			if ( !(_la==EMPTY || _la==NULL) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhiteSpaceContext : ParserRuleContext {
		public ITerminalNode WS(int i) {
			return GetToken(VBAExpressionParser.WS, i);
		}
		public IReadOnlyList<ITerminalNode> WS() { return GetTokens(VBAExpressionParser.WS); }
		public IReadOnlyList<ITerminalNode> LINE_CONTINUATION() { return GetTokens(VBAExpressionParser.LINE_CONTINUATION); }
		public ITerminalNode LINE_CONTINUATION(int i) {
			return GetToken(VBAExpressionParser.LINE_CONTINUATION, i);
		}
		public WhiteSpaceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whiteSpace; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterWhiteSpace(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitWhiteSpace(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhiteSpace(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhiteSpaceContext whiteSpace() {
		WhiteSpaceContext _localctx = new WhiteSpaceContext(_ctx, State);
		EnterRule(_localctx, 108, RULE_whiteSpace);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 610;
			_errHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 609;
					_la = _input.La(1);
					if ( !(_la==WS || _la==LINE_CONTINUATION) ) {
					_errHandler.RecoverInline(this);
					}
					Consume();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 612;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,86,_ctx);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 13: return expression_sempred((ExpressionContext)_localctx, predIndex);

		case 19: return lExpression_sempred((LExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(_ctx, 16);

		case 1: return Precpred(_ctx, 14);

		case 2: return Precpred(_ctx, 13);

		case 3: return Precpred(_ctx, 12);

		case 4: return Precpred(_ctx, 11);

		case 5: return Precpred(_ctx, 10);

		case 6: return Precpred(_ctx, 9);

		case 7: return Precpred(_ctx, 7);

		case 8: return Precpred(_ctx, 6);

		case 9: return Precpred(_ctx, 5);

		case 10: return Precpred(_ctx, 4);

		case 11: return Precpred(_ctx, 3);
		}
		return true;
	}
	private bool lExpression_sempred(LExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 16: return Precpred(_ctx, 5);

		case 17: return Precpred(_ctx, 4);

		case 12: return Precpred(_ctx, 9);

		case 13: return Precpred(_ctx, 8);

		case 14: return Precpred(_ctx, 7);

		case 15: return Precpred(_ctx, 6);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\xF3\x269\x4\x2"+
		"\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4"+
		"\t\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10"+
		"\t\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x4\x16\t\x16\x4\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B"+
		"\t\x1B\x4\x1C\t\x1C\x4\x1D\t\x1D\x4\x1E\t\x1E\x4\x1F\t\x1F\x4 \t \x4!"+
		"\t!\x4\"\t\"\x4#\t#\x4$\t$\x4%\t%\x4&\t&\x4\'\t\'\x4(\t(\x4)\t)\x4*\t"+
		"*\x4+\t+\x4,\t,\x4-\t-\x4.\t.\x4/\t/\x4\x30\t\x30\x4\x31\t\x31\x4\x32"+
		"\t\x32\x4\x33\t\x33\x4\x34\t\x34\x4\x35\t\x35\x4\x36\t\x36\x4\x37\t\x37"+
		"\x4\x38\t\x38\x3\x2\x3\x2\x5\x2s\n\x2\x3\x2\x3\x2\x3\x3\x3\x3\x3\x3\x5"+
		"\x3z\n\x3\x3\x3\x3\x3\x3\x3\x5\x3\x7F\n\x3\x3\x4\x3\x4\x5\x4\x83\n\x4"+
		"\x3\x5\x3\x5\x5\x5\x87\n\x5\x3\x6\x3\x6\x5\x6\x8B\n\x6\x3\a\x3\a\x3\b"+
		"\x3\b\x3\b\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x5\t\x9B\n\t\x3"+
		"\n\x3\n\x3\n\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x5\v\xA8\n\v\x3\f"+
		"\x3\f\x3\r\x3\r\x3\xE\x3\xE\x3\xE\x5\xE\xB1\n\xE\x3\xE\x3\xE\x5\xE\xB5"+
		"\n\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x5\xE\xBC\n\xE\x3\xE\x3\xE\x5\xE\xC0"+
		"\n\xE\x3\xE\x5\xE\xC3\n\xE\x3\xF\x3\xF\x3\xF\x5\xF\xC8\n\xF\x3\xF\x3\xF"+
		"\x3\xF\x5\xF\xCD\n\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x5\xF\xD5\n"+
		"\xF\x3\xF\x3\xF\x5\xF\xD9\n\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x5\xF\xE0"+
		"\n\xF\x3\xF\x3\xF\x5\xF\xE4\n\xF\x3\xF\x3\xF\x5\xF\xE8\n\xF\x3\xF\x3\xF"+
		"\x3\xF\x5\xF\xED\n\xF\x3\xF\x3\xF\x5\xF\xF1\n\xF\x3\xF\x3\xF\x3\xF\x5"+
		"\xF\xF6\n\xF\x3\xF\x3\xF\x5\xF\xFA\n\xF\x3\xF\x3\xF\x3\xF\x5\xF\xFF\n"+
		"\xF\x3\xF\x3\xF\x5\xF\x103\n\xF\x3\xF\x3\xF\x3\xF\x5\xF\x108\n\xF\x3\xF"+
		"\x3\xF\x5\xF\x10C\n\xF\x3\xF\x3\xF\x3\xF\x5\xF\x111\n\xF\x3\xF\x3\xF\x5"+
		"\xF\x115\n\xF\x3\xF\x3\xF\x3\xF\x5\xF\x11A\n\xF\x3\xF\x3\xF\x5\xF\x11E"+
		"\n\xF\x3\xF\x3\xF\x3\xF\x5\xF\x123\n\xF\x3\xF\x3\xF\x5\xF\x127\n\xF\x3"+
		"\xF\x3\xF\x3\xF\x5\xF\x12C\n\xF\x3\xF\x3\xF\x5\xF\x130\n\xF\x3\xF\x3\xF"+
		"\x3\xF\x5\xF\x135\n\xF\x3\xF\x3\xF\x5\xF\x139\n\xF\x3\xF\x3\xF\x3\xF\x5"+
		"\xF\x13E\n\xF\x3\xF\x3\xF\x5\xF\x142\n\xF\x3\xF\x3\xF\x3\xF\x5\xF\x147"+
		"\n\xF\x3\xF\x3\xF\x5\xF\x14B\n\xF\x3\xF\a\xF\x14E\n\xF\f\xF\xE\xF\x151"+
		"\v\xF\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x5\x10\x158\n\x10\x5\x10\x15A"+
		"\n\x10\x3\x11\x3\x11\x3\x12\x3\x12\x5\x12\x160\n\x12\x3\x12\x3\x12\x5"+
		"\x12\x164\n\x12\x3\x12\x3\x12\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13"+
		"\x3\x13\x3\x13\x3\x14\x3\x14\x3\x14\x3\x14\x3\x15\x3\x15\x3\x15\x3\x15"+
		"\x5\x15\x178\n\x15\x3\x15\x3\x15\x5\x15\x17C\n\x15\x3\x15\x3\x15\x5\x15"+
		"\x180\n\x15\x3\x15\x5\x15\x183\n\x15\x3\x15\x5\x15\x186\n\x15\x3\x15\x3"+
		"\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x5\x15\x18F\n\x15\x3\x15\x3\x15"+
		"\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15"+
		"\x3\x15\x3\x15\a\x15\x19F\n\x15\f\x15\xE\x15\x1A2\v\x15\x3\x16\x3\x16"+
		"\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16\x5\x16\x1AB\n\x16\x3\x16\x3\x16\x3"+
		"\x16\x5\x16\x1B0\n\x16\x3\x17\x3\x17\x5\x17\x1B4\n\x17\x3\x17\x3\x17\x5"+
		"\x17\x1B8\n\x17\x3\x17\x5\x17\x1BB\n\x17\x3\x17\x5\x17\x1BE\n\x17\x3\x17"+
		"\x3\x17\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18"+
		"\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x5\x18\x1D1\n\x18\x3\x19\x3"+
		"\x19\x3\x1A\x5\x1A\x1D6\n\x1A\x3\x1A\x5\x1A\x1D9\n\x1A\x3\x1A\x3\x1A\x5"+
		"\x1A\x1DD\n\x1A\a\x1A\x1DF\n\x1A\f\x1A\xE\x1A\x1E2\v\x1A\x3\x1A\x3\x1A"+
		"\x5\x1A\x1E6\n\x1A\x3\x1A\x5\x1A\x1E9\n\x1A\x3\x1A\x3\x1A\x5\x1A\x1ED"+
		"\n\x1A\a\x1A\x1EF\n\x1A\f\x1A\xE\x1A\x1F2\v\x1A\x3\x1A\x5\x1A\x1F5\n\x1A"+
		"\x3\x1B\x3\x1B\x3\x1C\x3\x1C\x3\x1D\x3\x1D\x5\x1D\x1FD\n\x1D\x3\x1D\x3"+
		"\x1D\x5\x1D\x201\n\x1D\x3\x1D\a\x1D\x204\n\x1D\f\x1D\xE\x1D\x207\v\x1D"+
		"\x3\x1E\x3\x1E\x5\x1E\x20B\n\x1E\x3\x1E\x3\x1E\x5\x1E\x20F\n\x1E\x3\x1E"+
		"\x3\x1E\x3\x1F\x3\x1F\x5\x1F\x215\n\x1F\x3\x1F\x3\x1F\x5\x1F\x219\n\x1F"+
		"\x3 \x3 \x3!\x3!\x3\"\x3\"\x5\"\x221\n\"\x3#\x3#\x3#\x3$\x3$\x3$\x3%\x3"+
		"%\x3&\x3&\x5&\x22D\n&\x3\'\x3\'\x5\'\x231\n\'\x3(\x3(\x3(\x3(\x3)\x3)"+
		"\x5)\x239\n)\x3*\x3*\x3*\x3*\x3*\x3*\x3*\x3*\x5*\x243\n*\x3+\x3+\x3,\x3"+
		",\x3-\x3-\x3.\x3.\x3/\x3/\x5/\x24F\n/\x3\x30\x3\x30\x3\x31\x3\x31\x3\x32"+
		"\x3\x32\x3\x33\x3\x33\x3\x34\x3\x34\x3\x34\x5\x34\x25C\n\x34\x3\x35\x3"+
		"\x35\x3\x36\x3\x36\x3\x37\x3\x37\x3\x38\x6\x38\x265\n\x38\r\x38\xE\x38"+
		"\x266\x3\x38\x2\x2\x4\x1C(\x39\x2\x2\x4\x2\x6\x2\b\x2\n\x2\f\x2\xE\x2"+
		"\x10\x2\x12\x2\x14\x2\x16\x2\x18\x2\x1A\x2\x1C\x2\x1E\x2 \x2\"\x2$\x2"+
		"&\x2(\x2*\x2,\x2.\x2\x30\x2\x32\x2\x34\x2\x36\x2\x38\x2:\x2<\x2>\x2@\x2"+
		"\x42\x2\x44\x2\x46\x2H\x2J\x2L\x2N\x2P\x2R\x2T\x2V\x2X\x2Z\x2\\\x2^\x2"+
		"`\x2\x62\x2\x64\x2\x66\x2h\x2j\x2l\x2n\x2\x2\x12\x5\x2,,.\x32\xDA\xDA"+
		"\x5\x2;;\x45\x45\xBC\xBC\x4\x2\xCE\xCE\xD7\xD7\x4\x2\xD6\xD6\xD9\xD9\a"+
		"\x2||\x83\x83\xD0\xD3\xD5\xD5\xD8\xD8\x3\x2\xE4\xE7\x1F\x2\x18\x18$$@"+
		"\x41\x44\x44GVYZ^^\x65\x65ggiiprtwyy\x80\x81\x88\x88\x8C\x8C\x91\x91\x9E"+
		"\x9F\xA4\xA4\xA7\xA7\xAA\xAA\xAD\xAF\xB1\xB2\xB6\xB6\xB8\xB8\xBA\xBA\xC0"+
		"\xC0\xC6\xC7\xC9\xC9\x11\x2\x4\x4\x39\x39=>\x41\x41XYzz\x8D\x8D\x95\x95"+
		"\x9C\x9D\xB3\xB3\xB5\xB5\xBB\xBB\xBD\xBE\xC3\xC3\xCA\xCB\r\x2\x34\x34"+
		"\x36\x36\x66\x66xx||\x83\x83\x8B\x8B\x8D\x8E\x9A\x9A\xC1\xC1\xCC\xCC$"+
		"\x2\x3\x3\x6\f\xE\x12\x14\x17\x19\x19\x1B\x1B\x1D\x1E!#%\'\x33\x33\x38"+
		"\x38;;\x43\x43``\x63\x64hhjnss{{~~\x84\x87\x8A\x8A\x92\x92\x94\x94\x9B"+
		"\x9B\xA5\xA6\xA8\xA9\xAC\xAC\xB0\xB0\xB3\xB3\xB7\xB7\xC2\xC2\xC8\xC8\xCB"+
		"\xCB\t\x2\x5\x5\r\r\x1A\x1A\x1C\x1C&&(({{\xE\x2\x4\x4\x13\x13\x1F <<?"+
		"?\x46\x46WW}}\x7F\x7F\xB4\xB4\xB9\xB9\xC4\xC4\v\x2\x35\x35\x37\x37::\x42"+
		"\x42\x82\x82\x91\x91\xBB\xBB\xC5\xC5\xF3\xF3\x4\x2oo\xBF\xBF\x4\x2[[\x90"+
		"\x90\x4\x2\xEC\xEC\xEF\xEF\x2B7\x2r\x3\x2\x2\x2\x4y\x3\x2\x2\x2\x6\x82"+
		"\x3\x2\x2\x2\b\x86\x3\x2\x2\x2\n\x8A\x3\x2\x2\x2\f\x8C\x3\x2\x2\x2\xE"+
		"\x8E\x3\x2\x2\x2\x10\x9A\x3\x2\x2\x2\x12\x9C\x3\x2\x2\x2\x14\xA7\x3\x2"+
		"\x2\x2\x16\xA9\x3\x2\x2\x2\x18\xAB\x3\x2\x2\x2\x1A\xC2\x3\x2\x2\x2\x1C"+
		"\xDF\x3\x2\x2\x2\x1E\x159\x3\x2\x2\x2 \x15B\x3\x2\x2\x2\"\x15D\x3\x2\x2"+
		"\x2$\x167\x3\x2\x2\x2&\x16F\x3\x2\x2\x2(\x177\x3\x2\x2\x2*\x1AF\x3\x2"+
		"\x2\x2,\x1B1\x3\x2\x2\x2.\x1D0\x3\x2\x2\x2\x30\x1D2\x3\x2\x2\x2\x32\x1F4"+
		"\x3\x2\x2\x2\x34\x1F6\x3\x2\x2\x2\x36\x1F8\x3\x2\x2\x2\x38\x1FA\x3\x2"+
		"\x2\x2:\x208\x3\x2\x2\x2<\x218\x3\x2\x2\x2>\x21A\x3\x2\x2\x2@\x21C\x3"+
		"\x2\x2\x2\x42\x220\x3\x2\x2\x2\x44\x222\x3\x2\x2\x2\x46\x225\x3\x2\x2"+
		"\x2H\x228\x3\x2\x2\x2J\x22C\x3\x2\x2\x2L\x230\x3\x2\x2\x2N\x232\x3\x2"+
		"\x2\x2P\x238\x3\x2\x2\x2R\x242\x3\x2\x2\x2T\x244\x3\x2\x2\x2V\x246\x3"+
		"\x2\x2\x2X\x248\x3\x2\x2\x2Z\x24A\x3\x2\x2\x2\\\x24E\x3\x2\x2\x2^\x250"+
		"\x3\x2\x2\x2`\x252\x3\x2\x2\x2\x62\x254\x3\x2\x2\x2\x64\x256\x3\x2\x2"+
		"\x2\x66\x25B\x3\x2\x2\x2h\x25D\x3\x2\x2\x2j\x25F\x3\x2\x2\x2l\x261\x3"+
		"\x2\x2\x2n\x264\x3\x2\x2\x2ps\x5\x1C\xF\x2qs\x5\x4\x3\x2rp\x3\x2\x2\x2"+
		"rq\x3\x2\x2\x2st\x3\x2\x2\x2tu\a\x2\x2\x3u\x3\x3\x2\x2\x2vz\x5*\x16\x2"+
		"wz\x5> \x2xz\x5\x42\"\x2yv\x3\x2\x2\x2yw\x3\x2\x2\x2yx\x3\x2\x2\x2z~\x3"+
		"\x2\x2\x2{|\x5n\x38\x2|}\x5\x30\x19\x2}\x7F\x3\x2\x2\x2~{\x3\x2\x2\x2"+
		"~\x7F\x3\x2\x2\x2\x7F\x5\x3\x2\x2\x2\x80\x83\x5\b\x5\x2\x81\x83\x5\n\x6"+
		"\x2\x82\x80\x3\x2\x2\x2\x82\x81\x3\x2\x2\x2\x83\a\x3\x2\x2\x2\x84\x87"+
		"\x5\x10\t\x2\x85\x87\x5\x12\n\x2\x86\x84\x3\x2\x2\x2\x86\x85\x3\x2\x2"+
		"\x2\x87\t\x3\x2\x2\x2\x88\x8B\x5\f\a\x2\x89\x8B\x5\xE\b\x2\x8A\x88\x3"+
		"\x2\x2\x2\x8A\x89\x3\x2\x2\x2\x8B\v\x3\x2\x2\x2\x8C\x8D\x5R*\x2\x8D\r"+
		"\x3\x2\x2\x2\x8E\x8F\x5R*\x2\x8F\x90\x5\x16\f\x2\x90\xF\x3\x2\x2\x2\x91"+
		"\x9B\a\xEE\x2\x2\x92\x9B\a\xF1\x2\x2\x93\x9B\x5^\x30\x2\x94\x9B\x5`\x31"+
		"\x2\x95\x9B\x5\x18\r\x2\x96\x9B\a\xF2\x2\x2\x97\x9B\x5\x64\x33\x2\x98"+
		"\x9B\ah\x2\x2\x99\x9B\x5\x62\x32\x2\x9A\x91\x3\x2\x2\x2\x9A\x92\x3\x2"+
		"\x2\x2\x9A\x93\x3\x2\x2\x2\x9A\x94\x3\x2\x2\x2\x9A\x95\x3\x2\x2\x2\x9A"+
		"\x96\x3\x2\x2\x2\x9A\x97\x3\x2\x2\x2\x9A\x98\x3\x2\x2\x2\x9A\x99\x3\x2"+
		"\x2\x2\x9B\x11\x3\x2\x2\x2\x9C\x9D\x5\x14\v\x2\x9D\x9E\x5\x16\f\x2\x9E"+
		"\x13\x3\x2\x2\x2\x9F\xA8\a\xEE\x2\x2\xA0\xA8\x5^\x30\x2\xA1\xA8\x5`\x31"+
		"\x2\xA2\xA8\x5\x18\r\x2\xA3\xA8\a\xF2\x2\x2\xA4\xA8\x5\x64\x33\x2\xA5"+
		"\xA8\ah\x2\x2\xA6\xA8\x5\x62\x32\x2\xA7\x9F\x3\x2\x2\x2\xA7\xA0\x3\x2"+
		"\x2\x2\xA7\xA1\x3\x2\x2\x2\xA7\xA2\x3\x2\x2\x2\xA7\xA3\x3\x2\x2\x2\xA7"+
		"\xA4\x3\x2\x2\x2\xA7\xA5\x3\x2\x2\x2\xA7\xA6\x3\x2\x2\x2\xA8\x15\x3\x2"+
		"\x2\x2\xA9\xAA\t\x2\x2\x2\xAA\x17\x3\x2\x2\x2\xAB\xAC\t\x3\x2\x2\xAC\x19"+
		"\x3\x2\x2\x2\xAD\xC3\x5\x62\x32\x2\xAE\xB0\a\xE1\x2\x2\xAF\xB1\x5n\x38"+
		"\x2\xB0\xAF\x3\x2\x2\x2\xB0\xB1\x3\x2\x2\x2\xB1\xB2\x3\x2\x2\x2\xB2\xB4"+
		"\x5\x62\x32\x2\xB3\xB5\x5n\x38\x2\xB4\xB3\x3\x2\x2\x2\xB4\xB5\x3\x2\x2"+
		"\x2\xB5\xB6\x3\x2\x2\x2\xB6\xB7\a\xE2\x2\x2\xB7\xC3\x3\x2\x2\x2\xB8\xC3"+
		"\a\xF2\x2\x2\xB9\xBB\a\xE1\x2\x2\xBA\xBC\x5n\x38\x2\xBB\xBA\x3\x2\x2\x2"+
		"\xBB\xBC\x3\x2\x2\x2\xBC\xBD\x3\x2\x2\x2\xBD\xBF\a\xF2\x2\x2\xBE\xC0\x5"+
		"n\x38\x2\xBF\xBE\x3\x2\x2\x2\xBF\xC0\x3\x2\x2\x2\xC0\xC1\x3\x2\x2\x2\xC1"+
		"\xC3\a\xE2\x2\x2\xC2\xAD\x3\x2\x2\x2\xC2\xAE\x3\x2\x2\x2\xC2\xB8\x3\x2"+
		"\x2\x2\xC2\xB9\x3\x2\x2\x2\xC3\x1B\x3\x2\x2\x2\xC4\xC5\b\xF\x1\x2\xC5"+
		"\xC7\a\xD6\x2\x2\xC6\xC8\x5n\x38\x2\xC7\xC6\x3\x2\x2\x2\xC7\xC8\x3\x2"+
		"\x2\x2\xC8\xC9\x3\x2\x2\x2\xC9\xE0\x5\x1C\xF\x11\xCA\xCC\a\x8E\x2\x2\xCB"+
		"\xCD\x5n\x38\x2\xCC\xCB\x3\x2\x2\x2\xCC\xCD\x3\x2\x2\x2\xCD\xCE\x3\x2"+
		"\x2\x2\xCE\xE0\x5\x1C\xF\n\xCF\xD0\a.\x2\x2\xD0\xE0\x5\x1C\xF\x3\xD1\xE0"+
		"\x5(\x15\x2\xD2\xD4\a\xD4\x2\x2\xD3\xD5\x5n\x38\x2\xD4\xD3\x3\x2\x2\x2"+
		"\xD4\xD5\x3\x2\x2\x2\xD5\xD6\x3\x2\x2\x2\xD6\xD8\x5\x1C\xF\x2\xD7\xD9"+
		"\x5n\x38\x2\xD8\xD7\x3\x2\x2\x2\xD8\xD9\x3\x2\x2\x2\xD9\xDA\x3\x2\x2\x2"+
		"\xDA\xDB\a\xDB\x2\x2\xDB\xE0\x3\x2\x2\x2\xDC\xE0\x5$\x13\x2\xDD\xE0\x5"+
		"&\x14\x2\xDE\xE0\x5\x1E\x10\x2\xDF\xC4\x3\x2\x2\x2\xDF\xCA\x3\x2\x2\x2"+
		"\xDF\xCF\x3\x2\x2\x2\xDF\xD1\x3\x2\x2\x2\xDF\xD2\x3\x2\x2\x2\xDF\xDC\x3"+
		"\x2\x2\x2\xDF\xDD\x3\x2\x2\x2\xDF\xDE\x3\x2\x2\x2\xE0\x14F\x3\x2\x2\x2"+
		"\xE1\xE3\f\x12\x2\x2\xE2\xE4\x5n\x38\x2\xE3\xE2\x3\x2\x2\x2\xE3\xE4\x3"+
		"\x2\x2\x2\xE4\xE5\x3\x2\x2\x2\xE5\xE7\a\xDA\x2\x2\xE6\xE8\x5n\x38\x2\xE7"+
		"\xE6\x3\x2\x2\x2\xE7\xE8\x3\x2\x2\x2\xE8\xE9\x3\x2\x2\x2\xE9\x14E\x5\x1C"+
		"\xF\x13\xEA\xEC\f\x10\x2\x2\xEB\xED\x5n\x38\x2\xEC\xEB\x3\x2\x2\x2\xEC"+
		"\xED\x3\x2\x2\x2\xED\xEE\x3\x2\x2\x2\xEE\xF0\t\x4\x2\x2\xEF\xF1\x5n\x38"+
		"\x2\xF0\xEF\x3\x2\x2\x2\xF0\xF1\x3\x2\x2\x2\xF1\xF2\x3\x2\x2\x2\xF2\x14E"+
		"\x5\x1C\xF\x11\xF3\xF5\f\xF\x2\x2\xF4\xF6\x5n\x38\x2\xF5\xF4\x3\x2\x2"+
		"\x2\xF5\xF6\x3\x2\x2\x2\xF6\xF7\x3\x2\x2\x2\xF7\xF9\a\xCF\x2\x2\xF8\xFA"+
		"\x5n\x38\x2\xF9\xF8\x3\x2\x2\x2\xF9\xFA\x3\x2\x2\x2\xFA\xFB\x3\x2\x2\x2"+
		"\xFB\x14E\x5\x1C\xF\x10\xFC\xFE\f\xE\x2\x2\xFD\xFF\x5n\x38\x2\xFE\xFD"+
		"\x3\x2\x2\x2\xFE\xFF\x3\x2\x2\x2\xFF\x100\x3\x2\x2\x2\x100\x102\a\x8B"+
		"\x2\x2\x101\x103\x5n\x38\x2\x102\x101\x3\x2\x2\x2\x102\x103\x3\x2\x2\x2"+
		"\x103\x104\x3\x2\x2\x2\x104\x14E\x5\x1C\xF\xF\x105\x107\f\r\x2\x2\x106"+
		"\x108\x5n\x38\x2\x107\x106\x3\x2\x2\x2\x107\x108\x3\x2\x2\x2\x108\x109"+
		"\x3\x2\x2\x2\x109\x10B\t\x5\x2\x2\x10A\x10C\x5n\x38\x2\x10B\x10A\x3\x2"+
		"\x2\x2\x10B\x10C\x3\x2\x2\x2\x10C\x10D\x3\x2\x2\x2\x10D\x14E\x5\x1C\xF"+
		"\xE\x10E\x110\f\f\x2\x2\x10F\x111\x5n\x38\x2\x110\x10F\x3\x2\x2\x2\x110"+
		"\x111\x3\x2\x2\x2\x111\x112\x3\x2\x2\x2\x112\x114\a\x32\x2\x2\x113\x115"+
		"\x5n\x38\x2\x114\x113\x3\x2\x2\x2\x114\x115\x3\x2\x2\x2\x115\x116\x3\x2"+
		"\x2\x2\x116\x14E\x5\x1C\xF\r\x117\x119\f\v\x2\x2\x118\x11A\x5n\x38\x2"+
		"\x119\x118\x3\x2\x2\x2\x119\x11A\x3\x2\x2\x2\x11A\x11B\x3\x2\x2\x2\x11B"+
		"\x11D\t\x6\x2\x2\x11C\x11E\x5n\x38\x2\x11D\x11C\x3\x2\x2\x2\x11D\x11E"+
		"\x3\x2\x2\x2\x11E\x11F\x3\x2\x2\x2\x11F\x14E\x5\x1C\xF\f\x120\x122\f\t"+
		"\x2\x2\x121\x123\x5n\x38\x2\x122\x121\x3\x2\x2\x2\x122\x123\x3\x2\x2\x2"+
		"\x123\x124\x3\x2\x2\x2\x124\x126\a\x36\x2\x2\x125\x127\x5n\x38\x2\x126"+
		"\x125\x3\x2\x2\x2\x126\x127\x3\x2\x2\x2\x127\x128\x3\x2\x2\x2\x128\x14E"+
		"\x5\x1C\xF\n\x129\x12B\f\b\x2\x2\x12A\x12C\x5n\x38\x2\x12B\x12A\x3\x2"+
		"\x2\x2\x12B\x12C\x3\x2\x2\x2\x12C\x12D\x3\x2\x2\x2\x12D\x12F\a\x9A\x2"+
		"\x2\x12E\x130\x5n\x38\x2\x12F\x12E\x3\x2\x2\x2\x12F\x130\x3\x2\x2\x2\x130"+
		"\x131\x3\x2\x2\x2\x131\x14E\x5\x1C\xF\t\x132\x134\f\a\x2\x2\x133\x135"+
		"\x5n\x38\x2\x134\x133\x3\x2\x2\x2\x134\x135\x3\x2\x2\x2\x135\x136\x3\x2"+
		"\x2\x2\x136\x138\a\xCC\x2\x2\x137\x139\x5n\x38\x2\x138\x137\x3\x2\x2\x2"+
		"\x138\x139\x3\x2\x2\x2\x139\x13A\x3\x2\x2\x2\x13A\x14E\x5\x1C\xF\b\x13B"+
		"\x13D\f\x6\x2\x2\x13C\x13E\x5n\x38\x2\x13D\x13C\x3\x2\x2\x2\x13D\x13E"+
		"\x3\x2\x2\x2\x13E\x13F\x3\x2\x2\x2\x13F\x141\a\x66\x2\x2\x140\x142\x5"+
		"n\x38\x2\x141\x140\x3\x2\x2\x2\x141\x142\x3\x2\x2\x2\x142\x143\x3\x2\x2"+
		"\x2\x143\x14E\x5\x1C\xF\a\x144\x146\f\x5\x2\x2\x145\x147\x5n\x38\x2\x146"+
		"\x145\x3\x2\x2\x2\x146\x147\x3\x2\x2\x2\x147\x148\x3\x2\x2\x2\x148\x14A"+
		"\ax\x2\x2\x149\x14B\x5n\x38\x2\x14A\x149\x3\x2\x2\x2\x14A\x14B\x3\x2\x2"+
		"\x2\x14B\x14C\x3\x2\x2\x2\x14C\x14E\x5\x1C\xF\x6\x14D\xE1\x3\x2\x2\x2"+
		"\x14D\xEA\x3\x2\x2\x2\x14D\xF3\x3\x2\x2\x2\x14D\xFC\x3\x2\x2\x2\x14D\x105"+
		"\x3\x2\x2\x2\x14D\x10E\x3\x2\x2\x2\x14D\x117\x3\x2\x2\x2\x14D\x120\x3"+
		"\x2\x2\x2\x14D\x129\x3\x2\x2\x2\x14D\x132\x3\x2\x2\x2\x14D\x13B\x3\x2"+
		"\x2\x2\x14D\x144\x3\x2\x2\x2\x14E\x151\x3\x2\x2\x2\x14F\x14D\x3\x2\x2"+
		"\x2\x14F\x150\x3\x2\x2\x2\x150\x1D\x3\x2\x2\x2\x151\x14F\x3\x2\x2\x2\x152"+
		"\x15A\x5 \x11\x2\x153\x15A\a\xE8\x2\x2\x154\x15A\a\xE3\x2\x2\x155\x157"+
		"\x5\x66\x34\x2\x156\x158\x5\x16\f\x2\x157\x156\x3\x2\x2\x2\x157\x158\x3"+
		"\x2\x2\x2\x158\x15A\x3\x2\x2\x2\x159\x152\x3\x2\x2\x2\x159\x153\x3\x2"+
		"\x2\x2\x159\x154\x3\x2\x2\x2\x159\x155\x3\x2\x2\x2\x15A\x1F\x3\x2\x2\x2"+
		"\x15B\x15C\t\a\x2\x2\x15C!\x3\x2\x2\x2\x15D\x15F\a\xD4\x2\x2\x15E\x160"+
		"\x5n\x38\x2\x15F\x15E\x3\x2\x2\x2\x15F\x160\x3\x2\x2\x2\x160\x161\x3\x2"+
		"\x2\x2\x161\x163\x5\x1C\xF\x2\x162\x164\x5n\x38\x2\x163\x162\x3\x2\x2"+
		"\x2\x163\x164\x3\x2\x2\x2\x164\x165\x3\x2\x2\x2\x165\x166\a\xDB\x2\x2"+
		"\x166#\x3\x2\x2\x2\x167\x168\a\xC1\x2\x2\x168\x169\x5n\x38\x2\x169\x16A"+
		"\x5\x1C\xF\x2\x16A\x16B\x5n\x38\x2\x16B\x16C\a|\x2\x2\x16C\x16D\x5n\x38"+
		"\x2\x16D\x16E\x5J&\x2\x16E%\x3\x2\x2\x2\x16F\x170\a\x8D\x2\x2\x170\x171"+
		"\x5n\x38\x2\x171\x172\x5J&\x2\x172\'\x3\x2\x2\x2\x173\x174\b\x15\x1\x2"+
		"\x174\x178\x5@!\x2\x175\x178\x5> \x2\x176\x178\x5\x42\"\x2\x177\x173\x3"+
		"\x2\x2\x2\x177\x175\x3\x2\x2\x2\x177\x176\x3\x2\x2\x2\x178\x1A0\x3\x2"+
		"\x2\x2\x179\x17B\f\v\x2\x2\x17A\x17C\x5n\x38\x2\x17B\x17A\x3\x2\x2\x2"+
		"\x17B\x17C\x3\x2\x2\x2\x17C\x17D\x3\x2\x2\x2\x17D\x17F\a\xD4\x2\x2\x17E"+
		"\x180\x5n\x38\x2\x17F\x17E\x3\x2\x2\x2\x17F\x180\x3\x2\x2\x2\x180\x182"+
		"\x3\x2\x2\x2\x181\x183\x5\x30\x19\x2\x182\x181\x3\x2\x2\x2\x182\x183\x3"+
		"\x2\x2\x2\x183\x185\x3\x2\x2\x2\x184\x186\x5n\x38\x2\x185\x184\x3\x2\x2"+
		"\x2\x185\x186\x3\x2\x2\x2\x186\x187\x3\x2\x2\x2\x187\x19F\a\xDB\x2\x2"+
		"\x188\x189\f\n\x2\x2\x189\x18A\a-\x2\x2\x18A\x19F\x5\x6\x4\x2\x18B\x18C"+
		"\f\t\x2\x2\x18C\x18E\a\xEF\x2\x2\x18D\x18F\x5n\x38\x2\x18E\x18D\x3\x2"+
		"\x2\x2\x18E\x18F\x3\x2\x2\x2\x18F\x190\x3\x2\x2\x2\x190\x191\a-\x2\x2"+
		"\x191\x19F\x5\x6\x4\x2\x192\x193\f\b\x2\x2\x193\x194\a,\x2\x2\x194\x19F"+
		"\x5\x6\x4\x2\x195\x196\f\a\x2\x2\x196\x197\a\xEF\x2\x2\x197\x198\a,\x2"+
		"\x2\x198\x19F\x5\x6\x4\x2\x199\x19A\f\x6\x2\x2\x19A\x19B\a\xEF\x2\x2\x19B"+
		"\x19C\a,\x2\x2\x19C\x19D\a\xEF\x2\x2\x19D\x19F\x5\x6\x4\x2\x19E\x179\x3"+
		"\x2\x2\x2\x19E\x188\x3\x2\x2\x2\x19E\x18B\x3\x2\x2\x2\x19E\x192\x3\x2"+
		"\x2\x2\x19E\x195\x3\x2\x2\x2\x19E\x199\x3\x2\x2\x2\x19F\x1A2\x3\x2\x2"+
		"\x2\x1A0\x19E\x3\x2\x2\x2\x1A0\x1A1\x3\x2\x2\x2\x1A1)\x3\x2\x2\x2\x1A2"+
		"\x1A0\x3\x2\x2\x2\x1A3\x1A4\x5(\x15\x2\x1A4\x1A5\a-\x2\x2\x1A5\x1A6\x5"+
		"\x6\x4\x2\x1A6\x1B0\x3\x2\x2\x2\x1A7\x1A8\x5(\x15\x2\x1A8\x1AA\a\xEF\x2"+
		"\x2\x1A9\x1AB\x5n\x38\x2\x1AA\x1A9\x3\x2\x2\x2\x1AA\x1AB\x3\x2\x2\x2\x1AB"+
		"\x1AC\x3\x2\x2\x2\x1AC\x1AD\a-\x2\x2\x1AD\x1AE\x5\x6\x4\x2\x1AE\x1B0\x3"+
		"\x2\x2\x2\x1AF\x1A3\x3\x2\x2\x2\x1AF\x1A7\x3\x2\x2\x2\x1B0+\x3\x2\x2\x2"+
		"\x1B1\x1B3\x5(\x15\x2\x1B2\x1B4\x5n\x38\x2\x1B3\x1B2\x3\x2\x2\x2\x1B3"+
		"\x1B4\x3\x2\x2\x2\x1B4\x1B5\x3\x2\x2\x2\x1B5\x1B7\a\xD4\x2\x2\x1B6\x1B8"+
		"\x5n\x38\x2\x1B7\x1B6\x3\x2\x2\x2\x1B7\x1B8\x3\x2\x2\x2\x1B8\x1BA\x3\x2"+
		"\x2\x2\x1B9\x1BB\x5\x30\x19\x2\x1BA\x1B9\x3\x2\x2\x2\x1BA\x1BB\x3\x2\x2"+
		"\x2\x1BB\x1BD\x3\x2\x2\x2\x1BC\x1BE\x5n\x38\x2\x1BD\x1BC\x3\x2\x2\x2\x1BD"+
		"\x1BE\x3\x2\x2\x2\x1BE\x1BF\x3\x2\x2\x2\x1BF\x1C0\a\xDB\x2\x2\x1C0-\x3"+
		"\x2\x2\x2\x1C1\x1C2\x5(\x15\x2\x1C2\x1C3\a,\x2\x2\x1C3\x1C4\x5\x6\x4\x2"+
		"\x1C4\x1D1\x3\x2\x2\x2\x1C5\x1C6\x5(\x15\x2\x1C6\x1C7\a\xEF\x2\x2\x1C7"+
		"\x1C8\a,\x2\x2\x1C8\x1C9\x5\x6\x4\x2\x1C9\x1D1\x3\x2\x2\x2\x1CA\x1CB\x5"+
		"(\x15\x2\x1CB\x1CC\a\xEF\x2\x2\x1CC\x1CD\a,\x2\x2\x1CD\x1CE\a\xEF\x2\x2"+
		"\x1CE\x1CF\x5\x6\x4\x2\x1CF\x1D1\x3\x2\x2\x2\x1D0\x1C1\x3\x2\x2\x2\x1D0"+
		"\x1C5\x3\x2\x2\x2\x1D0\x1CA\x3\x2\x2\x2\x1D1/\x3\x2\x2\x2\x1D2\x1D3\x5"+
		"\x32\x1A\x2\x1D3\x31\x3\x2\x2\x2\x1D4\x1D6\x5\x34\x1B\x2\x1D5\x1D4\x3"+
		"\x2\x2\x2\x1D5\x1D6\x3\x2\x2\x2\x1D6\x1D8\x3\x2\x2\x2\x1D7\x1D9\x5n\x38"+
		"\x2\x1D8\x1D7\x3\x2\x2\x2\x1D8\x1D9\x3\x2\x2\x2\x1D9\x1DA\x3\x2\x2\x2"+
		"\x1DA\x1DC\a)\x2\x2\x1DB\x1DD\x5n\x38\x2\x1DC\x1DB\x3\x2\x2\x2\x1DC\x1DD"+
		"\x3\x2\x2\x2\x1DD\x1DF\x3\x2\x2\x2\x1DE\x1D5\x3\x2\x2\x2\x1DF\x1E2\x3"+
		"\x2\x2\x2\x1E0\x1DE\x3\x2\x2\x2\x1E0\x1E1\x3\x2\x2\x2\x1E1\x1E3\x3\x2"+
		"\x2\x2\x1E2\x1E0\x3\x2\x2\x2\x1E3\x1F5\x5\x36\x1C\x2\x1E4\x1E6\x5\x34"+
		"\x1B\x2\x1E5\x1E4\x3\x2\x2\x2\x1E5\x1E6\x3\x2\x2\x2\x1E6\x1E8\x3\x2\x2"+
		"\x2\x1E7\x1E9\x5n\x38\x2\x1E8\x1E7\x3\x2\x2\x2\x1E8\x1E9\x3\x2\x2\x2\x1E9"+
		"\x1EA\x3\x2\x2\x2\x1EA\x1EC\a)\x2\x2\x1EB\x1ED\x5n\x38\x2\x1EC\x1EB\x3"+
		"\x2\x2\x2\x1EC\x1ED\x3\x2\x2\x2\x1ED\x1EF\x3\x2\x2\x2\x1EE\x1E5\x3\x2"+
		"\x2\x2\x1EF\x1F2\x3\x2\x2\x2\x1F0\x1EE\x3\x2\x2\x2\x1F0\x1F1\x3\x2\x2"+
		"\x2\x1F1\x1F3\x3\x2\x2\x2\x1F2\x1F0\x3\x2\x2\x2\x1F3\x1F5\x5\x38\x1D\x2"+
		"\x1F4\x1E0\x3\x2\x2\x2\x1F4\x1F0\x3\x2\x2\x2\x1F5\x33\x3\x2\x2\x2\x1F6"+
		"\x1F7\x5<\x1F\x2\x1F7\x35\x3\x2\x2\x2\x1F8\x1F9\x5<\x1F\x2\x1F9\x37\x3"+
		"\x2\x2\x2\x1FA\x205\x5:\x1E\x2\x1FB\x1FD\x5n\x38\x2\x1FC\x1FB\x3\x2\x2"+
		"\x2\x1FC\x1FD\x3\x2\x2\x2\x1FD\x1FE\x3\x2\x2\x2\x1FE\x200\a)\x2\x2\x1FF"+
		"\x201\x5n\x38\x2\x200\x1FF\x3\x2\x2\x2\x200\x201\x3\x2\x2\x2\x201\x202"+
		"\x3\x2\x2\x2\x202\x204\x5:\x1E\x2\x203\x1FC\x3\x2\x2\x2\x204\x207\x3\x2"+
		"\x2\x2\x205\x203\x3\x2\x2\x2\x205\x206\x3\x2\x2\x2\x206\x39\x3\x2\x2\x2"+
		"\x207\x205\x3\x2\x2\x2\x208\x20A\x5\x6\x4\x2\x209\x20B\x5n\x38\x2\x20A"+
		"\x209\x3\x2\x2\x2\x20A\x20B\x3\x2\x2\x2\x20B\x20C\x3\x2\x2\x2\x20C\x20E"+
		"\a\xCD\x2\x2\x20D\x20F\x5n\x38\x2\x20E\x20D\x3\x2\x2\x2\x20E\x20F\x3\x2"+
		"\x2\x2\x20F\x210\x3\x2\x2\x2\x210\x211\x5<\x1F\x2\x211;\x3\x2\x2\x2\x212"+
		"\x213\a=\x2\x2\x213\x215\x5n\x38\x2\x214\x212\x3\x2\x2\x2\x214\x215\x3"+
		"\x2\x2\x2\x215\x216\x3\x2\x2\x2\x216\x219\x5\x1C\xF\x2\x217\x219\x5N("+
		"\x2\x218\x214\x3\x2\x2\x2\x218\x217\x3\x2\x2\x2\x219=\x3\x2\x2\x2\x21A"+
		"\x21B\x5\b\x5\x2\x21B?\x3\x2\x2\x2\x21C\x21D\a\x89\x2\x2\x21D\x41\x3\x2"+
		"\x2\x2\x21E\x221\x5\x44#\x2\x21F\x221\x5\x46$\x2\x220\x21E\x3\x2\x2\x2"+
		"\x220\x21F\x3\x2\x2\x2\x221\x43\x3\x2\x2\x2\x222\x223\a-\x2\x2\x223\x224"+
		"\x5\x6\x4\x2\x224\x45\x3\x2\x2\x2\x225\x226\a,\x2\x2\x226\x227\x5\x6\x4"+
		"\x2\x227G\x3\x2\x2\x2\x228\x229\x5\x1C\xF\x2\x229I\x3\x2\x2\x2\x22A\x22D"+
		"\x5\x1A\xE\x2\x22B\x22D\x5L\'\x2\x22C\x22A\x3\x2\x2\x2\x22C\x22B\x3\x2"+
		"\x2\x2\x22DK\x3\x2\x2\x2\x22E\x231\x5> \x2\x22F\x231\x5*\x16\x2\x230\x22E"+
		"\x3\x2\x2\x2\x230\x22F\x3\x2\x2\x2\x231M\x3\x2\x2\x2\x232\x233\a\x34\x2"+
		"\x2\x233\x234\x5n\x38\x2\x234\x235\x5P)\x2\x235O\x3\x2\x2\x2\x236\x239"+
		"\x5*\x16\x2\x237\x239\x5> \x2\x238\x236\x3\x2\x2\x2\x238\x237\x3\x2\x2"+
		"\x2\x239Q\x3\x2\x2\x2\x23A\x243\x5T+\x2\x23B\x243\x5X-\x2\x23C\x243\x5"+
		"Z.\x2\x23D\x243\x5`\x31\x2\x23E\x243\x5\\/\x2\x23F\x243\x5\x66\x34\x2"+
		"\x240\x243\x5V,\x2\x241\x243\x5\x62\x32\x2\x242\x23A\x3\x2\x2\x2\x242"+
		"\x23B\x3\x2\x2\x2\x242\x23C\x3\x2\x2\x2\x242\x23D\x3\x2\x2\x2\x242\x23E"+
		"\x3\x2\x2\x2\x242\x23F\x3\x2\x2\x2\x242\x240\x3\x2\x2\x2\x242\x241\x3"+
		"\x2\x2\x2\x243S\x3\x2\x2\x2\x244\x245\t\b\x2\x2\x245U\x3\x2\x2\x2\x246"+
		"\x247\a\xAB\x2\x2\x247W\x3\x2\x2\x2\x248\x249\t\t\x2\x2\x249Y\x3\x2\x2"+
		"\x2\x24A\x24B\t\n\x2\x2\x24B[\x3\x2\x2\x2\x24C\x24F\a\x89\x2\x2\x24D\x24F"+
		"\x5^\x30\x2\x24E\x24C\x3\x2\x2\x2\x24E\x24D\x3\x2\x2\x2\x24F]\x3\x2\x2"+
		"\x2\x250\x251\t\v\x2\x2\x251_\x3\x2\x2\x2\x252\x253\t\f\x2\x2\x253\x61"+
		"\x3\x2\x2\x2\x254\x255\t\r\x2\x2\x255\x63\x3\x2\x2\x2\x256\x257\t\xE\x2"+
		"\x2\x257\x65\x3\x2\x2\x2\x258\x25C\x5h\x35\x2\x259\x25C\x5j\x36\x2\x25A"+
		"\x25C\x5l\x37\x2\x25B\x258\x3\x2\x2\x2\x25B\x259\x3\x2\x2\x2\x25B\x25A"+
		"\x3\x2\x2\x2\x25Cg\x3\x2\x2\x2\x25D\x25E\t\xF\x2\x2\x25Ei\x3\x2\x2\x2"+
		"\x25F\x260\a\x8F\x2\x2\x260k\x3\x2\x2\x2\x261\x262\t\x10\x2\x2\x262m\x3"+
		"\x2\x2\x2\x263\x265\t\x11\x2\x2\x264\x263\x3\x2\x2\x2\x265\x266\x3\x2"+
		"\x2\x2\x266\x264\x3\x2\x2\x2\x266\x267\x3\x2\x2\x2\x267o\x3\x2\x2\x2Y"+
		"ry~\x82\x86\x8A\x9A\xA7\xB0\xB4\xBB\xBF\xC2\xC7\xCC\xD4\xD8\xDF\xE3\xE7"+
		"\xEC\xF0\xF5\xF9\xFE\x102\x107\x10B\x110\x114\x119\x11D\x122\x126\x12B"+
		"\x12F\x134\x138\x13D\x141\x146\x14A\x14D\x14F\x157\x159\x15F\x163\x177"+
		"\x17B\x17F\x182\x185\x18E\x19E\x1A0\x1AA\x1AF\x1B3\x1B7\x1BA\x1BD\x1D0"+
		"\x1D5\x1D8\x1DC\x1E0\x1E5\x1E8\x1EC\x1F0\x1F4\x1FC\x200\x205\x20A\x20E"+
		"\x214\x218\x220\x22C\x230\x238\x242\x24E\x25B\x266";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace Rubberduck.Parsing.Binding
