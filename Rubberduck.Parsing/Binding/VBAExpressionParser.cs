//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\Splinter\Documents\Visual Studio 2015\Projects\RubberduckParserTest\RubberduckParserTest\VBAExpressionParser.g4 by ANTLR 4.3

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

namespace Rubberduck.Parsing.Binding {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.3")]
[System.CLSCompliant(false)]
public partial class VBAExpressionParser : Parser {
	public const int
		PRINT=156, ELSEIF=88, CBYTE=5, CLOSE=65, STATIC=180, MINUS=212, OPTION_EXPLICIT=149, 
		L_SQUARE_BRACKET=223, DOEVENTS=21, HASHENDIF=222, DATELITERAL=230, ERROR=102, 
		NOTHING=141, EACH=86, SUB=184, STOP=182, LPAREN=210, MID=136, CVERR=19, 
		AS=55, END_PROPERTY=93, AT=45, DATABASE=67, GOSUB=115, CSNG=15, HASHCONST=218, 
		POW=216, DOLLAR=47, PROPERTY_LET=159, THEN=187, XOR=202, EXIT_FOR=105, 
		DEFINT=75, HASHIF=219, UNLOCK=192, CALL=62, LOCK_READ=131, SET=176, LOCK_READ_WRITE=133, 
		ABS=1, LSET=134, RAISEEVENT=165, MIDBTYPESUFFIX=32, SEEK=174, LONG=125, 
		CBOOL=4, LIB=128, DIM=83, APPEND=54, OPEN=146, DIV=204, PROPERTY_SET=160, 
		CDBL=8, PERCENT=46, END_SELECT=94, STRING=183, HASHELSEIF=220, SGN=37, 
		REM=169, TO=188, DEFDBL=73, BYVAL=59, FRIEND=110, LOOP=126, CLASS=64, 
		DO=84, VARIANT=194, END_WITH=97, DEFBOOL=70, OPTIONAL=147, ADDRESSOF=50, 
		CONST=66, RSET=173, INTEGER=123, CDEC=9, ATTRIBUTE=53, OUTPUT=153, FOR=111, 
		PTRSAFE=161, EQ=206, BOOLEAN=58, CIRCLE=11, END_FUNCTION=91, DEFSNG=80, 
		DEFBYTE=71, NOT=140, CINT=10, END=98, PRESERVE=155, ON_LOCAL_ERROR=145, 
		FLOATLITERAL=228, HASHELSE=221, BINARY=57, LENB=28, RETURN=172, EXCLAMATIONPOINT=42, 
		NEXT=138, GLOBAL=114, INPUTB=24, IDENTIFIER=235, WS=234, EMPTY=89, CURRENCY=17, 
		CCUR=6, MOD=137, WITHEVENTS=200, COLON=40, DEFLNGLNG=77, STEP=181, OPTION_BASE=148, 
		GT=208, PUT=163, WITH=199, CSTR=16, LOCK_WRITE=132, LINE_CONTINUATION=236, 
		TYPEOF=191, DEFVAR=82, DEFLNG=76, UBOUND=38, FALSE=109, ERRORCHAR=238, 
		UNDERSCORE=233, INTEGERLITERAL=229, END_IF=92, LOCK=124, TEXT=186, SINGLEQUOTE=232, 
		MULT=213, SEMICOLON=41, BYTE=61, HEXLITERAL=227, ELSE=87, IF=117, TYPE=190, 
		AMPERSAND=48, DEFLNGPTR=78, ENUM=99, DEFOBJ=79, IN=120, OPTION=34, DOT=43, 
		EXIT_DO=104, GUIDLITERAL=237, IS=122, EQV=100, WEND=196, FUNCTION=112, 
		HASH=44, CASE=63, GEQ=207, GET=113, PUBLIC=162, ON_ERROR=144, EXIT=22, 
		MIDB=31, END_ENUM=90, GOTO=116, INTDIV=205, LONGPTR=30, WIDTH=198, BEGIN=56, 
		EXIT_SUB=108, ASSIGN=203, WRITE=201, DOUBLE=85, EXIT_PROPERTY=107, COMMA=39, 
		RANDOM=164, PROPERTY_GET=158, SELECT=175, PRIVATE=157, ERASE=101, TAB=185, 
		BYREF=60, VERSION=195, NEQ=214, END_TYPE=96, NEW=139, ARRAY=3, INPUT=121, 
		SINGLE=178, ALIAS=51, SPC=179, LT=211, RESET=170, END_SUB=95, EVENT=103, 
		READ_WRITE=167, OPTION_COMPARE=150, ME=135, SCALE=36, CDATE=7, MIDTYPESUFFIX=33, 
		NULL=142, NEWLINE=231, TRUE=189, RPAREN=217, IMP=118, STRINGLITERAL=225, 
		OCTLITERAL=226, READ=166, DATE=68, LIKE=129, AND=52, OPTION_PRIVATE_MODULE=151, 
		CLNGLNG=13, PLUS=215, ANY=2, RESUME=171, INT=25, SHARED=177, EXIT_FUNCTION=106, 
		PSET=35, ACCESS=49, LINE_INPUT=130, ON=143, OR=152, PARAMARRAY=154, LBOUND=26, 
		R_SQUARE_BRACKET=224, IMPLEMENTS=119, UNTIL=193, DEBUG=20, DEFCUR=74, 
		CLNGPTR=14, LONGLONG=29, DECLARE=69, DEFDATE=72, FIX=23, LEN=27, REDIM=168, 
		LEQ=209, DEFSTR=81, LET=127, WHILE=197, CVAR=18, CLNG=12, FOREIGNNAME=239, 
		OBJECT=240, COLLECTION=241;
	public static readonly string[] tokenNames = {
		"<INVALID>", "ABS", "ANY", "ARRAY", "CBOOL", "CBYTE", "CCUR", "CDATE", 
		"CDBL", "CDEC", "CINT", "CIRCLE", "CLNG", "CLNGLNG", "CLNGPTR", "CSNG", 
		"CSTR", "CURRENCY", "CVAR", "CVERR", "DEBUG", "DOEVENTS", "EXIT", "FIX", 
		"INPUTB", "INT", "LBOUND", "LEN", "LENB", "LONGLONG", "LONGPTR", "MIDB", 
		"MIDBTYPESUFFIX", "MIDTYPESUFFIX", "OPTION", "PSET", "SCALE", "SGN", "UBOUND", 
		"','", "':'", "';'", "'!'", "'.'", "'#'", "'@'", "'%'", "'$'", "'&'", 
		"ACCESS", "ADDRESSOF", "ALIAS", "AND", "ATTRIBUTE", "APPEND", "AS", "BEGIN", 
		"BINARY", "BOOLEAN", "BYVAL", "BYREF", "BYTE", "CALL", "CASE", "CLASS", 
		"CLOSE", "CONST", "DATABASE", "DATE", "DECLARE", "DEFBOOL", "DEFBYTE", 
		"DEFDATE", "DEFDBL", "DEFCUR", "DEFINT", "DEFLNG", "DEFLNGLNG", "DEFLNGPTR", 
		"DEFOBJ", "DEFSNG", "DEFSTR", "DEFVAR", "DIM", "DO", "DOUBLE", "EACH", 
		"ELSE", "ELSEIF", "EMPTY", "END_ENUM", "END_FUNCTION", "END_IF", "END_PROPERTY", 
		"END_SELECT", "END_SUB", "END_TYPE", "END_WITH", "END", "ENUM", "EQV", 
		"ERASE", "ERROR", "EVENT", "EXIT_DO", "EXIT_FOR", "EXIT_FUNCTION", "EXIT_PROPERTY", 
		"EXIT_SUB", "FALSE", "FRIEND", "FOR", "FUNCTION", "GET", "GLOBAL", "GOSUB", 
		"GOTO", "IF", "IMP", "IMPLEMENTS", "IN", "INPUT", "IS", "INTEGER", "LOCK", 
		"LONG", "LOOP", "LET", "LIB", "LIKE", "LINE_INPUT", "LOCK_READ", "LOCK_WRITE", 
		"LOCK_READ_WRITE", "LSET", "ME", "MID", "MOD", "NEXT", "NEW", "NOT", "NOTHING", 
		"NULL", "ON", "ON_ERROR", "ON_LOCAL_ERROR", "OPEN", "OPTIONAL", "OPTION_BASE", 
		"OPTION_EXPLICIT", "OPTION_COMPARE", "OPTION_PRIVATE_MODULE", "OR", "OUTPUT", 
		"PARAMARRAY", "PRESERVE", "PRINT", "PRIVATE", "PROPERTY_GET", "PROPERTY_LET", 
		"PROPERTY_SET", "PTRSAFE", "PUBLIC", "PUT", "RANDOM", "RAISEEVENT", "READ", 
		"READ_WRITE", "REDIM", "REM", "RESET", "RESUME", "RETURN", "RSET", "SEEK", 
		"SELECT", "SET", "SHARED", "SINGLE", "SPC", "STATIC", "STEP", "STOP", 
		"STRING", "SUB", "TAB", "TEXT", "THEN", "TO", "TRUE", "TYPE", "TYPEOF", 
		"UNLOCK", "UNTIL", "VARIANT", "VERSION", "WEND", "WHILE", "WIDTH", "WITH", 
		"WITHEVENTS", "WRITE", "XOR", "':='", "'/'", "'\\'", "'='", "GEQ", "'>'", 
		"LEQ", "'('", "'<'", "'-'", "'*'", "NEQ", "'+'", "'^'", "')'", "HASHCONST", 
		"HASHIF", "HASHELSEIF", "HASHELSE", "HASHENDIF", "'['", "']'", "STRINGLITERAL", 
		"OCTLITERAL", "HEXLITERAL", "FLOATLITERAL", "INTEGERLITERAL", "DATELITERAL", 
		"NEWLINE", "'''", "'_'", "WS", "IDENTIFIER", "LINE_CONTINUATION", "GUIDLITERAL", 
		"ERRORCHAR", "FOREIGNNAME", "OBJECT", "COLLECTION"
	};
	public const int
		RULE_startRule = 0, RULE_callStmt = 1, RULE_unrestrictedName = 2, RULE_name = 3, 
		RULE_reservedIdentifierName = 4, RULE_reservedUntypedName = 5, RULE_reservedTypedName = 6, 
		RULE_untypedName = 7, RULE_typedName = 8, RULE_typedNameValue = 9, RULE_typeSuffix = 10, 
		RULE_optionCompareArgument = 11, RULE_builtInType = 12, RULE_expression = 13, 
		RULE_literalExpression = 14, RULE_numberLiteral = 15, RULE_parenthesizedExpression = 16, 
		RULE_typeOfIsExpression = 17, RULE_newExpression = 18, RULE_lExpression = 19, 
		RULE_memberAccessExpression = 20, RULE_indexExpression = 21, RULE_dictionaryAccessExpression = 22, 
		RULE_argumentList = 23, RULE_positionalOrNamedArgumentList = 24, RULE_positionalArgument = 25, 
		RULE_requiredPositionalArgument = 26, RULE_namedArgumentList = 27, RULE_namedArgument = 28, 
		RULE_argumentExpression = 29, RULE_simpleNameExpression = 30, RULE_instanceExpression = 31, 
		RULE_withExpression = 32, RULE_withMemberAccessExpression = 33, RULE_withDictionaryAccessExpression = 34, 
		RULE_constantExpression = 35, RULE_typeExpression = 36, RULE_definedTypeExpression = 37, 
		RULE_addressOfExpression = 38, RULE_procedurePointerExpression = 39, RULE_reservedIdentifier = 40, 
		RULE_statementKeyword = 41, RULE_remKeyword = 42, RULE_markerKeyword = 43, 
		RULE_operatorIdentifier = 44, RULE_reservedName = 45, RULE_reservedProcedureName = 46, 
		RULE_specialForm = 47, RULE_reservedTypeIdentifier = 48, RULE_uncategorizedKeyword = 49, 
		RULE_literalIdentifier = 50, RULE_booleanLiteralIdentifier = 51, RULE_objectLiteralIdentifier = 52, 
		RULE_variantLiteralIdentifier = 53, RULE_whiteSpace = 54;
	public static readonly string[] ruleNames = {
		"startRule", "callStmt", "unrestrictedName", "name", "reservedIdentifierName", 
		"reservedUntypedName", "reservedTypedName", "untypedName", "typedName", 
		"typedNameValue", "typeSuffix", "optionCompareArgument", "builtInType", 
		"expression", "literalExpression", "numberLiteral", "parenthesizedExpression", 
		"typeOfIsExpression", "newExpression", "lExpression", "memberAccessExpression", 
		"indexExpression", "dictionaryAccessExpression", "argumentList", "positionalOrNamedArgumentList", 
		"positionalArgument", "requiredPositionalArgument", "namedArgumentList", 
		"namedArgument", "argumentExpression", "simpleNameExpression", "instanceExpression", 
		"withExpression", "withMemberAccessExpression", "withDictionaryAccessExpression", 
		"constantExpression", "typeExpression", "definedTypeExpression", "addressOfExpression", 
		"procedurePointerExpression", "reservedIdentifier", "statementKeyword", 
		"remKeyword", "markerKeyword", "operatorIdentifier", "reservedName", "reservedProcedureName", 
		"specialForm", "reservedTypeIdentifier", "uncategorizedKeyword", "literalIdentifier", 
		"booleanLiteralIdentifier", "objectLiteralIdentifier", "variantLiteralIdentifier", 
		"whiteSpace"
	};

	public override string GrammarFileName { get { return "VBAExpressionParser.g4"; } }

	public override string[] TokenNames { get { return tokenNames; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public VBAExpressionParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class StartRuleContext : ParserRuleContext {
		public CallStmtContext callStmt() {
			return GetRuleContext<CallStmtContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(VBAExpressionParser.Eof, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public StartRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_startRule; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterStartRule(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitStartRule(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStartRule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StartRuleContext startRule() {
		StartRuleContext _localctx = new StartRuleContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_startRule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 112;
			switch ( Interpreter.AdaptivePredict(_input,0,_ctx) ) {
			case 1:
				{
				State = 110; expression(0);
				}
				break;

			case 2:
				{
				State = 111; callStmt();
				}
				break;
			}
			State = 114; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CallStmtContext : ParserRuleContext {
		public MemberAccessExpressionContext memberAccessExpression() {
			return GetRuleContext<MemberAccessExpressionContext>(0);
		}
		public WithExpressionContext withExpression() {
			return GetRuleContext<WithExpressionContext>(0);
		}
		public SimpleNameExpressionContext simpleNameExpression() {
			return GetRuleContext<SimpleNameExpressionContext>(0);
		}
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		public CallStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_callStmt; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterCallStmt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitCallStmt(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCallStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CallStmtContext callStmt() {
		CallStmtContext _localctx = new CallStmtContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_callStmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 119;
			switch ( Interpreter.AdaptivePredict(_input,1,_ctx) ) {
			case 1:
				{
				State = 116; memberAccessExpression();
				}
				break;

			case 2:
				{
				State = 117; simpleNameExpression();
				}
				break;

			case 3:
				{
				State = 118; withExpression();
				}
				break;
			}
			State = 124;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 121; whiteSpace();
				State = 122; argumentList();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnrestrictedNameContext : ParserRuleContext {
		public ReservedIdentifierNameContext reservedIdentifierName() {
			return GetRuleContext<ReservedIdentifierNameContext>(0);
		}
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public UnrestrictedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unrestrictedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterUnrestrictedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitUnrestrictedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnrestrictedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnrestrictedNameContext unrestrictedName() {
		UnrestrictedNameContext _localctx = new UnrestrictedNameContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_unrestrictedName);
		try {
			State = 128;
			switch ( Interpreter.AdaptivePredict(_input,3,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 126; name();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 127; reservedIdentifierName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NameContext : ParserRuleContext {
		public TypedNameContext typedName() {
			return GetRuleContext<TypedNameContext>(0);
		}
		public UntypedNameContext untypedName() {
			return GetRuleContext<UntypedNameContext>(0);
		}
		public NameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NameContext name() {
		NameContext _localctx = new NameContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_name);
		try {
			State = 132;
			switch ( Interpreter.AdaptivePredict(_input,4,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 130; untypedName();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 131; typedName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedIdentifierNameContext : ParserRuleContext {
		public ReservedTypedNameContext reservedTypedName() {
			return GetRuleContext<ReservedTypedNameContext>(0);
		}
		public ReservedUntypedNameContext reservedUntypedName() {
			return GetRuleContext<ReservedUntypedNameContext>(0);
		}
		public ReservedIdentifierNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedIdentifierName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedIdentifierName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedIdentifierName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedIdentifierName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedIdentifierNameContext reservedIdentifierName() {
		ReservedIdentifierNameContext _localctx = new ReservedIdentifierNameContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_reservedIdentifierName);
		try {
			State = 136;
			switch ( Interpreter.AdaptivePredict(_input,5,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 134; reservedUntypedName();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 135; reservedTypedName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedUntypedNameContext : ParserRuleContext {
		public ReservedIdentifierContext reservedIdentifier() {
			return GetRuleContext<ReservedIdentifierContext>(0);
		}
		public ReservedUntypedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedUntypedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedUntypedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedUntypedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedUntypedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedUntypedNameContext reservedUntypedName() {
		ReservedUntypedNameContext _localctx = new ReservedUntypedNameContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_reservedUntypedName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 138; reservedIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedTypedNameContext : ParserRuleContext {
		public TypeSuffixContext typeSuffix() {
			return GetRuleContext<TypeSuffixContext>(0);
		}
		public ReservedIdentifierContext reservedIdentifier() {
			return GetRuleContext<ReservedIdentifierContext>(0);
		}
		public ReservedTypedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedTypedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedTypedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedTypedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedTypedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedTypedNameContext reservedTypedName() {
		ReservedTypedNameContext _localctx = new ReservedTypedNameContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_reservedTypedName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 140; reservedIdentifier();
			State = 141; typeSuffix();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UntypedNameContext : ParserRuleContext {
		public UncategorizedKeywordContext uncategorizedKeyword() {
			return GetRuleContext<UncategorizedKeywordContext>(0);
		}
		public ITerminalNode FOREIGNNAME() { return GetToken(VBAExpressionParser.FOREIGNNAME, 0); }
		public SpecialFormContext specialForm() {
			return GetRuleContext<SpecialFormContext>(0);
		}
		public ITerminalNode OBJECT() { return GetToken(VBAExpressionParser.OBJECT, 0); }
		public ITerminalNode ERROR() { return GetToken(VBAExpressionParser.ERROR, 0); }
		public OptionCompareArgumentContext optionCompareArgument() {
			return GetRuleContext<OptionCompareArgumentContext>(0);
		}
		public ITerminalNode IDENTIFIER() { return GetToken(VBAExpressionParser.IDENTIFIER, 0); }
		public ReservedProcedureNameContext reservedProcedureName() {
			return GetRuleContext<ReservedProcedureNameContext>(0);
		}
		public UntypedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_untypedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterUntypedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitUntypedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUntypedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UntypedNameContext untypedName() {
		UntypedNameContext _localctx = new UntypedNameContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_untypedName);
		try {
			State = 151;
			switch ( Interpreter.AdaptivePredict(_input,6,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 143; Match(IDENTIFIER);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 144; Match(FOREIGNNAME);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 145; reservedProcedureName();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 146; specialForm();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 147; optionCompareArgument();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 148; Match(OBJECT);
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 149; uncategorizedKeyword();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 150; Match(ERROR);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypedNameContext : ParserRuleContext {
		public TypeSuffixContext typeSuffix() {
			return GetRuleContext<TypeSuffixContext>(0);
		}
		public TypedNameValueContext typedNameValue() {
			return GetRuleContext<TypedNameValueContext>(0);
		}
		public TypedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypedNameContext typedName() {
		TypedNameContext _localctx = new TypedNameContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_typedName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 153; typedNameValue();
			State = 154; typeSuffix();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypedNameValueContext : ParserRuleContext {
		public UncategorizedKeywordContext uncategorizedKeyword() {
			return GetRuleContext<UncategorizedKeywordContext>(0);
		}
		public SpecialFormContext specialForm() {
			return GetRuleContext<SpecialFormContext>(0);
		}
		public ITerminalNode OBJECT() { return GetToken(VBAExpressionParser.OBJECT, 0); }
		public ITerminalNode ERROR() { return GetToken(VBAExpressionParser.ERROR, 0); }
		public OptionCompareArgumentContext optionCompareArgument() {
			return GetRuleContext<OptionCompareArgumentContext>(0);
		}
		public ITerminalNode IDENTIFIER() { return GetToken(VBAExpressionParser.IDENTIFIER, 0); }
		public ReservedProcedureNameContext reservedProcedureName() {
			return GetRuleContext<ReservedProcedureNameContext>(0);
		}
		public TypedNameValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typedNameValue; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypedNameValue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypedNameValue(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypedNameValue(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypedNameValueContext typedNameValue() {
		TypedNameValueContext _localctx = new TypedNameValueContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_typedNameValue);
		try {
			State = 163;
			switch ( Interpreter.AdaptivePredict(_input,7,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 156; Match(IDENTIFIER);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 157; reservedProcedureName();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 158; specialForm();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 159; optionCompareArgument();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 160; Match(OBJECT);
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 161; uncategorizedKeyword();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 162; Match(ERROR);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeSuffixContext : ParserRuleContext {
		public ITerminalNode AT() { return GetToken(VBAExpressionParser.AT, 0); }
		public ITerminalNode DOLLAR() { return GetToken(VBAExpressionParser.DOLLAR, 0); }
		public ITerminalNode EXCLAMATIONPOINT() { return GetToken(VBAExpressionParser.EXCLAMATIONPOINT, 0); }
		public ITerminalNode AMPERSAND() { return GetToken(VBAExpressionParser.AMPERSAND, 0); }
		public ITerminalNode PERCENT() { return GetToken(VBAExpressionParser.PERCENT, 0); }
		public ITerminalNode POW() { return GetToken(VBAExpressionParser.POW, 0); }
		public ITerminalNode HASH() { return GetToken(VBAExpressionParser.HASH, 0); }
		public TypeSuffixContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeSuffix; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypeSuffix(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypeSuffix(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeSuffix(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeSuffixContext typeSuffix() {
		TypeSuffixContext _localctx = new TypeSuffixContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_typeSuffix);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 165;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << EXCLAMATIONPOINT) | (1L << HASH) | (1L << AT) | (1L << PERCENT) | (1L << DOLLAR) | (1L << AMPERSAND))) != 0) || _la==POW) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OptionCompareArgumentContext : ParserRuleContext {
		public ITerminalNode TEXT() { return GetToken(VBAExpressionParser.TEXT, 0); }
		public ITerminalNode DATABASE() { return GetToken(VBAExpressionParser.DATABASE, 0); }
		public ITerminalNode BINARY() { return GetToken(VBAExpressionParser.BINARY, 0); }
		public OptionCompareArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_optionCompareArgument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterOptionCompareArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitOptionCompareArgument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOptionCompareArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OptionCompareArgumentContext optionCompareArgument() {
		OptionCompareArgumentContext _localctx = new OptionCompareArgumentContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_optionCompareArgument);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 167;
			_la = _input.La(1);
			if ( !(_la==BINARY || _la==DATABASE || _la==TEXT) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BuiltInTypeContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode OBJECT() { return GetToken(VBAExpressionParser.OBJECT, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ReservedTypeIdentifierContext reservedTypeIdentifier() {
			return GetRuleContext<ReservedTypeIdentifierContext>(0);
		}
		public ITerminalNode L_SQUARE_BRACKET() { return GetToken(VBAExpressionParser.L_SQUARE_BRACKET, 0); }
		public ITerminalNode R_SQUARE_BRACKET() { return GetToken(VBAExpressionParser.R_SQUARE_BRACKET, 0); }
		public BuiltInTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_builtInType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterBuiltInType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitBuiltInType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltInType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BuiltInTypeContext builtInType() {
		BuiltInTypeContext _localctx = new BuiltInTypeContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_builtInType);
		int _la;
		try {
			State = 190;
			switch ( Interpreter.AdaptivePredict(_input,12,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 169; reservedTypeIdentifier();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 170; Match(L_SQUARE_BRACKET);
				State = 172;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 171; whiteSpace();
					}
				}

				State = 174; reservedTypeIdentifier();
				State = 176;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 175; whiteSpace();
					}
				}

				State = 178; Match(R_SQUARE_BRACKET);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 180; Match(OBJECT);
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 181; Match(L_SQUARE_BRACKET);
				State = 183;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 182; whiteSpace();
					}
				}

				State = 185; Match(OBJECT);
				State = 187;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 186; whiteSpace();
					}
				}

				State = 189; Match(R_SQUARE_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
	 
		public ExpressionContext() { }
		public virtual void CopyFrom(ExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class UnaryMinusOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public ITerminalNode MINUS() { return GetToken(VBAExpressionParser.MINUS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public UnaryMinusOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterUnaryMinusOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitUnaryMinusOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryMinusOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NewExprContext : ExpressionContext {
		public NewExpressionContext newExpression() {
			return GetRuleContext<NewExpressionContext>(0);
		}
		public NewExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterNewExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitNewExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNewExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PowOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode POW() { return GetToken(VBAExpressionParser.POW, 0); }
		public PowOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterPowOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitPowOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPowOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AddOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode PLUS() { return GetToken(VBAExpressionParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(VBAExpressionParser.MINUS, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public AddOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterAddOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitAddOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAddOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TypeOfIsExprContext : ExpressionContext {
		public TypeOfIsExpressionContext typeOfIsExpression() {
			return GetRuleContext<TypeOfIsExpressionContext>(0);
		}
		public TypeOfIsExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypeOfIsExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypeOfIsExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeOfIsExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class IntDivOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode INTDIV() { return GetToken(VBAExpressionParser.INTDIV, 0); }
		public IntDivOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterIntDivOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitIntDivOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIntDivOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalImpOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode IMP() { return GetToken(VBAExpressionParser.IMP, 0); }
		public LogicalImpOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalImpOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalImpOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalImpOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ConcatOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode AMPERSAND() { return GetToken(VBAExpressionParser.AMPERSAND, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ConcatOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterConcatOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitConcatOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConcatOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ModOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode MOD() { return GetToken(VBAExpressionParser.MOD, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ModOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterModOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitModOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LExprContext : ExpressionContext {
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public LExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MultOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode MULT() { return GetToken(VBAExpressionParser.MULT, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode DIV() { return GetToken(VBAExpressionParser.DIV, 0); }
		public MultOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterMultOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitMultOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalXorOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode XOR() { return GetToken(VBAExpressionParser.XOR, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public LogicalXorOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalXorOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalXorOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalXorOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalAndOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode AND() { return GetToken(VBAExpressionParser.AND, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public LogicalAndOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalAndOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalAndOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalAndOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalOrOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode OR() { return GetToken(VBAExpressionParser.OR, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public LogicalOrOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalOrOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalOrOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalOrOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RelationalOpContext : ExpressionContext {
		public ITerminalNode GEQ() { return GetToken(VBAExpressionParser.GEQ, 0); }
		public ITerminalNode NEQ() { return GetToken(VBAExpressionParser.NEQ, 0); }
		public ITerminalNode IS() { return GetToken(VBAExpressionParser.IS, 0); }
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode LEQ() { return GetToken(VBAExpressionParser.LEQ, 0); }
		public ITerminalNode LT() { return GetToken(VBAExpressionParser.LT, 0); }
		public ITerminalNode GT() { return GetToken(VBAExpressionParser.GT, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode EQ() { return GetToken(VBAExpressionParser.EQ, 0); }
		public ITerminalNode LIKE() { return GetToken(VBAExpressionParser.LIKE, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public RelationalOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterRelationalOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitRelationalOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelationalOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalEqvOpContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode EQV() { return GetToken(VBAExpressionParser.EQV, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public LogicalEqvOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalEqvOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalEqvOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalEqvOp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ParenthesizedExprContext : ExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode LPAREN() { return GetToken(VBAExpressionParser.LPAREN, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode RPAREN() { return GetToken(VBAExpressionParser.RPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ParenthesizedExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterParenthesizedExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitParenthesizedExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthesizedExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LiteralExprContext : ExpressionContext {
		public LiteralExpressionContext literalExpression() {
			return GetRuleContext<LiteralExpressionContext>(0);
		}
		public LiteralExprContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLiteralExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLiteralExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalNotOpContext : ExpressionContext {
		public ITerminalNode NOT() { return GetToken(VBAExpressionParser.NOT, 0); }
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public LogicalNotOpContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLogicalNotOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLogicalNotOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalNotOp(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(_ctx, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 26;
		EnterRecursionRule(_localctx, 26, RULE_expression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 217;
			switch (_input.La(1)) {
			case MINUS:
				{
				_localctx = new UnaryMinusOpContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;

				State = 193; Match(MINUS);
				State = 195;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 194; whiteSpace();
					}
				}

				State = 197; expression(14);
				}
				break;
			case NOT:
				{
				_localctx = new LogicalNotOpContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 198; Match(NOT);
				State = 200;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 199; whiteSpace();
					}
				}

				State = 202; expression(7);
				}
				break;
			case ABS:
			case ARRAY:
			case CBOOL:
			case CBYTE:
			case CCUR:
			case CDATE:
			case CDBL:
			case CDEC:
			case CINT:
			case CIRCLE:
			case CLNG:
			case CLNGLNG:
			case CLNGPTR:
			case CSNG:
			case CSTR:
			case CVAR:
			case CVERR:
			case DEBUG:
			case DOEVENTS:
			case FIX:
			case INPUTB:
			case INT:
			case LBOUND:
			case LEN:
			case LENB:
			case MIDB:
			case MIDBTYPESUFFIX:
			case MIDTYPESUFFIX:
			case PSET:
			case SCALE:
			case SGN:
			case UBOUND:
			case EXCLAMATIONPOINT:
			case DOT:
			case ALIAS:
			case ATTRIBUTE:
			case BEGIN:
			case BINARY:
			case CLASS:
			case DATABASE:
			case ERROR:
			case INPUT:
			case LIB:
			case ME:
			case MID:
			case ON:
			case TAB:
			case TEXT:
			case VERSION:
			case IDENTIFIER:
			case FOREIGNNAME:
			case OBJECT:
			case COLLECTION:
				{
				_localctx = new LExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 203; lExpression(0);
				}
				break;
			case LPAREN:
				{
				_localctx = new ParenthesizedExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 204; Match(LPAREN);
				State = 206;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 205; whiteSpace();
					}
				}

				State = 208; expression(0);
				State = 210;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 209; whiteSpace();
					}
				}

				State = 212; Match(RPAREN);
				}
				break;
			case TYPEOF:
				{
				_localctx = new TypeOfIsExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 214; typeOfIsExpression();
				}
				break;
			case NEW:
				{
				_localctx = new NewExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 215; newExpression();
				}
				break;
			case EMPTY:
			case FALSE:
			case NOTHING:
			case NULL:
			case TRUE:
			case STRINGLITERAL:
			case OCTLITERAL:
			case HEXLITERAL:
			case FLOATLITERAL:
			case INTEGERLITERAL:
			case DATELITERAL:
				{
				_localctx = new LiteralExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 216; literalExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			_ctx.stop = _input.Lt(-1);
			State = 329;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,43,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 327;
					switch ( Interpreter.AdaptivePredict(_input,42,_ctx) ) {
					case 1:
						{
						_localctx = new PowOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 219;
						if (!(Precpred(_ctx, 15))) throw new FailedPredicateException(this, "Precpred(_ctx, 15)");
						State = 221;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 220; whiteSpace();
							}
						}

						State = 223; Match(POW);
						State = 225;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 224; whiteSpace();
							}
						}

						State = 227; expression(16);
						}
						break;

					case 2:
						{
						_localctx = new MultOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 228;
						if (!(Precpred(_ctx, 13))) throw new FailedPredicateException(this, "Precpred(_ctx, 13)");
						State = 230;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 229; whiteSpace();
							}
						}

						State = 232;
						_la = _input.La(1);
						if ( !(_la==DIV || _la==MULT) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 234;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 233; whiteSpace();
							}
						}

						State = 236; expression(14);
						}
						break;

					case 3:
						{
						_localctx = new IntDivOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 237;
						if (!(Precpred(_ctx, 12))) throw new FailedPredicateException(this, "Precpred(_ctx, 12)");
						State = 239;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 238; whiteSpace();
							}
						}

						State = 241; Match(INTDIV);
						State = 243;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 242; whiteSpace();
							}
						}

						State = 245; expression(13);
						}
						break;

					case 4:
						{
						_localctx = new ModOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 246;
						if (!(Precpred(_ctx, 11))) throw new FailedPredicateException(this, "Precpred(_ctx, 11)");
						State = 248;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 247; whiteSpace();
							}
						}

						State = 250; Match(MOD);
						State = 252;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 251; whiteSpace();
							}
						}

						State = 254; expression(12);
						}
						break;

					case 5:
						{
						_localctx = new AddOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 255;
						if (!(Precpred(_ctx, 10))) throw new FailedPredicateException(this, "Precpred(_ctx, 10)");
						State = 257;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 256; whiteSpace();
							}
						}

						State = 259;
						_la = _input.La(1);
						if ( !(_la==MINUS || _la==PLUS) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 261;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 260; whiteSpace();
							}
						}

						State = 263; expression(11);
						}
						break;

					case 6:
						{
						_localctx = new ConcatOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 264;
						if (!(Precpred(_ctx, 9))) throw new FailedPredicateException(this, "Precpred(_ctx, 9)");
						State = 266;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 265; whiteSpace();
							}
						}

						State = 268; Match(AMPERSAND);
						State = 270;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 269; whiteSpace();
							}
						}

						State = 272; expression(10);
						}
						break;

					case 7:
						{
						_localctx = new RelationalOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 273;
						if (!(Precpred(_ctx, 8))) throw new FailedPredicateException(this, "Precpred(_ctx, 8)");
						State = 275;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 274; whiteSpace();
							}
						}

						State = 277;
						_la = _input.La(1);
						if ( !(_la==IS || _la==LIKE || ((((_la - 206)) & ~0x3f) == 0 && ((1L << (_la - 206)) & ((1L << (EQ - 206)) | (1L << (GEQ - 206)) | (1L << (GT - 206)) | (1L << (LEQ - 206)) | (1L << (LT - 206)) | (1L << (NEQ - 206)))) != 0)) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 279;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 278; whiteSpace();
							}
						}

						State = 281; expression(9);
						}
						break;

					case 8:
						{
						_localctx = new LogicalAndOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 282;
						if (!(Precpred(_ctx, 6))) throw new FailedPredicateException(this, "Precpred(_ctx, 6)");
						State = 284;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 283; whiteSpace();
							}
						}

						State = 286; Match(AND);
						State = 288;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 287; whiteSpace();
							}
						}

						State = 290; expression(7);
						}
						break;

					case 9:
						{
						_localctx = new LogicalOrOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 291;
						if (!(Precpred(_ctx, 5))) throw new FailedPredicateException(this, "Precpred(_ctx, 5)");
						State = 293;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 292; whiteSpace();
							}
						}

						State = 295; Match(OR);
						State = 297;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 296; whiteSpace();
							}
						}

						State = 299; expression(6);
						}
						break;

					case 10:
						{
						_localctx = new LogicalXorOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 300;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 302;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 301; whiteSpace();
							}
						}

						State = 304; Match(XOR);
						State = 306;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 305; whiteSpace();
							}
						}

						State = 308; expression(5);
						}
						break;

					case 11:
						{
						_localctx = new LogicalEqvOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 309;
						if (!(Precpred(_ctx, 3))) throw new FailedPredicateException(this, "Precpred(_ctx, 3)");
						State = 311;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 310; whiteSpace();
							}
						}

						State = 313; Match(EQV);
						State = 315;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 314; whiteSpace();
							}
						}

						State = 317; expression(4);
						}
						break;

					case 12:
						{
						_localctx = new LogicalImpOpContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 318;
						if (!(Precpred(_ctx, 2))) throw new FailedPredicateException(this, "Precpred(_ctx, 2)");
						State = 320;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 319; whiteSpace();
							}
						}

						State = 322; Match(IMP);
						State = 324;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 323; whiteSpace();
							}
						}

						State = 326; expression(3);
						}
						break;
					}
					} 
				}
				State = 331;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,43,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class LiteralExpressionContext : ParserRuleContext {
		public ITerminalNode STRINGLITERAL() { return GetToken(VBAExpressionParser.STRINGLITERAL, 0); }
		public TypeSuffixContext typeSuffix() {
			return GetRuleContext<TypeSuffixContext>(0);
		}
		public ITerminalNode DATELITERAL() { return GetToken(VBAExpressionParser.DATELITERAL, 0); }
		public NumberLiteralContext numberLiteral() {
			return GetRuleContext<NumberLiteralContext>(0);
		}
		public LiteralIdentifierContext literalIdentifier() {
			return GetRuleContext<LiteralIdentifierContext>(0);
		}
		public LiteralExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literalExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLiteralExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLiteralExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralExpressionContext literalExpression() {
		LiteralExpressionContext _localctx = new LiteralExpressionContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_literalExpression);
		try {
			State = 339;
			switch (_input.La(1)) {
			case OCTLITERAL:
			case HEXLITERAL:
			case FLOATLITERAL:
			case INTEGERLITERAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 332; numberLiteral();
				}
				break;
			case DATELITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 333; Match(DATELITERAL);
				}
				break;
			case STRINGLITERAL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 334; Match(STRINGLITERAL);
				}
				break;
			case EMPTY:
			case FALSE:
			case NOTHING:
			case NULL:
			case TRUE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 335; literalIdentifier();
				State = 337;
				switch ( Interpreter.AdaptivePredict(_input,44,_ctx) ) {
				case 1:
					{
					State = 336; typeSuffix();
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumberLiteralContext : ParserRuleContext {
		public ITerminalNode INTEGERLITERAL() { return GetToken(VBAExpressionParser.INTEGERLITERAL, 0); }
		public ITerminalNode FLOATLITERAL() { return GetToken(VBAExpressionParser.FLOATLITERAL, 0); }
		public ITerminalNode HEXLITERAL() { return GetToken(VBAExpressionParser.HEXLITERAL, 0); }
		public ITerminalNode OCTLITERAL() { return GetToken(VBAExpressionParser.OCTLITERAL, 0); }
		public NumberLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numberLiteral; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterNumberLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitNumberLiteral(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumberLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumberLiteralContext numberLiteral() {
		NumberLiteralContext _localctx = new NumberLiteralContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_numberLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 341;
			_la = _input.La(1);
			if ( !(((((_la - 226)) & ~0x3f) == 0 && ((1L << (_la - 226)) & ((1L << (OCTLITERAL - 226)) | (1L << (HEXLITERAL - 226)) | (1L << (FLOATLITERAL - 226)) | (1L << (INTEGERLITERAL - 226)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParenthesizedExpressionContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode LPAREN() { return GetToken(VBAExpressionParser.LPAREN, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode RPAREN() { return GetToken(VBAExpressionParser.RPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ParenthesizedExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parenthesizedExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterParenthesizedExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitParenthesizedExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthesizedExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParenthesizedExpressionContext parenthesizedExpression() {
		ParenthesizedExpressionContext _localctx = new ParenthesizedExpressionContext(_ctx, State);
		EnterRule(_localctx, 32, RULE_parenthesizedExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 343; Match(LPAREN);
			State = 345;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 344; whiteSpace();
				}
			}

			State = 347; expression(0);
			State = 349;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 348; whiteSpace();
				}
			}

			State = 351; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeOfIsExpressionContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode IS() { return GetToken(VBAExpressionParser.IS, 0); }
		public ITerminalNode TYPEOF() { return GetToken(VBAExpressionParser.TYPEOF, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public TypeExpressionContext typeExpression() {
			return GetRuleContext<TypeExpressionContext>(0);
		}
		public TypeOfIsExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeOfIsExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypeOfIsExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypeOfIsExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeOfIsExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeOfIsExpressionContext typeOfIsExpression() {
		TypeOfIsExpressionContext _localctx = new TypeOfIsExpressionContext(_ctx, State);
		EnterRule(_localctx, 34, RULE_typeOfIsExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 353; Match(TYPEOF);
			State = 354; whiteSpace();
			State = 355; expression(0);
			State = 356; whiteSpace();
			State = 357; Match(IS);
			State = 358; whiteSpace();
			State = 359; typeExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NewExpressionContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public ITerminalNode NEW() { return GetToken(VBAExpressionParser.NEW, 0); }
		public TypeExpressionContext typeExpression() {
			return GetRuleContext<TypeExpressionContext>(0);
		}
		public NewExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_newExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterNewExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitNewExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNewExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NewExpressionContext newExpression() {
		NewExpressionContext _localctx = new NewExpressionContext(_ctx, State);
		EnterRule(_localctx, 36, RULE_newExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 361; Match(NEW);
			State = 362; whiteSpace();
			State = 363; typeExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LExpressionContext : ParserRuleContext {
		public LExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lExpression; } }
	 
		public LExpressionContext() { }
		public virtual void CopyFrom(LExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class IndexExprContext : LExpressionContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode LPAREN() { return GetToken(VBAExpressionParser.LPAREN, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode RPAREN() { return GetToken(VBAExpressionParser.RPAREN, 0); }
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		public IndexExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterIndexExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitIndexExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SimpleNameExprContext : LExpressionContext {
		public SimpleNameExpressionContext simpleNameExpression() {
			return GetRuleContext<SimpleNameExpressionContext>(0);
		}
		public SimpleNameExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterSimpleNameExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitSimpleNameExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleNameExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MemberAccessExprContext : LExpressionContext {
		public ITerminalNode DOT() { return GetToken(VBAExpressionParser.DOT, 0); }
		public ITerminalNode LINE_CONTINUATION() { return GetToken(VBAExpressionParser.LINE_CONTINUATION, 0); }
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public MemberAccessExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterMemberAccessExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitMemberAccessExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemberAccessExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class InstanceExprContext : LExpressionContext {
		public InstanceExpressionContext instanceExpression() {
			return GetRuleContext<InstanceExpressionContext>(0);
		}
		public InstanceExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterInstanceExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitInstanceExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInstanceExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class WithExprContext : LExpressionContext {
		public WithExpressionContext withExpression() {
			return GetRuleContext<WithExpressionContext>(0);
		}
		public WithExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterWithExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitWithExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DictionaryAccessExprContext : LExpressionContext {
		public IReadOnlyList<ITerminalNode> LINE_CONTINUATION() { return GetTokens(VBAExpressionParser.LINE_CONTINUATION); }
		public ITerminalNode EXCLAMATIONPOINT() { return GetToken(VBAExpressionParser.EXCLAMATIONPOINT, 0); }
		public ITerminalNode LINE_CONTINUATION(int i) {
			return GetToken(VBAExpressionParser.LINE_CONTINUATION, i);
		}
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public DictionaryAccessExprContext(LExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterDictionaryAccessExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitDictionaryAccessExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDictionaryAccessExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LExpressionContext lExpression() {
		return lExpression(0);
	}

	private LExpressionContext lExpression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		LExpressionContext _localctx = new LExpressionContext(_ctx, _parentState);
		LExpressionContext _prevctx = _localctx;
		int _startState = 38;
		EnterRecursionRule(_localctx, 38, RULE_lExpression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 369;
			switch (_input.La(1)) {
			case ME:
				{
				_localctx = new InstanceExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;

				State = 366; instanceExpression();
				}
				break;
			case ABS:
			case ARRAY:
			case CBOOL:
			case CBYTE:
			case CCUR:
			case CDATE:
			case CDBL:
			case CDEC:
			case CINT:
			case CIRCLE:
			case CLNG:
			case CLNGLNG:
			case CLNGPTR:
			case CSNG:
			case CSTR:
			case CVAR:
			case CVERR:
			case DEBUG:
			case DOEVENTS:
			case FIX:
			case INPUTB:
			case INT:
			case LBOUND:
			case LEN:
			case LENB:
			case MIDB:
			case MIDBTYPESUFFIX:
			case MIDTYPESUFFIX:
			case PSET:
			case SCALE:
			case SGN:
			case UBOUND:
			case ALIAS:
			case ATTRIBUTE:
			case BEGIN:
			case BINARY:
			case CLASS:
			case DATABASE:
			case ERROR:
			case INPUT:
			case LIB:
			case MID:
			case ON:
			case TAB:
			case TEXT:
			case VERSION:
			case IDENTIFIER:
			case FOREIGNNAME:
			case OBJECT:
			case COLLECTION:
				{
				_localctx = new SimpleNameExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 367; simpleNameExpression();
				}
				break;
			case EXCLAMATIONPOINT:
			case DOT:
				{
				_localctx = new WithExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 368; withExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			_ctx.stop = _input.Lt(-1);
			State = 410;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,55,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 408;
					switch ( Interpreter.AdaptivePredict(_input,54,_ctx) ) {
					case 1:
						{
						_localctx = new IndexExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 371;
						if (!(Precpred(_ctx, 9))) throw new FailedPredicateException(this, "Precpred(_ctx, 9)");
						State = 373;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 372; whiteSpace();
							}
						}

						State = 375; Match(LPAREN);
						State = 377;
						switch ( Interpreter.AdaptivePredict(_input,50,_ctx) ) {
						case 1:
							{
							State = 376; whiteSpace();
							}
							break;
						}
						State = 380;
						switch ( Interpreter.AdaptivePredict(_input,51,_ctx) ) {
						case 1:
							{
							State = 379; argumentList();
							}
							break;
						}
						State = 383;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 382; whiteSpace();
							}
						}

						State = 385; Match(RPAREN);
						}
						break;

					case 2:
						{
						_localctx = new MemberAccessExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 386;
						if (!(Precpred(_ctx, 8))) throw new FailedPredicateException(this, "Precpred(_ctx, 8)");
						State = 387; Match(DOT);
						State = 388; unrestrictedName();
						}
						break;

					case 3:
						{
						_localctx = new MemberAccessExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 389;
						if (!(Precpred(_ctx, 7))) throw new FailedPredicateException(this, "Precpred(_ctx, 7)");
						State = 390; Match(LINE_CONTINUATION);
						State = 392;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 391; whiteSpace();
							}
						}

						State = 394; Match(DOT);
						State = 395; unrestrictedName();
						}
						break;

					case 4:
						{
						_localctx = new DictionaryAccessExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 396;
						if (!(Precpred(_ctx, 6))) throw new FailedPredicateException(this, "Precpred(_ctx, 6)");
						State = 397; Match(EXCLAMATIONPOINT);
						State = 398; unrestrictedName();
						}
						break;

					case 5:
						{
						_localctx = new DictionaryAccessExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 399;
						if (!(Precpred(_ctx, 5))) throw new FailedPredicateException(this, "Precpred(_ctx, 5)");
						State = 400; Match(LINE_CONTINUATION);
						State = 401; Match(EXCLAMATIONPOINT);
						State = 402; unrestrictedName();
						}
						break;

					case 6:
						{
						_localctx = new DictionaryAccessExprContext(new LExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_lExpression);
						State = 403;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 404; Match(LINE_CONTINUATION);
						State = 405; Match(EXCLAMATIONPOINT);
						State = 406; Match(LINE_CONTINUATION);
						State = 407; unrestrictedName();
						}
						break;
					}
					} 
				}
				State = 412;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,55,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class MemberAccessExpressionContext : ParserRuleContext {
		public ITerminalNode DOT() { return GetToken(VBAExpressionParser.DOT, 0); }
		public ITerminalNode LINE_CONTINUATION() { return GetToken(VBAExpressionParser.LINE_CONTINUATION, 0); }
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public MemberAccessExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_memberAccessExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterMemberAccessExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitMemberAccessExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemberAccessExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MemberAccessExpressionContext memberAccessExpression() {
		MemberAccessExpressionContext _localctx = new MemberAccessExpressionContext(_ctx, State);
		EnterRule(_localctx, 40, RULE_memberAccessExpression);
		int _la;
		try {
			State = 425;
			switch ( Interpreter.AdaptivePredict(_input,57,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 413; lExpression(0);
				State = 414; Match(DOT);
				State = 415; unrestrictedName();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 417; lExpression(0);
				State = 418; Match(LINE_CONTINUATION);
				State = 420;
				_la = _input.La(1);
				if (_la==WS || _la==LINE_CONTINUATION) {
					{
					State = 419; whiteSpace();
					}
				}

				State = 422; Match(DOT);
				State = 423; unrestrictedName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexExpressionContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ITerminalNode LPAREN() { return GetToken(VBAExpressionParser.LPAREN, 0); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public ITerminalNode RPAREN() { return GetToken(VBAExpressionParser.RPAREN, 0); }
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		public IndexExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterIndexExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitIndexExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IndexExpressionContext indexExpression() {
		IndexExpressionContext _localctx = new IndexExpressionContext(_ctx, State);
		EnterRule(_localctx, 42, RULE_indexExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 427; lExpression(0);
			State = 429;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 428; whiteSpace();
				}
			}

			State = 431; Match(LPAREN);
			State = 433;
			switch ( Interpreter.AdaptivePredict(_input,59,_ctx) ) {
			case 1:
				{
				State = 432; whiteSpace();
				}
				break;
			}
			State = 436;
			switch ( Interpreter.AdaptivePredict(_input,60,_ctx) ) {
			case 1:
				{
				State = 435; argumentList();
				}
				break;
			}
			State = 439;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 438; whiteSpace();
				}
			}

			State = 441; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DictionaryAccessExpressionContext : ParserRuleContext {
		public IReadOnlyList<ITerminalNode> LINE_CONTINUATION() { return GetTokens(VBAExpressionParser.LINE_CONTINUATION); }
		public ITerminalNode EXCLAMATIONPOINT() { return GetToken(VBAExpressionParser.EXCLAMATIONPOINT, 0); }
		public ITerminalNode LINE_CONTINUATION(int i) {
			return GetToken(VBAExpressionParser.LINE_CONTINUATION, i);
		}
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public LExpressionContext lExpression() {
			return GetRuleContext<LExpressionContext>(0);
		}
		public DictionaryAccessExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dictionaryAccessExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterDictionaryAccessExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitDictionaryAccessExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDictionaryAccessExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DictionaryAccessExpressionContext dictionaryAccessExpression() {
		DictionaryAccessExpressionContext _localctx = new DictionaryAccessExpressionContext(_ctx, State);
		EnterRule(_localctx, 44, RULE_dictionaryAccessExpression);
		try {
			State = 458;
			switch ( Interpreter.AdaptivePredict(_input,62,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 443; lExpression(0);
				State = 444; Match(EXCLAMATIONPOINT);
				State = 445; unrestrictedName();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 447; lExpression(0);
				State = 448; Match(LINE_CONTINUATION);
				State = 449; Match(EXCLAMATIONPOINT);
				State = 450; unrestrictedName();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 452; lExpression(0);
				State = 453; Match(LINE_CONTINUATION);
				State = 454; Match(EXCLAMATIONPOINT);
				State = 455; Match(LINE_CONTINUATION);
				State = 456; unrestrictedName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentListContext : ParserRuleContext {
		public PositionalOrNamedArgumentListContext positionalOrNamedArgumentList() {
			return GetRuleContext<PositionalOrNamedArgumentListContext>(0);
		}
		public ArgumentListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argumentList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterArgumentList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitArgumentList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgumentList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentListContext argumentList() {
		ArgumentListContext _localctx = new ArgumentListContext(_ctx, State);
		EnterRule(_localctx, 46, RULE_argumentList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 460; positionalOrNamedArgumentList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PositionalOrNamedArgumentListContext : ParserRuleContext {
		public RequiredPositionalArgumentContext requiredPositionalArgument() {
			return GetRuleContext<RequiredPositionalArgumentContext>(0);
		}
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public IReadOnlyList<ITerminalNode> COMMA() { return GetTokens(VBAExpressionParser.COMMA); }
		public IReadOnlyList<PositionalArgumentContext> positionalArgument() {
			return GetRuleContexts<PositionalArgumentContext>();
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public NamedArgumentListContext namedArgumentList() {
			return GetRuleContext<NamedArgumentListContext>(0);
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(VBAExpressionParser.COMMA, i);
		}
		public PositionalArgumentContext positionalArgument(int i) {
			return GetRuleContext<PositionalArgumentContext>(i);
		}
		public PositionalOrNamedArgumentListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_positionalOrNamedArgumentList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterPositionalOrNamedArgumentList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitPositionalOrNamedArgumentList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPositionalOrNamedArgumentList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PositionalOrNamedArgumentListContext positionalOrNamedArgumentList() {
		PositionalOrNamedArgumentListContext _localctx = new PositionalOrNamedArgumentListContext(_ctx, State);
		EnterRule(_localctx, 48, RULE_positionalOrNamedArgumentList);
		int _la;
		try {
			int _alt;
			State = 494;
			switch ( Interpreter.AdaptivePredict(_input,71,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 474;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,66,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 463;
						_la = _input.La(1);
						if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABS) | (1L << ARRAY) | (1L << CBOOL) | (1L << CBYTE) | (1L << CCUR) | (1L << CDATE) | (1L << CDBL) | (1L << CDEC) | (1L << CINT) | (1L << CIRCLE) | (1L << CLNG) | (1L << CLNGLNG) | (1L << CLNGPTR) | (1L << CSNG) | (1L << CSTR) | (1L << CVAR) | (1L << CVERR) | (1L << DEBUG) | (1L << DOEVENTS) | (1L << FIX) | (1L << INPUTB) | (1L << INT) | (1L << LBOUND) | (1L << LEN) | (1L << LENB) | (1L << MIDB) | (1L << MIDBTYPESUFFIX) | (1L << MIDTYPESUFFIX) | (1L << PSET) | (1L << SCALE) | (1L << SGN) | (1L << UBOUND) | (1L << EXCLAMATIONPOINT) | (1L << DOT) | (1L << ADDRESSOF) | (1L << ALIAS) | (1L << ATTRIBUTE) | (1L << BEGIN) | (1L << BINARY) | (1L << BYVAL))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CLASS - 64)) | (1L << (DATABASE - 64)) | (1L << (EMPTY - 64)) | (1L << (ERROR - 64)) | (1L << (FALSE - 64)) | (1L << (INPUT - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (LIB - 128)) | (1L << (ME - 128)) | (1L << (MID - 128)) | (1L << (NEW - 128)) | (1L << (NOT - 128)) | (1L << (NOTHING - 128)) | (1L << (NULL - 128)) | (1L << (ON - 128)) | (1L << (TAB - 128)) | (1L << (TEXT - 128)) | (1L << (TRUE - 128)) | (1L << (TYPEOF - 128)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (VERSION - 195)) | (1L << (LPAREN - 195)) | (1L << (MINUS - 195)) | (1L << (STRINGLITERAL - 195)) | (1L << (OCTLITERAL - 195)) | (1L << (HEXLITERAL - 195)) | (1L << (FLOATLITERAL - 195)) | (1L << (INTEGERLITERAL - 195)) | (1L << (DATELITERAL - 195)) | (1L << (IDENTIFIER - 195)) | (1L << (FOREIGNNAME - 195)) | (1L << (OBJECT - 195)) | (1L << (COLLECTION - 195)))) != 0)) {
							{
							State = 462; positionalArgument();
							}
						}

						State = 466;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 465; whiteSpace();
							}
						}

						State = 468; Match(COMMA);
						State = 470;
						switch ( Interpreter.AdaptivePredict(_input,65,_ctx) ) {
						case 1:
							{
							State = 469; whiteSpace();
							}
							break;
						}
						}
						} 
					}
					State = 476;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,66,_ctx);
				}
				State = 477; requiredPositionalArgument();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 490;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,70,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 479;
						_la = _input.La(1);
						if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABS) | (1L << ARRAY) | (1L << CBOOL) | (1L << CBYTE) | (1L << CCUR) | (1L << CDATE) | (1L << CDBL) | (1L << CDEC) | (1L << CINT) | (1L << CIRCLE) | (1L << CLNG) | (1L << CLNGLNG) | (1L << CLNGPTR) | (1L << CSNG) | (1L << CSTR) | (1L << CVAR) | (1L << CVERR) | (1L << DEBUG) | (1L << DOEVENTS) | (1L << FIX) | (1L << INPUTB) | (1L << INT) | (1L << LBOUND) | (1L << LEN) | (1L << LENB) | (1L << MIDB) | (1L << MIDBTYPESUFFIX) | (1L << MIDTYPESUFFIX) | (1L << PSET) | (1L << SCALE) | (1L << SGN) | (1L << UBOUND) | (1L << EXCLAMATIONPOINT) | (1L << DOT) | (1L << ADDRESSOF) | (1L << ALIAS) | (1L << ATTRIBUTE) | (1L << BEGIN) | (1L << BINARY) | (1L << BYVAL))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CLASS - 64)) | (1L << (DATABASE - 64)) | (1L << (EMPTY - 64)) | (1L << (ERROR - 64)) | (1L << (FALSE - 64)) | (1L << (INPUT - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (LIB - 128)) | (1L << (ME - 128)) | (1L << (MID - 128)) | (1L << (NEW - 128)) | (1L << (NOT - 128)) | (1L << (NOTHING - 128)) | (1L << (NULL - 128)) | (1L << (ON - 128)) | (1L << (TAB - 128)) | (1L << (TEXT - 128)) | (1L << (TRUE - 128)) | (1L << (TYPEOF - 128)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (VERSION - 195)) | (1L << (LPAREN - 195)) | (1L << (MINUS - 195)) | (1L << (STRINGLITERAL - 195)) | (1L << (OCTLITERAL - 195)) | (1L << (HEXLITERAL - 195)) | (1L << (FLOATLITERAL - 195)) | (1L << (INTEGERLITERAL - 195)) | (1L << (DATELITERAL - 195)) | (1L << (IDENTIFIER - 195)) | (1L << (FOREIGNNAME - 195)) | (1L << (OBJECT - 195)) | (1L << (COLLECTION - 195)))) != 0)) {
							{
							State = 478; positionalArgument();
							}
						}

						State = 482;
						_la = _input.La(1);
						if (_la==WS || _la==LINE_CONTINUATION) {
							{
							State = 481; whiteSpace();
							}
						}

						State = 484; Match(COMMA);
						State = 486;
						switch ( Interpreter.AdaptivePredict(_input,69,_ctx) ) {
						case 1:
							{
							State = 485; whiteSpace();
							}
							break;
						}
						}
						} 
					}
					State = 492;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,70,_ctx);
				}
				State = 493; namedArgumentList();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PositionalArgumentContext : ParserRuleContext {
		public ArgumentExpressionContext argumentExpression() {
			return GetRuleContext<ArgumentExpressionContext>(0);
		}
		public PositionalArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_positionalArgument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterPositionalArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitPositionalArgument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPositionalArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PositionalArgumentContext positionalArgument() {
		PositionalArgumentContext _localctx = new PositionalArgumentContext(_ctx, State);
		EnterRule(_localctx, 50, RULE_positionalArgument);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 496; argumentExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RequiredPositionalArgumentContext : ParserRuleContext {
		public ArgumentExpressionContext argumentExpression() {
			return GetRuleContext<ArgumentExpressionContext>(0);
		}
		public RequiredPositionalArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_requiredPositionalArgument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterRequiredPositionalArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitRequiredPositionalArgument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRequiredPositionalArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RequiredPositionalArgumentContext requiredPositionalArgument() {
		RequiredPositionalArgumentContext _localctx = new RequiredPositionalArgumentContext(_ctx, State);
		EnterRule(_localctx, 52, RULE_requiredPositionalArgument);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 498; argumentExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NamedArgumentListContext : ParserRuleContext {
		public IReadOnlyList<NamedArgumentContext> namedArgument() {
			return GetRuleContexts<NamedArgumentContext>();
		}
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public IReadOnlyList<ITerminalNode> COMMA() { return GetTokens(VBAExpressionParser.COMMA); }
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public NamedArgumentContext namedArgument(int i) {
			return GetRuleContext<NamedArgumentContext>(i);
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(VBAExpressionParser.COMMA, i);
		}
		public NamedArgumentListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_namedArgumentList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterNamedArgumentList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitNamedArgumentList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamedArgumentList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NamedArgumentListContext namedArgumentList() {
		NamedArgumentListContext _localctx = new NamedArgumentListContext(_ctx, State);
		EnterRule(_localctx, 54, RULE_namedArgumentList);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 500; namedArgument();
			State = 511;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,74,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 502;
					_la = _input.La(1);
					if (_la==WS || _la==LINE_CONTINUATION) {
						{
						State = 501; whiteSpace();
						}
					}

					State = 504; Match(COMMA);
					State = 506;
					_la = _input.La(1);
					if (_la==WS || _la==LINE_CONTINUATION) {
						{
						State = 505; whiteSpace();
						}
					}

					State = 508; namedArgument();
					}
					} 
				}
				State = 513;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,74,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NamedArgumentContext : ParserRuleContext {
		public ITerminalNode ASSIGN() { return GetToken(VBAExpressionParser.ASSIGN, 0); }
		public WhiteSpaceContext whiteSpace(int i) {
			return GetRuleContext<WhiteSpaceContext>(i);
		}
		public ArgumentExpressionContext argumentExpression() {
			return GetRuleContext<ArgumentExpressionContext>(0);
		}
		public IReadOnlyList<WhiteSpaceContext> whiteSpace() {
			return GetRuleContexts<WhiteSpaceContext>();
		}
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public NamedArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_namedArgument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterNamedArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitNamedArgument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamedArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NamedArgumentContext namedArgument() {
		NamedArgumentContext _localctx = new NamedArgumentContext(_ctx, State);
		EnterRule(_localctx, 56, RULE_namedArgument);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 514; unrestrictedName();
			State = 516;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 515; whiteSpace();
				}
			}

			State = 518; Match(ASSIGN);
			State = 520;
			_la = _input.La(1);
			if (_la==WS || _la==LINE_CONTINUATION) {
				{
				State = 519; whiteSpace();
				}
			}

			State = 522; argumentExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentExpressionContext : ParserRuleContext {
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public AddressOfExpressionContext addressOfExpression() {
			return GetRuleContext<AddressOfExpressionContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode BYVAL() { return GetToken(VBAExpressionParser.BYVAL, 0); }
		public ArgumentExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argumentExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterArgumentExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitArgumentExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgumentExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentExpressionContext argumentExpression() {
		ArgumentExpressionContext _localctx = new ArgumentExpressionContext(_ctx, State);
		EnterRule(_localctx, 58, RULE_argumentExpression);
		int _la;
		try {
			State = 530;
			switch (_input.La(1)) {
			case ABS:
			case ARRAY:
			case CBOOL:
			case CBYTE:
			case CCUR:
			case CDATE:
			case CDBL:
			case CDEC:
			case CINT:
			case CIRCLE:
			case CLNG:
			case CLNGLNG:
			case CLNGPTR:
			case CSNG:
			case CSTR:
			case CVAR:
			case CVERR:
			case DEBUG:
			case DOEVENTS:
			case FIX:
			case INPUTB:
			case INT:
			case LBOUND:
			case LEN:
			case LENB:
			case MIDB:
			case MIDBTYPESUFFIX:
			case MIDTYPESUFFIX:
			case PSET:
			case SCALE:
			case SGN:
			case UBOUND:
			case EXCLAMATIONPOINT:
			case DOT:
			case ALIAS:
			case ATTRIBUTE:
			case BEGIN:
			case BINARY:
			case BYVAL:
			case CLASS:
			case DATABASE:
			case EMPTY:
			case ERROR:
			case FALSE:
			case INPUT:
			case LIB:
			case ME:
			case MID:
			case NEW:
			case NOT:
			case NOTHING:
			case NULL:
			case ON:
			case TAB:
			case TEXT:
			case TRUE:
			case TYPEOF:
			case VERSION:
			case LPAREN:
			case MINUS:
			case STRINGLITERAL:
			case OCTLITERAL:
			case HEXLITERAL:
			case FLOATLITERAL:
			case INTEGERLITERAL:
			case DATELITERAL:
			case IDENTIFIER:
			case FOREIGNNAME:
			case OBJECT:
			case COLLECTION:
				EnterOuterAlt(_localctx, 1);
				{
				State = 526;
				_la = _input.La(1);
				if (_la==BYVAL) {
					{
					State = 524; Match(BYVAL);
					State = 525; whiteSpace();
					}
				}

				State = 528; expression(0);
				}
				break;
			case ADDRESSOF:
				EnterOuterAlt(_localctx, 2);
				{
				State = 529; addressOfExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleNameExpressionContext : ParserRuleContext {
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public SimpleNameExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleNameExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterSimpleNameExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitSimpleNameExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleNameExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SimpleNameExpressionContext simpleNameExpression() {
		SimpleNameExpressionContext _localctx = new SimpleNameExpressionContext(_ctx, State);
		EnterRule(_localctx, 60, RULE_simpleNameExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 532; name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InstanceExpressionContext : ParserRuleContext {
		public ITerminalNode ME() { return GetToken(VBAExpressionParser.ME, 0); }
		public InstanceExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_instanceExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterInstanceExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitInstanceExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInstanceExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InstanceExpressionContext instanceExpression() {
		InstanceExpressionContext _localctx = new InstanceExpressionContext(_ctx, State);
		EnterRule(_localctx, 62, RULE_instanceExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 534; Match(ME);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithExpressionContext : ParserRuleContext {
		public WithDictionaryAccessExpressionContext withDictionaryAccessExpression() {
			return GetRuleContext<WithDictionaryAccessExpressionContext>(0);
		}
		public WithMemberAccessExpressionContext withMemberAccessExpression() {
			return GetRuleContext<WithMemberAccessExpressionContext>(0);
		}
		public WithExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterWithExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitWithExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WithExpressionContext withExpression() {
		WithExpressionContext _localctx = new WithExpressionContext(_ctx, State);
		EnterRule(_localctx, 64, RULE_withExpression);
		try {
			State = 538;
			switch (_input.La(1)) {
			case DOT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 536; withMemberAccessExpression();
				}
				break;
			case EXCLAMATIONPOINT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 537; withDictionaryAccessExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithMemberAccessExpressionContext : ParserRuleContext {
		public ITerminalNode DOT() { return GetToken(VBAExpressionParser.DOT, 0); }
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public WithMemberAccessExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withMemberAccessExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterWithMemberAccessExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitWithMemberAccessExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithMemberAccessExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WithMemberAccessExpressionContext withMemberAccessExpression() {
		WithMemberAccessExpressionContext _localctx = new WithMemberAccessExpressionContext(_ctx, State);
		EnterRule(_localctx, 66, RULE_withMemberAccessExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 540; Match(DOT);
			State = 541; unrestrictedName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithDictionaryAccessExpressionContext : ParserRuleContext {
		public ITerminalNode EXCLAMATIONPOINT() { return GetToken(VBAExpressionParser.EXCLAMATIONPOINT, 0); }
		public UnrestrictedNameContext unrestrictedName() {
			return GetRuleContext<UnrestrictedNameContext>(0);
		}
		public WithDictionaryAccessExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withDictionaryAccessExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterWithDictionaryAccessExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitWithDictionaryAccessExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithDictionaryAccessExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WithDictionaryAccessExpressionContext withDictionaryAccessExpression() {
		WithDictionaryAccessExpressionContext _localctx = new WithDictionaryAccessExpressionContext(_ctx, State);
		EnterRule(_localctx, 68, RULE_withDictionaryAccessExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 543; Match(EXCLAMATIONPOINT);
			State = 544; unrestrictedName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantExpressionContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ConstantExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constantExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterConstantExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitConstantExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstantExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantExpressionContext constantExpression() {
		ConstantExpressionContext _localctx = new ConstantExpressionContext(_ctx, State);
		EnterRule(_localctx, 70, RULE_constantExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 546; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeExpressionContext : ParserRuleContext {
		public DefinedTypeExpressionContext definedTypeExpression() {
			return GetRuleContext<DefinedTypeExpressionContext>(0);
		}
		public BuiltInTypeContext builtInType() {
			return GetRuleContext<BuiltInTypeContext>(0);
		}
		public TypeExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterTypeExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitTypeExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeExpressionContext typeExpression() {
		TypeExpressionContext _localctx = new TypeExpressionContext(_ctx, State);
		EnterRule(_localctx, 72, RULE_typeExpression);
		try {
			State = 550;
			switch ( Interpreter.AdaptivePredict(_input,80,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 548; builtInType();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 549; definedTypeExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DefinedTypeExpressionContext : ParserRuleContext {
		public MemberAccessExpressionContext memberAccessExpression() {
			return GetRuleContext<MemberAccessExpressionContext>(0);
		}
		public SimpleNameExpressionContext simpleNameExpression() {
			return GetRuleContext<SimpleNameExpressionContext>(0);
		}
		public DefinedTypeExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_definedTypeExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterDefinedTypeExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitDefinedTypeExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefinedTypeExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DefinedTypeExpressionContext definedTypeExpression() {
		DefinedTypeExpressionContext _localctx = new DefinedTypeExpressionContext(_ctx, State);
		EnterRule(_localctx, 74, RULE_definedTypeExpression);
		try {
			State = 554;
			switch ( Interpreter.AdaptivePredict(_input,81,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 552; simpleNameExpression();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 553; memberAccessExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AddressOfExpressionContext : ParserRuleContext {
		public ITerminalNode ADDRESSOF() { return GetToken(VBAExpressionParser.ADDRESSOF, 0); }
		public WhiteSpaceContext whiteSpace() {
			return GetRuleContext<WhiteSpaceContext>(0);
		}
		public ProcedurePointerExpressionContext procedurePointerExpression() {
			return GetRuleContext<ProcedurePointerExpressionContext>(0);
		}
		public AddressOfExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_addressOfExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterAddressOfExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitAddressOfExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAddressOfExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AddressOfExpressionContext addressOfExpression() {
		AddressOfExpressionContext _localctx = new AddressOfExpressionContext(_ctx, State);
		EnterRule(_localctx, 76, RULE_addressOfExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 556; Match(ADDRESSOF);
			State = 557; whiteSpace();
			State = 558; procedurePointerExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedurePointerExpressionContext : ParserRuleContext {
		public MemberAccessExpressionContext memberAccessExpression() {
			return GetRuleContext<MemberAccessExpressionContext>(0);
		}
		public SimpleNameExpressionContext simpleNameExpression() {
			return GetRuleContext<SimpleNameExpressionContext>(0);
		}
		public ProcedurePointerExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedurePointerExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterProcedurePointerExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitProcedurePointerExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProcedurePointerExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProcedurePointerExpressionContext procedurePointerExpression() {
		ProcedurePointerExpressionContext _localctx = new ProcedurePointerExpressionContext(_ctx, State);
		EnterRule(_localctx, 78, RULE_procedurePointerExpression);
		try {
			State = 562;
			switch ( Interpreter.AdaptivePredict(_input,82,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 560; memberAccessExpression();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 561; simpleNameExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedIdentifierContext : ParserRuleContext {
		public MarkerKeywordContext markerKeyword() {
			return GetRuleContext<MarkerKeywordContext>(0);
		}
		public SpecialFormContext specialForm() {
			return GetRuleContext<SpecialFormContext>(0);
		}
		public ReservedTypeIdentifierContext reservedTypeIdentifier() {
			return GetRuleContext<ReservedTypeIdentifierContext>(0);
		}
		public OperatorIdentifierContext operatorIdentifier() {
			return GetRuleContext<OperatorIdentifierContext>(0);
		}
		public RemKeywordContext remKeyword() {
			return GetRuleContext<RemKeywordContext>(0);
		}
		public ReservedNameContext reservedName() {
			return GetRuleContext<ReservedNameContext>(0);
		}
		public StatementKeywordContext statementKeyword() {
			return GetRuleContext<StatementKeywordContext>(0);
		}
		public LiteralIdentifierContext literalIdentifier() {
			return GetRuleContext<LiteralIdentifierContext>(0);
		}
		public ReservedIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedIdentifierContext reservedIdentifier() {
		ReservedIdentifierContext _localctx = new ReservedIdentifierContext(_ctx, State);
		EnterRule(_localctx, 80, RULE_reservedIdentifier);
		try {
			State = 572;
			switch ( Interpreter.AdaptivePredict(_input,83,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 564; statementKeyword();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 565; markerKeyword();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 566; operatorIdentifier();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 567; specialForm();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 568; reservedName();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 569; literalIdentifier();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 570; remKeyword();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 571; reservedTypeIdentifier();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementKeywordContext : ParserRuleContext {
		public ITerminalNode CASE() { return GetToken(VBAExpressionParser.CASE, 0); }
		public ITerminalNode DEFOBJ() { return GetToken(VBAExpressionParser.DEFOBJ, 0); }
		public ITerminalNode ELSE() { return GetToken(VBAExpressionParser.ELSE, 0); }
		public ITerminalNode LOCK_WRITE() { return GetToken(VBAExpressionParser.LOCK_WRITE, 0); }
		public ITerminalNode IF() { return GetToken(VBAExpressionParser.IF, 0); }
		public ITerminalNode RESET() { return GetToken(VBAExpressionParser.RESET, 0); }
		public ITerminalNode ERASE() { return GetToken(VBAExpressionParser.ERASE, 0); }
		public ITerminalNode WRITE(int i) {
			return GetToken(VBAExpressionParser.WRITE, i);
		}
		public ITerminalNode END_SELECT() { return GetToken(VBAExpressionParser.END_SELECT, 0); }
		public ITerminalNode ON_ERROR() { return GetToken(VBAExpressionParser.ON_ERROR, 0); }
		public ITerminalNode END_IF() { return GetToken(VBAExpressionParser.END_IF, 0); }
		public ITerminalNode RAISEEVENT() { return GetToken(VBAExpressionParser.RAISEEVENT, 0); }
		public ITerminalNode STOP() { return GetToken(VBAExpressionParser.STOP, 0); }
		public ITerminalNode SHARED() { return GetToken(VBAExpressionParser.SHARED, 0); }
		public ITerminalNode APPEND() { return GetToken(VBAExpressionParser.APPEND, 0); }
		public ITerminalNode PRIVATE() { return GetToken(VBAExpressionParser.PRIVATE, 0); }
		public ITerminalNode DEFBYTE() { return GetToken(VBAExpressionParser.DEFBYTE, 0); }
		public ITerminalNode DEFSNG() { return GetToken(VBAExpressionParser.DEFSNG, 0); }
		public ITerminalNode GOSUB() { return GetToken(VBAExpressionParser.GOSUB, 0); }
		public ITerminalNode RETURN() { return GetToken(VBAExpressionParser.RETURN, 0); }
		public ITerminalNode ENUM() { return GetToken(VBAExpressionParser.ENUM, 0); }
		public ITerminalNode LOCK() { return GetToken(VBAExpressionParser.LOCK, 0); }
		public ITerminalNode GLOBAL() { return GetToken(VBAExpressionParser.GLOBAL, 0); }
		public ITerminalNode WEND() { return GetToken(VBAExpressionParser.WEND, 0); }
		public ITerminalNode DEFSTR() { return GetToken(VBAExpressionParser.DEFSTR, 0); }
		public ITerminalNode DEFLNGLNG() { return GetToken(VBAExpressionParser.DEFLNGLNG, 0); }
		public ITerminalNode DEFVAR() { return GetToken(VBAExpressionParser.DEFVAR, 0); }
		public ITerminalNode EXIT_DO() { return GetToken(VBAExpressionParser.EXIT_DO, 0); }
		public ITerminalNode EVENT() { return GetToken(VBAExpressionParser.EVENT, 0); }
		public ITerminalNode CONST() { return GetToken(VBAExpressionParser.CONST, 0); }
		public ITerminalNode ELSEIF() { return GetToken(VBAExpressionParser.ELSEIF, 0); }
		public ITerminalNode PRINT() { return GetToken(VBAExpressionParser.PRINT, 0); }
		public ITerminalNode DEFINT() { return GetToken(VBAExpressionParser.DEFINT, 0); }
		public ITerminalNode SUB() { return GetToken(VBAExpressionParser.SUB, 0); }
		public ITerminalNode FOR() { return GetToken(VBAExpressionParser.FOR, 0); }
		public ITerminalNode LSET() { return GetToken(VBAExpressionParser.LSET, 0); }
		public ITerminalNode WIDTH() { return GetToken(VBAExpressionParser.WIDTH, 0); }
		public ITerminalNode INPUT() { return GetToken(VBAExpressionParser.INPUT, 0); }
		public ITerminalNode STEP() { return GetToken(VBAExpressionParser.STEP, 0); }
		public ITerminalNode SEEK() { return GetToken(VBAExpressionParser.SEEK, 0); }
		public ITerminalNode BINARY() { return GetToken(VBAExpressionParser.BINARY, 0); }
		public ITerminalNode RANDOM() { return GetToken(VBAExpressionParser.RANDOM, 0); }
		public ITerminalNode LOOP() { return GetToken(VBAExpressionParser.LOOP, 0); }
		public ITerminalNode DEFCUR() { return GetToken(VBAExpressionParser.DEFCUR, 0); }
		public ITerminalNode PUBLIC() { return GetToken(VBAExpressionParser.PUBLIC, 0); }
		public ITerminalNode DEFDATE() { return GetToken(VBAExpressionParser.DEFDATE, 0); }
		public ITerminalNode PUT() { return GetToken(VBAExpressionParser.PUT, 0); }
		public ITerminalNode LET() { return GetToken(VBAExpressionParser.LET, 0); }
		public ITerminalNode FRIEND() { return GetToken(VBAExpressionParser.FRIEND, 0); }
		public ITerminalNode TYPE() { return GetToken(VBAExpressionParser.TYPE, 0); }
		public ITerminalNode ERROR() { return GetToken(VBAExpressionParser.ERROR, 0); }
		public ITerminalNode CALL() { return GetToken(VBAExpressionParser.CALL, 0); }
		public ITerminalNode READ() { return GetToken(VBAExpressionParser.READ, 0); }
		public ITerminalNode DEFBOOL() { return GetToken(VBAExpressionParser.DEFBOOL, 0); }
		public ITerminalNode OPEN() { return GetToken(VBAExpressionParser.OPEN, 0); }
		public ITerminalNode STATIC() { return GetToken(VBAExpressionParser.STATIC, 0); }
		public ITerminalNode LOCK_READ() { return GetToken(VBAExpressionParser.LOCK_READ, 0); }
		public ITerminalNode DO() { return GetToken(VBAExpressionParser.DO, 0); }
		public ITerminalNode DIM() { return GetToken(VBAExpressionParser.DIM, 0); }
		public ITerminalNode OPTION() { return GetToken(VBAExpressionParser.OPTION, 0); }
		public ITerminalNode CLOSE() { return GetToken(VBAExpressionParser.CLOSE, 0); }
		public ITerminalNode OUTPUT() { return GetToken(VBAExpressionParser.OUTPUT, 0); }
		public ITerminalNode LINE_INPUT() { return GetToken(VBAExpressionParser.LINE_INPUT, 0); }
		public ITerminalNode DEFLNG() { return GetToken(VBAExpressionParser.DEFLNG, 0); }
		public ITerminalNode IMPLEMENTS() { return GetToken(VBAExpressionParser.IMPLEMENTS, 0); }
		public ITerminalNode ON() { return GetToken(VBAExpressionParser.ON, 0); }
		public ITerminalNode WITH() { return GetToken(VBAExpressionParser.WITH, 0); }
		public ITerminalNode ACCESS() { return GetToken(VBAExpressionParser.ACCESS, 0); }
		public ITerminalNode EXIT_SUB() { return GetToken(VBAExpressionParser.EXIT_SUB, 0); }
		public ITerminalNode DECLARE() { return GetToken(VBAExpressionParser.DECLARE, 0); }
		public ITerminalNode LOCK_READ_WRITE() { return GetToken(VBAExpressionParser.LOCK_READ_WRITE, 0); }
		public ITerminalNode RESUME() { return GetToken(VBAExpressionParser.RESUME, 0); }
		public IReadOnlyList<ITerminalNode> WRITE() { return GetTokens(VBAExpressionParser.WRITE); }
		public ITerminalNode DEFLNGPTR() { return GetToken(VBAExpressionParser.DEFLNGPTR, 0); }
		public ITerminalNode WHILE() { return GetToken(VBAExpressionParser.WHILE, 0); }
		public ITerminalNode EXIT() { return GetToken(VBAExpressionParser.EXIT, 0); }
		public ITerminalNode GET() { return GetToken(VBAExpressionParser.GET, 0); }
		public ITerminalNode EXIT_FOR() { return GetToken(VBAExpressionParser.EXIT_FOR, 0); }
		public ITerminalNode DEFDBL() { return GetToken(VBAExpressionParser.DEFDBL, 0); }
		public ITerminalNode NEXT() { return GetToken(VBAExpressionParser.NEXT, 0); }
		public ITerminalNode FUNCTION() { return GetToken(VBAExpressionParser.FUNCTION, 0); }
		public ITerminalNode END_WITH() { return GetToken(VBAExpressionParser.END_WITH, 0); }
		public ITerminalNode RSET() { return GetToken(VBAExpressionParser.RSET, 0); }
		public ITerminalNode GOTO() { return GetToken(VBAExpressionParser.GOTO, 0); }
		public ITerminalNode REDIM() { return GetToken(VBAExpressionParser.REDIM, 0); }
		public ITerminalNode EXIT_PROPERTY() { return GetToken(VBAExpressionParser.EXIT_PROPERTY, 0); }
		public ITerminalNode END() { return GetToken(VBAExpressionParser.END, 0); }
		public ITerminalNode SELECT() { return GetToken(VBAExpressionParser.SELECT, 0); }
		public ITerminalNode EXIT_FUNCTION() { return GetToken(VBAExpressionParser.EXIT_FUNCTION, 0); }
		public ITerminalNode READ_WRITE() { return GetToken(VBAExpressionParser.READ_WRITE, 0); }
		public ITerminalNode UNLOCK() { return GetToken(VBAExpressionParser.UNLOCK, 0); }
		public ITerminalNode SET() { return GetToken(VBAExpressionParser.SET, 0); }
		public StatementKeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statementKeyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterStatementKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitStatementKeyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatementKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementKeywordContext statementKeyword() {
		StatementKeywordContext _localctx = new StatementKeywordContext(_ctx, State);
		EnterRule(_localctx, 82, RULE_statementKeyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 574;
			_la = _input.La(1);
			if ( !(((((_la - 22)) & ~0x3f) == 0 && ((1L << (_la - 22)) & ((1L << (EXIT - 22)) | (1L << (OPTION - 22)) | (1L << (ACCESS - 22)) | (1L << (APPEND - 22)) | (1L << (BINARY - 22)) | (1L << (CALL - 22)) | (1L << (CASE - 22)) | (1L << (CLOSE - 22)) | (1L << (CONST - 22)) | (1L << (DECLARE - 22)) | (1L << (DEFBOOL - 22)) | (1L << (DEFBYTE - 22)) | (1L << (DEFDATE - 22)) | (1L << (DEFDBL - 22)) | (1L << (DEFCUR - 22)) | (1L << (DEFINT - 22)) | (1L << (DEFLNG - 22)) | (1L << (DEFLNGLNG - 22)) | (1L << (DEFLNGPTR - 22)) | (1L << (DEFOBJ - 22)) | (1L << (DEFSNG - 22)) | (1L << (DEFSTR - 22)) | (1L << (DEFVAR - 22)) | (1L << (DIM - 22)) | (1L << (DO - 22)))) != 0) || ((((_la - 87)) & ~0x3f) == 0 && ((1L << (_la - 87)) & ((1L << (ELSE - 87)) | (1L << (ELSEIF - 87)) | (1L << (END_IF - 87)) | (1L << (END_SELECT - 87)) | (1L << (END_WITH - 87)) | (1L << (END - 87)) | (1L << (ENUM - 87)) | (1L << (ERASE - 87)) | (1L << (ERROR - 87)) | (1L << (EVENT - 87)) | (1L << (EXIT_DO - 87)) | (1L << (EXIT_FOR - 87)) | (1L << (EXIT_FUNCTION - 87)) | (1L << (EXIT_PROPERTY - 87)) | (1L << (EXIT_SUB - 87)) | (1L << (FRIEND - 87)) | (1L << (FOR - 87)) | (1L << (FUNCTION - 87)) | (1L << (GET - 87)) | (1L << (GLOBAL - 87)) | (1L << (GOSUB - 87)) | (1L << (GOTO - 87)) | (1L << (IF - 87)) | (1L << (IMPLEMENTS - 87)) | (1L << (INPUT - 87)) | (1L << (LOCK - 87)) | (1L << (LOOP - 87)) | (1L << (LET - 87)) | (1L << (LINE_INPUT - 87)) | (1L << (LOCK_READ - 87)) | (1L << (LOCK_WRITE - 87)) | (1L << (LOCK_READ_WRITE - 87)) | (1L << (LSET - 87)) | (1L << (NEXT - 87)) | (1L << (ON - 87)) | (1L << (ON_ERROR - 87)) | (1L << (OPEN - 87)))) != 0) || ((((_la - 153)) & ~0x3f) == 0 && ((1L << (_la - 153)) & ((1L << (OUTPUT - 153)) | (1L << (PRINT - 153)) | (1L << (PRIVATE - 153)) | (1L << (PUBLIC - 153)) | (1L << (PUT - 153)) | (1L << (RANDOM - 153)) | (1L << (RAISEEVENT - 153)) | (1L << (READ - 153)) | (1L << (READ_WRITE - 153)) | (1L << (REDIM - 153)) | (1L << (RESET - 153)) | (1L << (RESUME - 153)) | (1L << (RETURN - 153)) | (1L << (RSET - 153)) | (1L << (SEEK - 153)) | (1L << (SELECT - 153)) | (1L << (SET - 153)) | (1L << (SHARED - 153)) | (1L << (STATIC - 153)) | (1L << (STEP - 153)) | (1L << (STOP - 153)) | (1L << (SUB - 153)) | (1L << (TYPE - 153)) | (1L << (UNLOCK - 153)) | (1L << (WEND - 153)) | (1L << (WHILE - 153)) | (1L << (WIDTH - 153)) | (1L << (WITH - 153)) | (1L << (WRITE - 153)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RemKeywordContext : ParserRuleContext {
		public ITerminalNode REM() { return GetToken(VBAExpressionParser.REM, 0); }
		public RemKeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_remKeyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterRemKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitRemKeyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRemKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RemKeywordContext remKeyword() {
		RemKeywordContext _localctx = new RemKeywordContext(_ctx, State);
		EnterRule(_localctx, 84, RULE_remKeyword);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 576; Match(REM);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MarkerKeywordContext : ParserRuleContext {
		public ITerminalNode CASE() { return GetToken(VBAExpressionParser.CASE, 0); }
		public ITerminalNode ELSE() { return GetToken(VBAExpressionParser.ELSE, 0); }
		public ITerminalNode THEN() { return GetToken(VBAExpressionParser.THEN, 0); }
		public ITerminalNode WRITE() { return GetToken(VBAExpressionParser.WRITE, 0); }
		public ITerminalNode PRESERVE() { return GetToken(VBAExpressionParser.PRESERVE, 0); }
		public ITerminalNode SPC() { return GetToken(VBAExpressionParser.SPC, 0); }
		public ITerminalNode TO() { return GetToken(VBAExpressionParser.TO, 0); }
		public ITerminalNode EACH() { return GetToken(VBAExpressionParser.EACH, 0); }
		public ITerminalNode SHARED() { return GetToken(VBAExpressionParser.SHARED, 0); }
		public ITerminalNode ANY() { return GetToken(VBAExpressionParser.ANY, 0); }
		public ITerminalNode NEW() { return GetToken(VBAExpressionParser.NEW, 0); }
		public ITerminalNode AS() { return GetToken(VBAExpressionParser.AS, 0); }
		public ITerminalNode BYVAL() { return GetToken(VBAExpressionParser.BYVAL, 0); }
		public ITerminalNode IN() { return GetToken(VBAExpressionParser.IN, 0); }
		public ITerminalNode TAB() { return GetToken(VBAExpressionParser.TAB, 0); }
		public ITerminalNode BYREF() { return GetToken(VBAExpressionParser.BYREF, 0); }
		public ITerminalNode OPTIONAL() { return GetToken(VBAExpressionParser.OPTIONAL, 0); }
		public ITerminalNode UNTIL() { return GetToken(VBAExpressionParser.UNTIL, 0); }
		public ITerminalNode PARAMARRAY() { return GetToken(VBAExpressionParser.PARAMARRAY, 0); }
		public ITerminalNode WITHEVENTS() { return GetToken(VBAExpressionParser.WITHEVENTS, 0); }
		public MarkerKeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_markerKeyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterMarkerKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitMarkerKeyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMarkerKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MarkerKeywordContext markerKeyword() {
		MarkerKeywordContext _localctx = new MarkerKeywordContext(_ctx, State);
		EnterRule(_localctx, 86, RULE_markerKeyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 578;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ANY) | (1L << AS) | (1L << BYVAL) | (1L << BYREF) | (1L << CASE))) != 0) || ((((_la - 86)) & ~0x3f) == 0 && ((1L << (_la - 86)) & ((1L << (EACH - 86)) | (1L << (ELSE - 86)) | (1L << (IN - 86)) | (1L << (NEW - 86)) | (1L << (OPTIONAL - 86)))) != 0) || ((((_la - 154)) & ~0x3f) == 0 && ((1L << (_la - 154)) & ((1L << (PARAMARRAY - 154)) | (1L << (PRESERVE - 154)) | (1L << (SHARED - 154)) | (1L << (SPC - 154)) | (1L << (TAB - 154)) | (1L << (THEN - 154)) | (1L << (TO - 154)) | (1L << (UNTIL - 154)) | (1L << (WITHEVENTS - 154)) | (1L << (WRITE - 154)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OperatorIdentifierContext : ParserRuleContext {
		public ITerminalNode NOT() { return GetToken(VBAExpressionParser.NOT, 0); }
		public ITerminalNode IS() { return GetToken(VBAExpressionParser.IS, 0); }
		public ITerminalNode XOR() { return GetToken(VBAExpressionParser.XOR, 0); }
		public ITerminalNode EQV() { return GetToken(VBAExpressionParser.EQV, 0); }
		public ITerminalNode ADDRESSOF() { return GetToken(VBAExpressionParser.ADDRESSOF, 0); }
		public ITerminalNode AND() { return GetToken(VBAExpressionParser.AND, 0); }
		public ITerminalNode TYPEOF() { return GetToken(VBAExpressionParser.TYPEOF, 0); }
		public ITerminalNode LIKE() { return GetToken(VBAExpressionParser.LIKE, 0); }
		public ITerminalNode MOD() { return GetToken(VBAExpressionParser.MOD, 0); }
		public ITerminalNode OR() { return GetToken(VBAExpressionParser.OR, 0); }
		public ITerminalNode IMP() { return GetToken(VBAExpressionParser.IMP, 0); }
		public ITerminalNode NEW() { return GetToken(VBAExpressionParser.NEW, 0); }
		public OperatorIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_operatorIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterOperatorIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitOperatorIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOperatorIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OperatorIdentifierContext operatorIdentifier() {
		OperatorIdentifierContext _localctx = new OperatorIdentifierContext(_ctx, State);
		EnterRule(_localctx, 88, RULE_operatorIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 580;
			_la = _input.La(1);
			if ( !(_la==ADDRESSOF || _la==AND || ((((_la - 100)) & ~0x3f) == 0 && ((1L << (_la - 100)) & ((1L << (EQV - 100)) | (1L << (IMP - 100)) | (1L << (IS - 100)) | (1L << (LIKE - 100)) | (1L << (MOD - 100)) | (1L << (NEW - 100)) | (1L << (NOT - 100)) | (1L << (OR - 100)))) != 0) || _la==TYPEOF || _la==XOR) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedNameContext : ParserRuleContext {
		public ITerminalNode ME() { return GetToken(VBAExpressionParser.ME, 0); }
		public ReservedProcedureNameContext reservedProcedureName() {
			return GetRuleContext<ReservedProcedureNameContext>(0);
		}
		public ReservedNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedNameContext reservedName() {
		ReservedNameContext _localctx = new ReservedNameContext(_ctx, State);
		EnterRule(_localctx, 90, RULE_reservedName);
		try {
			State = 584;
			switch (_input.La(1)) {
			case ME:
				EnterOuterAlt(_localctx, 1);
				{
				State = 582; Match(ME);
				}
				break;
			case ABS:
			case CBOOL:
			case CBYTE:
			case CCUR:
			case CDATE:
			case CDBL:
			case CDEC:
			case CINT:
			case CLNG:
			case CLNGLNG:
			case CLNGPTR:
			case CSNG:
			case CSTR:
			case CVAR:
			case CVERR:
			case DEBUG:
			case DOEVENTS:
			case FIX:
			case INT:
			case LEN:
			case LENB:
			case MIDB:
			case MIDBTYPESUFFIX:
			case MIDTYPESUFFIX:
			case PSET:
			case SCALE:
			case SGN:
			case MID:
				EnterOuterAlt(_localctx, 2);
				{
				State = 583; reservedProcedureName();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedProcedureNameContext : ParserRuleContext {
		public ITerminalNode CSTR() { return GetToken(VBAExpressionParser.CSTR, 0); }
		public ITerminalNode CLNGLNG() { return GetToken(VBAExpressionParser.CLNGLNG, 0); }
		public ITerminalNode CDATE() { return GetToken(VBAExpressionParser.CDATE, 0); }
		public ITerminalNode CINT() { return GetToken(VBAExpressionParser.CINT, 0); }
		public ITerminalNode ABS() { return GetToken(VBAExpressionParser.ABS, 0); }
		public ITerminalNode INT() { return GetToken(VBAExpressionParser.INT, 0); }
		public ITerminalNode LENB() { return GetToken(VBAExpressionParser.LENB, 0); }
		public ITerminalNode SCALE() { return GetToken(VBAExpressionParser.SCALE, 0); }
		public ITerminalNode MIDTYPESUFFIX() { return GetToken(VBAExpressionParser.MIDTYPESUFFIX, 0); }
		public ITerminalNode DEBUG() { return GetToken(VBAExpressionParser.DEBUG, 0); }
		public ITerminalNode CLNGPTR() { return GetToken(VBAExpressionParser.CLNGPTR, 0); }
		public ITerminalNode DOEVENTS() { return GetToken(VBAExpressionParser.DOEVENTS, 0); }
		public ITerminalNode MID() { return GetToken(VBAExpressionParser.MID, 0); }
		public ITerminalNode CDEC() { return GetToken(VBAExpressionParser.CDEC, 0); }
		public ITerminalNode MIDB() { return GetToken(VBAExpressionParser.MIDB, 0); }
		public ITerminalNode CSNG() { return GetToken(VBAExpressionParser.CSNG, 0); }
		public ITerminalNode LEN() { return GetToken(VBAExpressionParser.LEN, 0); }
		public ITerminalNode CCUR() { return GetToken(VBAExpressionParser.CCUR, 0); }
		public ITerminalNode CBOOL() { return GetToken(VBAExpressionParser.CBOOL, 0); }
		public ITerminalNode MIDBTYPESUFFIX() { return GetToken(VBAExpressionParser.MIDBTYPESUFFIX, 0); }
		public ITerminalNode SGN() { return GetToken(VBAExpressionParser.SGN, 0); }
		public ITerminalNode CBYTE() { return GetToken(VBAExpressionParser.CBYTE, 0); }
		public ITerminalNode PSET() { return GetToken(VBAExpressionParser.PSET, 0); }
		public ITerminalNode CVERR() { return GetToken(VBAExpressionParser.CVERR, 0); }
		public ITerminalNode FIX() { return GetToken(VBAExpressionParser.FIX, 0); }
		public ITerminalNode CDBL() { return GetToken(VBAExpressionParser.CDBL, 0); }
		public ITerminalNode CVAR() { return GetToken(VBAExpressionParser.CVAR, 0); }
		public ITerminalNode CLNG() { return GetToken(VBAExpressionParser.CLNG, 0); }
		public ReservedProcedureNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedProcedureName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedProcedureName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedProcedureName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedProcedureName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedProcedureNameContext reservedProcedureName() {
		ReservedProcedureNameContext _localctx = new ReservedProcedureNameContext(_ctx, State);
		EnterRule(_localctx, 92, RULE_reservedProcedureName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 586;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABS) | (1L << CBOOL) | (1L << CBYTE) | (1L << CCUR) | (1L << CDATE) | (1L << CDBL) | (1L << CDEC) | (1L << CINT) | (1L << CLNG) | (1L << CLNGLNG) | (1L << CLNGPTR) | (1L << CSNG) | (1L << CSTR) | (1L << CVAR) | (1L << CVERR) | (1L << DEBUG) | (1L << DOEVENTS) | (1L << FIX) | (1L << INT) | (1L << LEN) | (1L << LENB) | (1L << MIDB) | (1L << MIDBTYPESUFFIX) | (1L << MIDTYPESUFFIX) | (1L << PSET) | (1L << SCALE) | (1L << SGN))) != 0) || _la==MID) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SpecialFormContext : ParserRuleContext {
		public ITerminalNode INPUTB() { return GetToken(VBAExpressionParser.INPUTB, 0); }
		public ITerminalNode SCALE() { return GetToken(VBAExpressionParser.SCALE, 0); }
		public ITerminalNode ARRAY() { return GetToken(VBAExpressionParser.ARRAY, 0); }
		public ITerminalNode LBOUND() { return GetToken(VBAExpressionParser.LBOUND, 0); }
		public ITerminalNode UBOUND() { return GetToken(VBAExpressionParser.UBOUND, 0); }
		public ITerminalNode INPUT() { return GetToken(VBAExpressionParser.INPUT, 0); }
		public ITerminalNode CIRCLE() { return GetToken(VBAExpressionParser.CIRCLE, 0); }
		public SpecialFormContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_specialForm; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterSpecialForm(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitSpecialForm(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSpecialForm(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SpecialFormContext specialForm() {
		SpecialFormContext _localctx = new SpecialFormContext(_ctx, State);
		EnterRule(_localctx, 94, RULE_specialForm);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 588;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ARRAY) | (1L << CIRCLE) | (1L << INPUTB) | (1L << LBOUND) | (1L << SCALE) | (1L << UBOUND))) != 0) || _la==INPUT) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedTypeIdentifierContext : ParserRuleContext {
		public ITerminalNode INTEGER() { return GetToken(VBAExpressionParser.INTEGER, 0); }
		public ITerminalNode LONGLONG() { return GetToken(VBAExpressionParser.LONGLONG, 0); }
		public ITerminalNode LONG() { return GetToken(VBAExpressionParser.LONG, 0); }
		public ITerminalNode VARIANT() { return GetToken(VBAExpressionParser.VARIANT, 0); }
		public ITerminalNode LONGPTR() { return GetToken(VBAExpressionParser.LONGPTR, 0); }
		public ITerminalNode BYTE() { return GetToken(VBAExpressionParser.BYTE, 0); }
		public ITerminalNode STRING() { return GetToken(VBAExpressionParser.STRING, 0); }
		public ITerminalNode BOOLEAN() { return GetToken(VBAExpressionParser.BOOLEAN, 0); }
		public ITerminalNode DATE() { return GetToken(VBAExpressionParser.DATE, 0); }
		public ITerminalNode CURRENCY() { return GetToken(VBAExpressionParser.CURRENCY, 0); }
		public ITerminalNode DOUBLE() { return GetToken(VBAExpressionParser.DOUBLE, 0); }
		public ITerminalNode SINGLE() { return GetToken(VBAExpressionParser.SINGLE, 0); }
		public ReservedTypeIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedTypeIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterReservedTypeIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitReservedTypeIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedTypeIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedTypeIdentifierContext reservedTypeIdentifier() {
		ReservedTypeIdentifierContext _localctx = new ReservedTypeIdentifierContext(_ctx, State);
		EnterRule(_localctx, 96, RULE_reservedTypeIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 590;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << CURRENCY) | (1L << LONGLONG) | (1L << LONGPTR) | (1L << BOOLEAN) | (1L << BYTE))) != 0) || ((((_la - 68)) & ~0x3f) == 0 && ((1L << (_la - 68)) & ((1L << (DATE - 68)) | (1L << (DOUBLE - 68)) | (1L << (INTEGER - 68)) | (1L << (LONG - 68)))) != 0) || ((((_la - 178)) & ~0x3f) == 0 && ((1L << (_la - 178)) & ((1L << (SINGLE - 178)) | (1L << (STRING - 178)) | (1L << (VARIANT - 178)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UncategorizedKeywordContext : ParserRuleContext {
		public ITerminalNode TAB() { return GetToken(VBAExpressionParser.TAB, 0); }
		public ITerminalNode LIB() { return GetToken(VBAExpressionParser.LIB, 0); }
		public ITerminalNode VERSION() { return GetToken(VBAExpressionParser.VERSION, 0); }
		public ITerminalNode ON() { return GetToken(VBAExpressionParser.ON, 0); }
		public ITerminalNode COLLECTION() { return GetToken(VBAExpressionParser.COLLECTION, 0); }
		public ITerminalNode ALIAS() { return GetToken(VBAExpressionParser.ALIAS, 0); }
		public ITerminalNode ATTRIBUTE() { return GetToken(VBAExpressionParser.ATTRIBUTE, 0); }
		public ITerminalNode BEGIN() { return GetToken(VBAExpressionParser.BEGIN, 0); }
		public ITerminalNode CLASS() { return GetToken(VBAExpressionParser.CLASS, 0); }
		public UncategorizedKeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_uncategorizedKeyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterUncategorizedKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitUncategorizedKeyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUncategorizedKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UncategorizedKeywordContext uncategorizedKeyword() {
		UncategorizedKeywordContext _localctx = new UncategorizedKeywordContext(_ctx, State);
		EnterRule(_localctx, 98, RULE_uncategorizedKeyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 592;
			_la = _input.La(1);
			if ( !(((((_la - 51)) & ~0x3f) == 0 && ((1L << (_la - 51)) & ((1L << (ALIAS - 51)) | (1L << (ATTRIBUTE - 51)) | (1L << (BEGIN - 51)) | (1L << (CLASS - 51)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (LIB - 128)) | (1L << (ON - 128)) | (1L << (TAB - 128)))) != 0) || _la==VERSION || _la==COLLECTION) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralIdentifierContext : ParserRuleContext {
		public ObjectLiteralIdentifierContext objectLiteralIdentifier() {
			return GetRuleContext<ObjectLiteralIdentifierContext>(0);
		}
		public BooleanLiteralIdentifierContext booleanLiteralIdentifier() {
			return GetRuleContext<BooleanLiteralIdentifierContext>(0);
		}
		public VariantLiteralIdentifierContext variantLiteralIdentifier() {
			return GetRuleContext<VariantLiteralIdentifierContext>(0);
		}
		public LiteralIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literalIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterLiteralIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitLiteralIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralIdentifierContext literalIdentifier() {
		LiteralIdentifierContext _localctx = new LiteralIdentifierContext(_ctx, State);
		EnterRule(_localctx, 100, RULE_literalIdentifier);
		try {
			State = 597;
			switch (_input.La(1)) {
			case FALSE:
			case TRUE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 594; booleanLiteralIdentifier();
				}
				break;
			case NOTHING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 595; objectLiteralIdentifier();
				}
				break;
			case EMPTY:
			case NULL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 596; variantLiteralIdentifier();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BooleanLiteralIdentifierContext : ParserRuleContext {
		public ITerminalNode FALSE() { return GetToken(VBAExpressionParser.FALSE, 0); }
		public ITerminalNode TRUE() { return GetToken(VBAExpressionParser.TRUE, 0); }
		public BooleanLiteralIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_booleanLiteralIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterBooleanLiteralIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitBooleanLiteralIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBooleanLiteralIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BooleanLiteralIdentifierContext booleanLiteralIdentifier() {
		BooleanLiteralIdentifierContext _localctx = new BooleanLiteralIdentifierContext(_ctx, State);
		EnterRule(_localctx, 102, RULE_booleanLiteralIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 599;
			_la = _input.La(1);
			if ( !(_la==FALSE || _la==TRUE) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectLiteralIdentifierContext : ParserRuleContext {
		public ITerminalNode NOTHING() { return GetToken(VBAExpressionParser.NOTHING, 0); }
		public ObjectLiteralIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectLiteralIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterObjectLiteralIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitObjectLiteralIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObjectLiteralIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ObjectLiteralIdentifierContext objectLiteralIdentifier() {
		ObjectLiteralIdentifierContext _localctx = new ObjectLiteralIdentifierContext(_ctx, State);
		EnterRule(_localctx, 104, RULE_objectLiteralIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 601; Match(NOTHING);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariantLiteralIdentifierContext : ParserRuleContext {
		public ITerminalNode NULL() { return GetToken(VBAExpressionParser.NULL, 0); }
		public ITerminalNode EMPTY() { return GetToken(VBAExpressionParser.EMPTY, 0); }
		public VariantLiteralIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variantLiteralIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterVariantLiteralIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitVariantLiteralIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariantLiteralIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariantLiteralIdentifierContext variantLiteralIdentifier() {
		VariantLiteralIdentifierContext _localctx = new VariantLiteralIdentifierContext(_ctx, State);
		EnterRule(_localctx, 106, RULE_variantLiteralIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 603;
			_la = _input.La(1);
			if ( !(_la==EMPTY || _la==NULL) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhiteSpaceContext : ParserRuleContext {
		public ITerminalNode WS(int i) {
			return GetToken(VBAExpressionParser.WS, i);
		}
		public IReadOnlyList<ITerminalNode> WS() { return GetTokens(VBAExpressionParser.WS); }
		public IReadOnlyList<ITerminalNode> LINE_CONTINUATION() { return GetTokens(VBAExpressionParser.LINE_CONTINUATION); }
		public ITerminalNode LINE_CONTINUATION(int i) {
			return GetToken(VBAExpressionParser.LINE_CONTINUATION, i);
		}
		public WhiteSpaceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whiteSpace; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.EnterWhiteSpace(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAExpressionParserListener typedListener = listener as IVBAExpressionParserListener;
			if (typedListener != null) typedListener.ExitWhiteSpace(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAExpressionParserVisitor<TResult> typedVisitor = visitor as IVBAExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhiteSpace(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhiteSpaceContext whiteSpace() {
		WhiteSpaceContext _localctx = new WhiteSpaceContext(_ctx, State);
		EnterRule(_localctx, 108, RULE_whiteSpace);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 606;
			_errHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 605;
					_la = _input.La(1);
					if ( !(_la==WS || _la==LINE_CONTINUATION) ) {
					_errHandler.RecoverInline(this);
					}
					Consume();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 608;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,86,_ctx);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 13: return expression_sempred((ExpressionContext)_localctx, predIndex);

		case 19: return lExpression_sempred((LExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(_ctx, 15);

		case 1: return Precpred(_ctx, 13);

		case 2: return Precpred(_ctx, 12);

		case 3: return Precpred(_ctx, 11);

		case 4: return Precpred(_ctx, 10);

		case 5: return Precpred(_ctx, 9);

		case 6: return Precpred(_ctx, 8);

		case 7: return Precpred(_ctx, 6);

		case 8: return Precpred(_ctx, 5);

		case 9: return Precpred(_ctx, 4);

		case 10: return Precpred(_ctx, 3);

		case 11: return Precpred(_ctx, 2);
		}
		return true;
	}
	private bool lExpression_sempred(LExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 16: return Precpred(_ctx, 5);

		case 17: return Precpred(_ctx, 4);

		case 12: return Precpred(_ctx, 9);

		case 13: return Precpred(_ctx, 8);

		case 14: return Precpred(_ctx, 7);

		case 15: return Precpred(_ctx, 6);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\xF3\x265\x4\x2"+
		"\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4"+
		"\t\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10"+
		"\t\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x4\x16\t\x16\x4\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B"+
		"\t\x1B\x4\x1C\t\x1C\x4\x1D\t\x1D\x4\x1E\t\x1E\x4\x1F\t\x1F\x4 \t \x4!"+
		"\t!\x4\"\t\"\x4#\t#\x4$\t$\x4%\t%\x4&\t&\x4\'\t\'\x4(\t(\x4)\t)\x4*\t"+
		"*\x4+\t+\x4,\t,\x4-\t-\x4.\t.\x4/\t/\x4\x30\t\x30\x4\x31\t\x31\x4\x32"+
		"\t\x32\x4\x33\t\x33\x4\x34\t\x34\x4\x35\t\x35\x4\x36\t\x36\x4\x37\t\x37"+
		"\x4\x38\t\x38\x3\x2\x3\x2\x5\x2s\n\x2\x3\x2\x3\x2\x3\x3\x3\x3\x3\x3\x5"+
		"\x3z\n\x3\x3\x3\x3\x3\x3\x3\x5\x3\x7F\n\x3\x3\x4\x3\x4\x5\x4\x83\n\x4"+
		"\x3\x5\x3\x5\x5\x5\x87\n\x5\x3\x6\x3\x6\x5\x6\x8B\n\x6\x3\a\x3\a\x3\b"+
		"\x3\b\x3\b\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x5\t\x9A\n\t\x3\n\x3"+
		"\n\x3\n\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x5\v\xA6\n\v\x3\f\x3\f\x3\r"+
		"\x3\r\x3\xE\x3\xE\x3\xE\x5\xE\xAF\n\xE\x3\xE\x3\xE\x5\xE\xB3\n\xE\x3\xE"+
		"\x3\xE\x3\xE\x3\xE\x3\xE\x5\xE\xBA\n\xE\x3\xE\x3\xE\x5\xE\xBE\n\xE\x3"+
		"\xE\x5\xE\xC1\n\xE\x3\xF\x3\xF\x3\xF\x5\xF\xC6\n\xF\x3\xF\x3\xF\x3\xF"+
		"\x5\xF\xCB\n\xF\x3\xF\x3\xF\x3\xF\x3\xF\x5\xF\xD1\n\xF\x3\xF\x3\xF\x5"+
		"\xF\xD5\n\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x5\xF\xDC\n\xF\x3\xF\x3\xF"+
		"\x5\xF\xE0\n\xF\x3\xF\x3\xF\x5\xF\xE4\n\xF\x3\xF\x3\xF\x3\xF\x5\xF\xE9"+
		"\n\xF\x3\xF\x3\xF\x5\xF\xED\n\xF\x3\xF\x3\xF\x3\xF\x5\xF\xF2\n\xF\x3\xF"+
		"\x3\xF\x5\xF\xF6\n\xF\x3\xF\x3\xF\x3\xF\x5\xF\xFB\n\xF\x3\xF\x3\xF\x5"+
		"\xF\xFF\n\xF\x3\xF\x3\xF\x3\xF\x5\xF\x104\n\xF\x3\xF\x3\xF\x5\xF\x108"+
		"\n\xF\x3\xF\x3\xF\x3\xF\x5\xF\x10D\n\xF\x3\xF\x3\xF\x5\xF\x111\n\xF\x3"+
		"\xF\x3\xF\x3\xF\x5\xF\x116\n\xF\x3\xF\x3\xF\x5\xF\x11A\n\xF\x3\xF\x3\xF"+
		"\x3\xF\x5\xF\x11F\n\xF\x3\xF\x3\xF\x5\xF\x123\n\xF\x3\xF\x3\xF\x3\xF\x5"+
		"\xF\x128\n\xF\x3\xF\x3\xF\x5\xF\x12C\n\xF\x3\xF\x3\xF\x3\xF\x5\xF\x131"+
		"\n\xF\x3\xF\x3\xF\x5\xF\x135\n\xF\x3\xF\x3\xF\x3\xF\x5\xF\x13A\n\xF\x3"+
		"\xF\x3\xF\x5\xF\x13E\n\xF\x3\xF\x3\xF\x3\xF\x5\xF\x143\n\xF\x3\xF\x3\xF"+
		"\x5\xF\x147\n\xF\x3\xF\a\xF\x14A\n\xF\f\xF\xE\xF\x14D\v\xF\x3\x10\x3\x10"+
		"\x3\x10\x3\x10\x3\x10\x5\x10\x154\n\x10\x5\x10\x156\n\x10\x3\x11\x3\x11"+
		"\x3\x12\x3\x12\x5\x12\x15C\n\x12\x3\x12\x3\x12\x5\x12\x160\n\x12\x3\x12"+
		"\x3\x12\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x14"+
		"\x3\x14\x3\x14\x3\x14\x3\x15\x3\x15\x3\x15\x3\x15\x5\x15\x174\n\x15\x3"+
		"\x15\x3\x15\x5\x15\x178\n\x15\x3\x15\x3\x15\x5\x15\x17C\n\x15\x3\x15\x5"+
		"\x15\x17F\n\x15\x3\x15\x5\x15\x182\n\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3"+
		"\x15\x3\x15\x3\x15\x5\x15\x18B\n\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15"+
		"\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\a\x15"+
		"\x19B\n\x15\f\x15\xE\x15\x19E\v\x15\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16"+
		"\x3\x16\x3\x16\x5\x16\x1A7\n\x16\x3\x16\x3\x16\x3\x16\x5\x16\x1AC\n\x16"+
		"\x3\x17\x3\x17\x5\x17\x1B0\n\x17\x3\x17\x3\x17\x5\x17\x1B4\n\x17\x3\x17"+
		"\x5\x17\x1B7\n\x17\x3\x17\x5\x17\x1BA\n\x17\x3\x17\x3\x17\x3\x18\x3\x18"+
		"\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18"+
		"\x3\x18\x3\x18\x3\x18\x5\x18\x1CD\n\x18\x3\x19\x3\x19\x3\x1A\x5\x1A\x1D2"+
		"\n\x1A\x3\x1A\x5\x1A\x1D5\n\x1A\x3\x1A\x3\x1A\x5\x1A\x1D9\n\x1A\a\x1A"+
		"\x1DB\n\x1A\f\x1A\xE\x1A\x1DE\v\x1A\x3\x1A\x3\x1A\x5\x1A\x1E2\n\x1A\x3"+
		"\x1A\x5\x1A\x1E5\n\x1A\x3\x1A\x3\x1A\x5\x1A\x1E9\n\x1A\a\x1A\x1EB\n\x1A"+
		"\f\x1A\xE\x1A\x1EE\v\x1A\x3\x1A\x5\x1A\x1F1\n\x1A\x3\x1B\x3\x1B\x3\x1C"+
		"\x3\x1C\x3\x1D\x3\x1D\x5\x1D\x1F9\n\x1D\x3\x1D\x3\x1D\x5\x1D\x1FD\n\x1D"+
		"\x3\x1D\a\x1D\x200\n\x1D\f\x1D\xE\x1D\x203\v\x1D\x3\x1E\x3\x1E\x5\x1E"+
		"\x207\n\x1E\x3\x1E\x3\x1E\x5\x1E\x20B\n\x1E\x3\x1E\x3\x1E\x3\x1F\x3\x1F"+
		"\x5\x1F\x211\n\x1F\x3\x1F\x3\x1F\x5\x1F\x215\n\x1F\x3 \x3 \x3!\x3!\x3"+
		"\"\x3\"\x5\"\x21D\n\"\x3#\x3#\x3#\x3$\x3$\x3$\x3%\x3%\x3&\x3&\x5&\x229"+
		"\n&\x3\'\x3\'\x5\'\x22D\n\'\x3(\x3(\x3(\x3(\x3)\x3)\x5)\x235\n)\x3*\x3"+
		"*\x3*\x3*\x3*\x3*\x3*\x3*\x5*\x23F\n*\x3+\x3+\x3,\x3,\x3-\x3-\x3.\x3."+
		"\x3/\x3/\x5/\x24B\n/\x3\x30\x3\x30\x3\x31\x3\x31\x3\x32\x3\x32\x3\x33"+
		"\x3\x33\x3\x34\x3\x34\x3\x34\x5\x34\x258\n\x34\x3\x35\x3\x35\x3\x36\x3"+
		"\x36\x3\x37\x3\x37\x3\x38\x6\x38\x261\n\x38\r\x38\xE\x38\x262\x3\x38\x2"+
		"\x2\x4\x1C(\x39\x2\x2\x4\x2\x6\x2\b\x2\n\x2\f\x2\xE\x2\x10\x2\x12\x2\x14"+
		"\x2\x16\x2\x18\x2\x1A\x2\x1C\x2\x1E\x2 \x2\"\x2$\x2&\x2(\x2*\x2,\x2.\x2"+
		"\x30\x2\x32\x2\x34\x2\x36\x2\x38\x2:\x2<\x2>\x2@\x2\x42\x2\x44\x2\x46"+
		"\x2H\x2J\x2L\x2N\x2P\x2R\x2T\x2V\x2X\x2Z\x2\\\x2^\x2`\x2\x62\x2\x64\x2"+
		"\x66\x2h\x2j\x2l\x2n\x2\x2\x12\x5\x2,,.\x32\xDA\xDA\x5\x2;;\x45\x45\xBC"+
		"\xBC\x4\x2\xCE\xCE\xD7\xD7\x4\x2\xD6\xD6\xD9\xD9\a\x2||\x83\x83\xD0\xD3"+
		"\xD5\xD5\xD8\xD8\x3\x2\xE4\xE7\"\x2\x18\x18$$\x33\x33\x38\x38;;@\x41\x43"+
		"\x44GVYZ^^``\x63\x65gnpwyy{{~~\x80\x81\x84\x88\x8C\x8C\x91\x92\x94\x94"+
		"\x9B\x9B\x9E\x9F\xA4\xAA\xAC\xB3\xB6\xB8\xBA\xBA\xC0\xC0\xC2\xC2\xC6\xC9"+
		"\xCB\xCB\x11\x2\x4\x4\x39\x39=>\x41\x41XYzz\x8D\x8D\x95\x95\x9C\x9D\xB3"+
		"\xB3\xB5\xB5\xBB\xBB\xBD\xBE\xC3\xC3\xCA\xCB\r\x2\x34\x34\x36\x36\x66"+
		"\x66xx||\x83\x83\x8B\x8B\x8D\x8E\x9A\x9A\xC1\xC1\xCC\xCC\f\x2\x3\x3\x6"+
		"\f\xE\x12\x14\x17\x19\x19\x1B\x1B\x1D\x1E!#%\'\x8A\x8A\t\x2\x5\x5\r\r"+
		"\x1A\x1A\x1C\x1C&&(({{\r\x2\x13\x13\x1F <<??\x46\x46WW}}\x7F\x7F\xB4\xB4"+
		"\xB9\xB9\xC4\xC4\v\x2\x35\x35\x37\x37::\x42\x42\x82\x82\x91\x91\xBB\xBB"+
		"\xC5\xC5\xF3\xF3\x4\x2oo\xBF\xBF\x4\x2[[\x90\x90\x4\x2\xEC\xEC\xEE\xEE"+
		"\x2B0\x2r\x3\x2\x2\x2\x4y\x3\x2\x2\x2\x6\x82\x3\x2\x2\x2\b\x86\x3\x2\x2"+
		"\x2\n\x8A\x3\x2\x2\x2\f\x8C\x3\x2\x2\x2\xE\x8E\x3\x2\x2\x2\x10\x99\x3"+
		"\x2\x2\x2\x12\x9B\x3\x2\x2\x2\x14\xA5\x3\x2\x2\x2\x16\xA7\x3\x2\x2\x2"+
		"\x18\xA9\x3\x2\x2\x2\x1A\xC0\x3\x2\x2\x2\x1C\xDB\x3\x2\x2\x2\x1E\x155"+
		"\x3\x2\x2\x2 \x157\x3\x2\x2\x2\"\x159\x3\x2\x2\x2$\x163\x3\x2\x2\x2&\x16B"+
		"\x3\x2\x2\x2(\x173\x3\x2\x2\x2*\x1AB\x3\x2\x2\x2,\x1AD\x3\x2\x2\x2.\x1CC"+
		"\x3\x2\x2\x2\x30\x1CE\x3\x2\x2\x2\x32\x1F0\x3\x2\x2\x2\x34\x1F2\x3\x2"+
		"\x2\x2\x36\x1F4\x3\x2\x2\x2\x38\x1F6\x3\x2\x2\x2:\x204\x3\x2\x2\x2<\x214"+
		"\x3\x2\x2\x2>\x216\x3\x2\x2\x2@\x218\x3\x2\x2\x2\x42\x21C\x3\x2\x2\x2"+
		"\x44\x21E\x3\x2\x2\x2\x46\x221\x3\x2\x2\x2H\x224\x3\x2\x2\x2J\x228\x3"+
		"\x2\x2\x2L\x22C\x3\x2\x2\x2N\x22E\x3\x2\x2\x2P\x234\x3\x2\x2\x2R\x23E"+
		"\x3\x2\x2\x2T\x240\x3\x2\x2\x2V\x242\x3\x2\x2\x2X\x244\x3\x2\x2\x2Z\x246"+
		"\x3\x2\x2\x2\\\x24A\x3\x2\x2\x2^\x24C\x3\x2\x2\x2`\x24E\x3\x2\x2\x2\x62"+
		"\x250\x3\x2\x2\x2\x64\x252\x3\x2\x2\x2\x66\x257\x3\x2\x2\x2h\x259\x3\x2"+
		"\x2\x2j\x25B\x3\x2\x2\x2l\x25D\x3\x2\x2\x2n\x260\x3\x2\x2\x2ps\x5\x1C"+
		"\xF\x2qs\x5\x4\x3\x2rp\x3\x2\x2\x2rq\x3\x2\x2\x2st\x3\x2\x2\x2tu\a\x2"+
		"\x2\x3u\x3\x3\x2\x2\x2vz\x5*\x16\x2wz\x5> \x2xz\x5\x42\"\x2yv\x3\x2\x2"+
		"\x2yw\x3\x2\x2\x2yx\x3\x2\x2\x2z~\x3\x2\x2\x2{|\x5n\x38\x2|}\x5\x30\x19"+
		"\x2}\x7F\x3\x2\x2\x2~{\x3\x2\x2\x2~\x7F\x3\x2\x2\x2\x7F\x5\x3\x2\x2\x2"+
		"\x80\x83\x5\b\x5\x2\x81\x83\x5\n\x6\x2\x82\x80\x3\x2\x2\x2\x82\x81\x3"+
		"\x2\x2\x2\x83\a\x3\x2\x2\x2\x84\x87\x5\x10\t\x2\x85\x87\x5\x12\n\x2\x86"+
		"\x84\x3\x2\x2\x2\x86\x85\x3\x2\x2\x2\x87\t\x3\x2\x2\x2\x88\x8B\x5\f\a"+
		"\x2\x89\x8B\x5\xE\b\x2\x8A\x88\x3\x2\x2\x2\x8A\x89\x3\x2\x2\x2\x8B\v\x3"+
		"\x2\x2\x2\x8C\x8D\x5R*\x2\x8D\r\x3\x2\x2\x2\x8E\x8F\x5R*\x2\x8F\x90\x5"+
		"\x16\f\x2\x90\xF\x3\x2\x2\x2\x91\x9A\a\xED\x2\x2\x92\x9A\a\xF1\x2\x2\x93"+
		"\x9A\x5^\x30\x2\x94\x9A\x5`\x31\x2\x95\x9A\x5\x18\r\x2\x96\x9A\a\xF2\x2"+
		"\x2\x97\x9A\x5\x64\x33\x2\x98\x9A\ah\x2\x2\x99\x91\x3\x2\x2\x2\x99\x92"+
		"\x3\x2\x2\x2\x99\x93\x3\x2\x2\x2\x99\x94\x3\x2\x2\x2\x99\x95\x3\x2\x2"+
		"\x2\x99\x96\x3\x2\x2\x2\x99\x97\x3\x2\x2\x2\x99\x98\x3\x2\x2\x2\x9A\x11"+
		"\x3\x2\x2\x2\x9B\x9C\x5\x14\v\x2\x9C\x9D\x5\x16\f\x2\x9D\x13\x3\x2\x2"+
		"\x2\x9E\xA6\a\xED\x2\x2\x9F\xA6\x5^\x30\x2\xA0\xA6\x5`\x31\x2\xA1\xA6"+
		"\x5\x18\r\x2\xA2\xA6\a\xF2\x2\x2\xA3\xA6\x5\x64\x33\x2\xA4\xA6\ah\x2\x2"+
		"\xA5\x9E\x3\x2\x2\x2\xA5\x9F\x3\x2\x2\x2\xA5\xA0\x3\x2\x2\x2\xA5\xA1\x3"+
		"\x2\x2\x2\xA5\xA2\x3\x2\x2\x2\xA5\xA3\x3\x2\x2\x2\xA5\xA4\x3\x2\x2\x2"+
		"\xA6\x15\x3\x2\x2\x2\xA7\xA8\t\x2\x2\x2\xA8\x17\x3\x2\x2\x2\xA9\xAA\t"+
		"\x3\x2\x2\xAA\x19\x3\x2\x2\x2\xAB\xC1\x5\x62\x32\x2\xAC\xAE\a\xE1\x2\x2"+
		"\xAD\xAF\x5n\x38\x2\xAE\xAD\x3\x2\x2\x2\xAE\xAF\x3\x2\x2\x2\xAF\xB0\x3"+
		"\x2\x2\x2\xB0\xB2\x5\x62\x32\x2\xB1\xB3\x5n\x38\x2\xB2\xB1\x3\x2\x2\x2"+
		"\xB2\xB3\x3\x2\x2\x2\xB3\xB4\x3\x2\x2\x2\xB4\xB5\a\xE2\x2\x2\xB5\xC1\x3"+
		"\x2\x2\x2\xB6\xC1\a\xF2\x2\x2\xB7\xB9\a\xE1\x2\x2\xB8\xBA\x5n\x38\x2\xB9"+
		"\xB8\x3\x2\x2\x2\xB9\xBA\x3\x2\x2\x2\xBA\xBB\x3\x2\x2\x2\xBB\xBD\a\xF2"+
		"\x2\x2\xBC\xBE\x5n\x38\x2\xBD\xBC\x3\x2\x2\x2\xBD\xBE\x3\x2\x2\x2\xBE"+
		"\xBF\x3\x2\x2\x2\xBF\xC1\a\xE2\x2\x2\xC0\xAB\x3\x2\x2\x2\xC0\xAC\x3\x2"+
		"\x2\x2\xC0\xB6\x3\x2\x2\x2\xC0\xB7\x3\x2\x2\x2\xC1\x1B\x3\x2\x2\x2\xC2"+
		"\xC3\b\xF\x1\x2\xC3\xC5\a\xD6\x2\x2\xC4\xC6\x5n\x38\x2\xC5\xC4\x3\x2\x2"+
		"\x2\xC5\xC6\x3\x2\x2\x2\xC6\xC7\x3\x2\x2\x2\xC7\xDC\x5\x1C\xF\x10\xC8"+
		"\xCA\a\x8E\x2\x2\xC9\xCB\x5n\x38\x2\xCA\xC9\x3\x2\x2\x2\xCA\xCB\x3\x2"+
		"\x2\x2\xCB\xCC\x3\x2\x2\x2\xCC\xDC\x5\x1C\xF\t\xCD\xDC\x5(\x15\x2\xCE"+
		"\xD0\a\xD4\x2\x2\xCF\xD1\x5n\x38\x2\xD0\xCF\x3\x2\x2\x2\xD0\xD1\x3\x2"+
		"\x2\x2\xD1\xD2\x3\x2\x2\x2\xD2\xD4\x5\x1C\xF\x2\xD3\xD5\x5n\x38\x2\xD4"+
		"\xD3\x3\x2\x2\x2\xD4\xD5\x3\x2\x2\x2\xD5\xD6\x3\x2\x2\x2\xD6\xD7\a\xDB"+
		"\x2\x2\xD7\xDC\x3\x2\x2\x2\xD8\xDC\x5$\x13\x2\xD9\xDC\x5&\x14\x2\xDA\xDC"+
		"\x5\x1E\x10\x2\xDB\xC2\x3\x2\x2\x2\xDB\xC8\x3\x2\x2\x2\xDB\xCD\x3\x2\x2"+
		"\x2\xDB\xCE\x3\x2\x2\x2\xDB\xD8\x3\x2\x2\x2\xDB\xD9\x3\x2\x2\x2\xDB\xDA"+
		"\x3\x2\x2\x2\xDC\x14B\x3\x2\x2\x2\xDD\xDF\f\x11\x2\x2\xDE\xE0\x5n\x38"+
		"\x2\xDF\xDE\x3\x2\x2\x2\xDF\xE0\x3\x2\x2\x2\xE0\xE1\x3\x2\x2\x2\xE1\xE3"+
		"\a\xDA\x2\x2\xE2\xE4\x5n\x38\x2\xE3\xE2\x3\x2\x2\x2\xE3\xE4\x3\x2\x2\x2"+
		"\xE4\xE5\x3\x2\x2\x2\xE5\x14A\x5\x1C\xF\x12\xE6\xE8\f\xF\x2\x2\xE7\xE9"+
		"\x5n\x38\x2\xE8\xE7\x3\x2\x2\x2\xE8\xE9\x3\x2\x2\x2\xE9\xEA\x3\x2\x2\x2"+
		"\xEA\xEC\t\x4\x2\x2\xEB\xED\x5n\x38\x2\xEC\xEB\x3\x2\x2\x2\xEC\xED\x3"+
		"\x2\x2\x2\xED\xEE\x3\x2\x2\x2\xEE\x14A\x5\x1C\xF\x10\xEF\xF1\f\xE\x2\x2"+
		"\xF0\xF2\x5n\x38\x2\xF1\xF0\x3\x2\x2\x2\xF1\xF2\x3\x2\x2\x2\xF2\xF3\x3"+
		"\x2\x2\x2\xF3\xF5\a\xCF\x2\x2\xF4\xF6\x5n\x38\x2\xF5\xF4\x3\x2\x2\x2\xF5"+
		"\xF6\x3\x2\x2\x2\xF6\xF7\x3\x2\x2\x2\xF7\x14A\x5\x1C\xF\xF\xF8\xFA\f\r"+
		"\x2\x2\xF9\xFB\x5n\x38\x2\xFA\xF9\x3\x2\x2\x2\xFA\xFB\x3\x2\x2\x2\xFB"+
		"\xFC\x3\x2\x2\x2\xFC\xFE\a\x8B\x2\x2\xFD\xFF\x5n\x38\x2\xFE\xFD\x3\x2"+
		"\x2\x2\xFE\xFF\x3\x2\x2\x2\xFF\x100\x3\x2\x2\x2\x100\x14A\x5\x1C\xF\xE"+
		"\x101\x103\f\f\x2\x2\x102\x104\x5n\x38\x2\x103\x102\x3\x2\x2\x2\x103\x104"+
		"\x3\x2\x2\x2\x104\x105\x3\x2\x2\x2\x105\x107\t\x5\x2\x2\x106\x108\x5n"+
		"\x38\x2\x107\x106\x3\x2\x2\x2\x107\x108\x3\x2\x2\x2\x108\x109\x3\x2\x2"+
		"\x2\x109\x14A\x5\x1C\xF\r\x10A\x10C\f\v\x2\x2\x10B\x10D\x5n\x38\x2\x10C"+
		"\x10B\x3\x2\x2\x2\x10C\x10D\x3\x2\x2\x2\x10D\x10E\x3\x2\x2\x2\x10E\x110"+
		"\a\x32\x2\x2\x10F\x111\x5n\x38\x2\x110\x10F\x3\x2\x2\x2\x110\x111\x3\x2"+
		"\x2\x2\x111\x112\x3\x2\x2\x2\x112\x14A\x5\x1C\xF\f\x113\x115\f\n\x2\x2"+
		"\x114\x116\x5n\x38\x2\x115\x114\x3\x2\x2\x2\x115\x116\x3\x2\x2\x2\x116"+
		"\x117\x3\x2\x2\x2\x117\x119\t\x6\x2\x2\x118\x11A\x5n\x38\x2\x119\x118"+
		"\x3\x2\x2\x2\x119\x11A\x3\x2\x2\x2\x11A\x11B\x3\x2\x2\x2\x11B\x14A\x5"+
		"\x1C\xF\v\x11C\x11E\f\b\x2\x2\x11D\x11F\x5n\x38\x2\x11E\x11D\x3\x2\x2"+
		"\x2\x11E\x11F\x3\x2\x2\x2\x11F\x120\x3\x2\x2\x2\x120\x122\a\x36\x2\x2"+
		"\x121\x123\x5n\x38\x2\x122\x121\x3\x2\x2\x2\x122\x123\x3\x2\x2\x2\x123"+
		"\x124\x3\x2\x2\x2\x124\x14A\x5\x1C\xF\t\x125\x127\f\a\x2\x2\x126\x128"+
		"\x5n\x38\x2\x127\x126\x3\x2\x2\x2\x127\x128\x3\x2\x2\x2\x128\x129\x3\x2"+
		"\x2\x2\x129\x12B\a\x9A\x2\x2\x12A\x12C\x5n\x38\x2\x12B\x12A\x3\x2\x2\x2"+
		"\x12B\x12C\x3\x2\x2\x2\x12C\x12D\x3\x2\x2\x2\x12D\x14A\x5\x1C\xF\b\x12E"+
		"\x130\f\x6\x2\x2\x12F\x131\x5n\x38\x2\x130\x12F\x3\x2\x2\x2\x130\x131"+
		"\x3\x2\x2\x2\x131\x132\x3\x2\x2\x2\x132\x134\a\xCC\x2\x2\x133\x135\x5"+
		"n\x38\x2\x134\x133\x3\x2\x2\x2\x134\x135\x3\x2\x2\x2\x135\x136\x3\x2\x2"+
		"\x2\x136\x14A\x5\x1C\xF\a\x137\x139\f\x5\x2\x2\x138\x13A\x5n\x38\x2\x139"+
		"\x138\x3\x2\x2\x2\x139\x13A\x3\x2\x2\x2\x13A\x13B\x3\x2\x2\x2\x13B\x13D"+
		"\a\x66\x2\x2\x13C\x13E\x5n\x38\x2\x13D\x13C\x3\x2\x2\x2\x13D\x13E\x3\x2"+
		"\x2\x2\x13E\x13F\x3\x2\x2\x2\x13F\x14A\x5\x1C\xF\x6\x140\x142\f\x4\x2"+
		"\x2\x141\x143\x5n\x38\x2\x142\x141\x3\x2\x2\x2\x142\x143\x3\x2\x2\x2\x143"+
		"\x144\x3\x2\x2\x2\x144\x146\ax\x2\x2\x145\x147\x5n\x38\x2\x146\x145\x3"+
		"\x2\x2\x2\x146\x147\x3\x2\x2\x2\x147\x148\x3\x2\x2\x2\x148\x14A\x5\x1C"+
		"\xF\x5\x149\xDD\x3\x2\x2\x2\x149\xE6\x3\x2\x2\x2\x149\xEF\x3\x2\x2\x2"+
		"\x149\xF8\x3\x2\x2\x2\x149\x101\x3\x2\x2\x2\x149\x10A\x3\x2\x2\x2\x149"+
		"\x113\x3\x2\x2\x2\x149\x11C\x3\x2\x2\x2\x149\x125\x3\x2\x2\x2\x149\x12E"+
		"\x3\x2\x2\x2\x149\x137\x3\x2\x2\x2\x149\x140\x3\x2\x2\x2\x14A\x14D\x3"+
		"\x2\x2\x2\x14B\x149\x3\x2\x2\x2\x14B\x14C\x3\x2\x2\x2\x14C\x1D\x3\x2\x2"+
		"\x2\x14D\x14B\x3\x2\x2\x2\x14E\x156\x5 \x11\x2\x14F\x156\a\xE8\x2\x2\x150"+
		"\x156\a\xE3\x2\x2\x151\x153\x5\x66\x34\x2\x152\x154\x5\x16\f\x2\x153\x152"+
		"\x3\x2\x2\x2\x153\x154\x3\x2\x2\x2\x154\x156\x3\x2\x2\x2\x155\x14E\x3"+
		"\x2\x2\x2\x155\x14F\x3\x2\x2\x2\x155\x150\x3\x2\x2\x2\x155\x151\x3\x2"+
		"\x2\x2\x156\x1F\x3\x2\x2\x2\x157\x158\t\a\x2\x2\x158!\x3\x2\x2\x2\x159"+
		"\x15B\a\xD4\x2\x2\x15A\x15C\x5n\x38\x2\x15B\x15A\x3\x2\x2\x2\x15B\x15C"+
		"\x3\x2\x2\x2\x15C\x15D\x3\x2\x2\x2\x15D\x15F\x5\x1C\xF\x2\x15E\x160\x5"+
		"n\x38\x2\x15F\x15E\x3\x2\x2\x2\x15F\x160\x3\x2\x2\x2\x160\x161\x3\x2\x2"+
		"\x2\x161\x162\a\xDB\x2\x2\x162#\x3\x2\x2\x2\x163\x164\a\xC1\x2\x2\x164"+
		"\x165\x5n\x38\x2\x165\x166\x5\x1C\xF\x2\x166\x167\x5n\x38\x2\x167\x168"+
		"\a|\x2\x2\x168\x169\x5n\x38\x2\x169\x16A\x5J&\x2\x16A%\x3\x2\x2\x2\x16B"+
		"\x16C\a\x8D\x2\x2\x16C\x16D\x5n\x38\x2\x16D\x16E\x5J&\x2\x16E\'\x3\x2"+
		"\x2\x2\x16F\x170\b\x15\x1\x2\x170\x174\x5@!\x2\x171\x174\x5> \x2\x172"+
		"\x174\x5\x42\"\x2\x173\x16F\x3\x2\x2\x2\x173\x171\x3\x2\x2\x2\x173\x172"+
		"\x3\x2\x2\x2\x174\x19C\x3\x2\x2\x2\x175\x177\f\v\x2\x2\x176\x178\x5n\x38"+
		"\x2\x177\x176\x3\x2\x2\x2\x177\x178\x3\x2\x2\x2\x178\x179\x3\x2\x2\x2"+
		"\x179\x17B\a\xD4\x2\x2\x17A\x17C\x5n\x38\x2\x17B\x17A\x3\x2\x2\x2\x17B"+
		"\x17C\x3\x2\x2\x2\x17C\x17E\x3\x2\x2\x2\x17D\x17F\x5\x30\x19\x2\x17E\x17D"+
		"\x3\x2\x2\x2\x17E\x17F\x3\x2\x2\x2\x17F\x181\x3\x2\x2\x2\x180\x182\x5"+
		"n\x38\x2\x181\x180\x3\x2\x2\x2\x181\x182\x3\x2\x2\x2\x182\x183\x3\x2\x2"+
		"\x2\x183\x19B\a\xDB\x2\x2\x184\x185\f\n\x2\x2\x185\x186\a-\x2\x2\x186"+
		"\x19B\x5\x6\x4\x2\x187\x188\f\t\x2\x2\x188\x18A\a\xEE\x2\x2\x189\x18B"+
		"\x5n\x38\x2\x18A\x189\x3\x2\x2\x2\x18A\x18B\x3\x2\x2\x2\x18B\x18C\x3\x2"+
		"\x2\x2\x18C\x18D\a-\x2\x2\x18D\x19B\x5\x6\x4\x2\x18E\x18F\f\b\x2\x2\x18F"+
		"\x190\a,\x2\x2\x190\x19B\x5\x6\x4\x2\x191\x192\f\a\x2\x2\x192\x193\a\xEE"+
		"\x2\x2\x193\x194\a,\x2\x2\x194\x19B\x5\x6\x4\x2\x195\x196\f\x6\x2\x2\x196"+
		"\x197\a\xEE\x2\x2\x197\x198\a,\x2\x2\x198\x199\a\xEE\x2\x2\x199\x19B\x5"+
		"\x6\x4\x2\x19A\x175\x3\x2\x2\x2\x19A\x184\x3\x2\x2\x2\x19A\x187\x3\x2"+
		"\x2\x2\x19A\x18E\x3\x2\x2\x2\x19A\x191\x3\x2\x2\x2\x19A\x195\x3\x2\x2"+
		"\x2\x19B\x19E\x3\x2\x2\x2\x19C\x19A\x3\x2\x2\x2\x19C\x19D\x3\x2\x2\x2"+
		"\x19D)\x3\x2\x2\x2\x19E\x19C\x3\x2\x2\x2\x19F\x1A0\x5(\x15\x2\x1A0\x1A1"+
		"\a-\x2\x2\x1A1\x1A2\x5\x6\x4\x2\x1A2\x1AC\x3\x2\x2\x2\x1A3\x1A4\x5(\x15"+
		"\x2\x1A4\x1A6\a\xEE\x2\x2\x1A5\x1A7\x5n\x38\x2\x1A6\x1A5\x3\x2\x2\x2\x1A6"+
		"\x1A7\x3\x2\x2\x2\x1A7\x1A8\x3\x2\x2\x2\x1A8\x1A9\a-\x2\x2\x1A9\x1AA\x5"+
		"\x6\x4\x2\x1AA\x1AC\x3\x2\x2\x2\x1AB\x19F\x3\x2\x2\x2\x1AB\x1A3\x3\x2"+
		"\x2\x2\x1AC+\x3\x2\x2\x2\x1AD\x1AF\x5(\x15\x2\x1AE\x1B0\x5n\x38\x2\x1AF"+
		"\x1AE\x3\x2\x2\x2\x1AF\x1B0\x3\x2\x2\x2\x1B0\x1B1\x3\x2\x2\x2\x1B1\x1B3"+
		"\a\xD4\x2\x2\x1B2\x1B4\x5n\x38\x2\x1B3\x1B2\x3\x2\x2\x2\x1B3\x1B4\x3\x2"+
		"\x2\x2\x1B4\x1B6\x3\x2\x2\x2\x1B5\x1B7\x5\x30\x19\x2\x1B6\x1B5\x3\x2\x2"+
		"\x2\x1B6\x1B7\x3\x2\x2\x2\x1B7\x1B9\x3\x2\x2\x2\x1B8\x1BA\x5n\x38\x2\x1B9"+
		"\x1B8\x3\x2\x2\x2\x1B9\x1BA\x3\x2\x2\x2\x1BA\x1BB\x3\x2\x2\x2\x1BB\x1BC"+
		"\a\xDB\x2\x2\x1BC-\x3\x2\x2\x2\x1BD\x1BE\x5(\x15\x2\x1BE\x1BF\a,\x2\x2"+
		"\x1BF\x1C0\x5\x6\x4\x2\x1C0\x1CD\x3\x2\x2\x2\x1C1\x1C2\x5(\x15\x2\x1C2"+
		"\x1C3\a\xEE\x2\x2\x1C3\x1C4\a,\x2\x2\x1C4\x1C5\x5\x6\x4\x2\x1C5\x1CD\x3"+
		"\x2\x2\x2\x1C6\x1C7\x5(\x15\x2\x1C7\x1C8\a\xEE\x2\x2\x1C8\x1C9\a,\x2\x2"+
		"\x1C9\x1CA\a\xEE\x2\x2\x1CA\x1CB\x5\x6\x4\x2\x1CB\x1CD\x3\x2\x2\x2\x1CC"+
		"\x1BD\x3\x2\x2\x2\x1CC\x1C1\x3\x2\x2\x2\x1CC\x1C6\x3\x2\x2\x2\x1CD/\x3"+
		"\x2\x2\x2\x1CE\x1CF\x5\x32\x1A\x2\x1CF\x31\x3\x2\x2\x2\x1D0\x1D2\x5\x34"+
		"\x1B\x2\x1D1\x1D0\x3\x2\x2\x2\x1D1\x1D2\x3\x2\x2\x2\x1D2\x1D4\x3\x2\x2"+
		"\x2\x1D3\x1D5\x5n\x38\x2\x1D4\x1D3\x3\x2\x2\x2\x1D4\x1D5\x3\x2\x2\x2\x1D5"+
		"\x1D6\x3\x2\x2\x2\x1D6\x1D8\a)\x2\x2\x1D7\x1D9\x5n\x38\x2\x1D8\x1D7\x3"+
		"\x2\x2\x2\x1D8\x1D9\x3\x2\x2\x2\x1D9\x1DB\x3\x2\x2\x2\x1DA\x1D1\x3\x2"+
		"\x2\x2\x1DB\x1DE\x3\x2\x2\x2\x1DC\x1DA\x3\x2\x2\x2\x1DC\x1DD\x3\x2\x2"+
		"\x2\x1DD\x1DF\x3\x2\x2\x2\x1DE\x1DC\x3\x2\x2\x2\x1DF\x1F1\x5\x36\x1C\x2"+
		"\x1E0\x1E2\x5\x34\x1B\x2\x1E1\x1E0\x3\x2\x2\x2\x1E1\x1E2\x3\x2\x2\x2\x1E2"+
		"\x1E4\x3\x2\x2\x2\x1E3\x1E5\x5n\x38\x2\x1E4\x1E3\x3\x2\x2\x2\x1E4\x1E5"+
		"\x3\x2\x2\x2\x1E5\x1E6\x3\x2\x2\x2\x1E6\x1E8\a)\x2\x2\x1E7\x1E9\x5n\x38"+
		"\x2\x1E8\x1E7\x3\x2\x2\x2\x1E8\x1E9\x3\x2\x2\x2\x1E9\x1EB\x3\x2\x2\x2"+
		"\x1EA\x1E1\x3\x2\x2\x2\x1EB\x1EE\x3\x2\x2\x2\x1EC\x1EA\x3\x2\x2\x2\x1EC"+
		"\x1ED\x3\x2\x2\x2\x1ED\x1EF\x3\x2\x2\x2\x1EE\x1EC\x3\x2\x2\x2\x1EF\x1F1"+
		"\x5\x38\x1D\x2\x1F0\x1DC\x3\x2\x2\x2\x1F0\x1EC\x3\x2\x2\x2\x1F1\x33\x3"+
		"\x2\x2\x2\x1F2\x1F3\x5<\x1F\x2\x1F3\x35\x3\x2\x2\x2\x1F4\x1F5\x5<\x1F"+
		"\x2\x1F5\x37\x3\x2\x2\x2\x1F6\x201\x5:\x1E\x2\x1F7\x1F9\x5n\x38\x2\x1F8"+
		"\x1F7\x3\x2\x2\x2\x1F8\x1F9\x3\x2\x2\x2\x1F9\x1FA\x3\x2\x2\x2\x1FA\x1FC"+
		"\a)\x2\x2\x1FB\x1FD\x5n\x38\x2\x1FC\x1FB\x3\x2\x2\x2\x1FC\x1FD\x3\x2\x2"+
		"\x2\x1FD\x1FE\x3\x2\x2\x2\x1FE\x200\x5:\x1E\x2\x1FF\x1F8\x3\x2\x2\x2\x200"+
		"\x203\x3\x2\x2\x2\x201\x1FF\x3\x2\x2\x2\x201\x202\x3\x2\x2\x2\x202\x39"+
		"\x3\x2\x2\x2\x203\x201\x3\x2\x2\x2\x204\x206\x5\x6\x4\x2\x205\x207\x5"+
		"n\x38\x2\x206\x205\x3\x2\x2\x2\x206\x207\x3\x2\x2\x2\x207\x208\x3\x2\x2"+
		"\x2\x208\x20A\a\xCD\x2\x2\x209\x20B\x5n\x38\x2\x20A\x209\x3\x2\x2\x2\x20A"+
		"\x20B\x3\x2\x2\x2\x20B\x20C\x3\x2\x2\x2\x20C\x20D\x5<\x1F\x2\x20D;\x3"+
		"\x2\x2\x2\x20E\x20F\a=\x2\x2\x20F\x211\x5n\x38\x2\x210\x20E\x3\x2\x2\x2"+
		"\x210\x211\x3\x2\x2\x2\x211\x212\x3\x2\x2\x2\x212\x215\x5\x1C\xF\x2\x213"+
		"\x215\x5N(\x2\x214\x210\x3\x2\x2\x2\x214\x213\x3\x2\x2\x2\x215=\x3\x2"+
		"\x2\x2\x216\x217\x5\b\x5\x2\x217?\x3\x2\x2\x2\x218\x219\a\x89\x2\x2\x219"+
		"\x41\x3\x2\x2\x2\x21A\x21D\x5\x44#\x2\x21B\x21D\x5\x46$\x2\x21C\x21A\x3"+
		"\x2\x2\x2\x21C\x21B\x3\x2\x2\x2\x21D\x43\x3\x2\x2\x2\x21E\x21F\a-\x2\x2"+
		"\x21F\x220\x5\x6\x4\x2\x220\x45\x3\x2\x2\x2\x221\x222\a,\x2\x2\x222\x223"+
		"\x5\x6\x4\x2\x223G\x3\x2\x2\x2\x224\x225\x5\x1C\xF\x2\x225I\x3\x2\x2\x2"+
		"\x226\x229\x5\x1A\xE\x2\x227\x229\x5L\'\x2\x228\x226\x3\x2\x2\x2\x228"+
		"\x227\x3\x2\x2\x2\x229K\x3\x2\x2\x2\x22A\x22D\x5> \x2\x22B\x22D\x5*\x16"+
		"\x2\x22C\x22A\x3\x2\x2\x2\x22C\x22B\x3\x2\x2\x2\x22DM\x3\x2\x2\x2\x22E"+
		"\x22F\a\x34\x2\x2\x22F\x230\x5n\x38\x2\x230\x231\x5P)\x2\x231O\x3\x2\x2"+
		"\x2\x232\x235\x5*\x16\x2\x233\x235\x5> \x2\x234\x232\x3\x2\x2\x2\x234"+
		"\x233\x3\x2\x2\x2\x235Q\x3\x2\x2\x2\x236\x23F\x5T+\x2\x237\x23F\x5X-\x2"+
		"\x238\x23F\x5Z.\x2\x239\x23F\x5`\x31\x2\x23A\x23F\x5\\/\x2\x23B\x23F\x5"+
		"\x66\x34\x2\x23C\x23F\x5V,\x2\x23D\x23F\x5\x62\x32\x2\x23E\x236\x3\x2"+
		"\x2\x2\x23E\x237\x3\x2\x2\x2\x23E\x238\x3\x2\x2\x2\x23E\x239\x3\x2\x2"+
		"\x2\x23E\x23A\x3\x2\x2\x2\x23E\x23B\x3\x2\x2\x2\x23E\x23C\x3\x2\x2\x2"+
		"\x23E\x23D\x3\x2\x2\x2\x23FS\x3\x2\x2\x2\x240\x241\t\b\x2\x2\x241U\x3"+
		"\x2\x2\x2\x242\x243\a\xAB\x2\x2\x243W\x3\x2\x2\x2\x244\x245\t\t\x2\x2"+
		"\x245Y\x3\x2\x2\x2\x246\x247\t\n\x2\x2\x247[\x3\x2\x2\x2\x248\x24B\a\x89"+
		"\x2\x2\x249\x24B\x5^\x30\x2\x24A\x248\x3\x2\x2\x2\x24A\x249\x3\x2\x2\x2"+
		"\x24B]\x3\x2\x2\x2\x24C\x24D\t\v\x2\x2\x24D_\x3\x2\x2\x2\x24E\x24F\t\f"+
		"\x2\x2\x24F\x61\x3\x2\x2\x2\x250\x251\t\r\x2\x2\x251\x63\x3\x2\x2\x2\x252"+
		"\x253\t\xE\x2\x2\x253\x65\x3\x2\x2\x2\x254\x258\x5h\x35\x2\x255\x258\x5"+
		"j\x36\x2\x256\x258\x5l\x37\x2\x257\x254\x3\x2\x2\x2\x257\x255\x3\x2\x2"+
		"\x2\x257\x256\x3\x2\x2\x2\x258g\x3\x2\x2\x2\x259\x25A\t\xF\x2\x2\x25A"+
		"i\x3\x2\x2\x2\x25B\x25C\a\x8F\x2\x2\x25Ck\x3\x2\x2\x2\x25D\x25E\t\x10"+
		"\x2\x2\x25Em\x3\x2\x2\x2\x25F\x261\t\x11\x2\x2\x260\x25F\x3\x2\x2\x2\x261"+
		"\x262\x3\x2\x2\x2\x262\x260\x3\x2\x2\x2\x262\x263\x3\x2\x2\x2\x263o\x3"+
		"\x2\x2\x2Yry~\x82\x86\x8A\x99\xA5\xAE\xB2\xB9\xBD\xC0\xC5\xCA\xD0\xD4"+
		"\xDB\xDF\xE3\xE8\xEC\xF1\xF5\xFA\xFE\x103\x107\x10C\x110\x115\x119\x11E"+
		"\x122\x127\x12B\x130\x134\x139\x13D\x142\x146\x149\x14B\x153\x155\x15B"+
		"\x15F\x173\x177\x17B\x17E\x181\x18A\x19A\x19C\x1A6\x1AB\x1AF\x1B3\x1B6"+
		"\x1B9\x1CC\x1D1\x1D4\x1D8\x1DC\x1E1\x1E4\x1E8\x1EC\x1F0\x1F8\x1FC\x201"+
		"\x206\x20A\x210\x214\x21C\x228\x22C\x234\x23E\x24A\x257\x262";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace Rubberduck.Parsing.Binding
