//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\hosch\Documents\Visual Studio 2015\Projects\Rubberduck\Rubberduck.Parsing\Preprocessing\VBAConditionalCompilationParser.g4 by ANTLR 4.3

// Unreachable code detected

using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Tree;

#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

namespace Rubberduck.Parsing.Preprocessing {
    [System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.3")]
[System.CLSCompliant(false)]
public partial class VBAConditionalCompilationParser : Parser {
	public const int
		PRINT=160, ELSEIF=90, CBYTE=7, CLOSE=67, STATIC=184, MINUS=216, OPTION_EXPLICIT=153, 
		L_SQUARE_BRACKET=222, DOEVENTS=23, DATELITERAL=229, ERROR=104, NOTHING=144, 
		EACH=88, SUB=188, STOP=186, LPAREN=214, MID=138, CVERR=21, AS=57, END_PROPERTY=95, 
		AT=47, DATABASE=69, GOSUB=117, CSNG=17, POW=220, DOLLAR=49, PROPERTY_LET=163, 
		THEN=191, XOR=206, EXIT_FOR=107, DEFINT=77, UNLOCK=196, CALL=64, LOCK_READ=133, 
		SET=180, BF=5, LOCK_READ_WRITE=135, ABS=1, LSET=136, RAISEEVENT=169, MIDBTYPESUFFIX=34, 
		SEEK=178, LONG=127, CBOOL=6, LIB=130, DIM=85, APPEND=56, OPEN=150, DIV=208, 
		PROPERTY_SET=164, CDBL=10, PERCENT=48, END_SELECT=96, STRING=187, SGN=39, 
		REM=173, TO=192, DEFDBL=75, BYVAL=61, FRIEND=112, LOOP=128, CLASS=66, 
		DO=86, VARIANT=198, END_WITH=99, DEFBOOL=72, OPTIONAL=151, ADDRESSOF=52, 
		CONST=68, RSET=177, INTEGER=125, CDEC=11, ATTRIBUTE=55, OUTPUT=157, FOR=113, 
		PTRSAFE=165, EQ=210, BOOLEAN=60, CIRCLE=13, NAME=140, END_FUNCTION=93, 
		DEFSNG=82, DEFBYTE=73, NOT=143, CINT=12, END=100, PRESERVE=159, ON_LOCAL_ERROR=149, 
		FLOATLITERAL=227, BINARY=59, B_CHAR=4, LENB=30, RETURN=176, EXCLAMATIONPOINT=44, 
		NEXT=141, GLOBAL=116, INPUTB=26, IDENTIFIER=235, WS=233, EMPTY=91, CURRENCY=19, 
		CCUR=8, MOD=139, WITHEVENTS=204, COLON=42, DEFLNGLNG=79, STEP=185, OPTION_BASE=152, 
		GT=212, PUT=167, WITH=203, CSTR=18, LOCK_WRITE=134, LINE_CONTINUATION=236, 
		TYPEOF=195, DEFVAR=84, DEFLNG=78, UBOUND=40, FALSE=111, ERRORCHAR=237, 
		UNDERSCORE=232, INTEGERLITERAL=228, END_IF=94, LOCK=126, TEXT=190, SINGLEQUOTE=231, 
		MULT=217, SEMICOLON=43, BYTE=63, HEXLITERAL=226, ELSE=89, IF=119, TYPE=194, 
		AMPERSAND=50, DEFLNGPTR=80, ENUM=101, DEFOBJ=81, IN=122, OPTION=36, DOT=45, 
		EXIT_DO=106, GUIDLITERAL=234, IS=124, EQV=102, WEND=200, FUNCTION=114, 
		HASH=46, CASE=65, GEQ=211, GET=115, PUBLIC=166, ON_ERROR=148, EXIT=24, 
		MIDB=33, END_ENUM=92, GOTO=118, INTDIV=209, LONGPTR=32, WIDTH=202, BEGIN=58, 
		EXIT_SUB=110, ASSIGN=207, WRITE=205, DOUBLE=87, EXIT_PROPERTY=109, COMMA=41, 
		RANDOM=168, PROPERTY_GET=162, SELECT=179, PRIVATE=161, ERASE=103, TAB=189, 
		BYREF=62, VERSION=199, NEQ=218, END_TYPE=98, NEW=142, ARRAY=3, INPUT=123, 
		SINGLE=182, ALIAS=53, SPC=183, LT=215, RESET=174, END_SUB=97, EVENT=105, 
		READ_WRITE=171, OPTION_COMPARE=154, ME=137, SCALE=38, CDATE=9, MIDTYPESUFFIX=35, 
		NULL=145, NEWLINE=230, TRUE=193, RPAREN=221, OBJECT=146, IMP=120, STRINGLITERAL=224, 
		OCTLITERAL=225, READ=170, DATE=70, LIKE=131, AND=54, OPTION_PRIVATE_MODULE=155, 
		CLNGLNG=15, PLUS=219, ANY=2, RESUME=175, INT=27, SHARED=181, EXIT_FUNCTION=108, 
		PSET=37, ACCESS=51, LINE_INPUT=132, ON=147, OR=156, PARAMARRAY=158, LBOUND=28, 
		R_SQUARE_BRACKET=223, IMPLEMENTS=121, UNTIL=197, DEBUG=22, DEFCUR=76, 
		CLNGPTR=16, LONGLONG=31, DECLARE=71, DEFDATE=74, FIX=25, LEN=29, REDIM=172, 
		LEQ=213, DEFSTR=83, LET=129, WHILE=201, CVAR=20, CLNG=14, LOAD=238, RESUME_NEXT=239;
	public static readonly string[] tokenNames = {
		"<INVALID>", "ABS", "ANY", "ARRAY", "B_CHAR", "BF", "CBOOL", "CBYTE", 
		"CCUR", "CDATE", "CDBL", "CDEC", "CINT", "CIRCLE", "CLNG", "CLNGLNG", 
		"CLNGPTR", "CSNG", "CSTR", "CURRENCY", "CVAR", "CVERR", "DEBUG", "DOEVENTS", 
		"EXIT", "FIX", "INPUTB", "INT", "LBOUND", "LEN", "LENB", "LONGLONG", "LONGPTR", 
		"MIDB", "MIDBTYPESUFFIX", "MIDTYPESUFFIX", "OPTION", "PSET", "SCALE", 
		"SGN", "UBOUND", "','", "':'", "';'", "'!'", "'.'", "'#'", "'@'", "'%'", 
		"'$'", "'&'", "ACCESS", "ADDRESSOF", "ALIAS", "AND", "ATTRIBUTE", "APPEND", 
		"AS", "BEGIN", "BINARY", "BOOLEAN", "BYVAL", "BYREF", "BYTE", "CALL", 
		"CASE", "CLASS", "CLOSE", "CONST", "DATABASE", "DATE", "DECLARE", "DEFBOOL", 
		"DEFBYTE", "DEFDATE", "DEFDBL", "DEFCUR", "DEFINT", "DEFLNG", "DEFLNGLNG", 
		"DEFLNGPTR", "DEFOBJ", "DEFSNG", "DEFSTR", "DEFVAR", "DIM", "DO", "DOUBLE", 
		"EACH", "ELSE", "ELSEIF", "EMPTY", "END_ENUM", "END_FUNCTION", "END_IF", 
		"END_PROPERTY", "END_SELECT", "END_SUB", "END_TYPE", "END_WITH", "END", 
		"ENUM", "EQV", "ERASE", "ERROR", "EVENT", "EXIT_DO", "EXIT_FOR", "EXIT_FUNCTION", 
		"EXIT_PROPERTY", "EXIT_SUB", "FALSE", "FRIEND", "FOR", "FUNCTION", "GET", 
		"GLOBAL", "GOSUB", "GOTO", "IF", "IMP", "IMPLEMENTS", "IN", "INPUT", "IS", 
		"INTEGER", "LOCK", "LONG", "LOOP", "LET", "LIB", "LIKE", "LINE_INPUT", 
		"LOCK_READ", "LOCK_WRITE", "LOCK_READ_WRITE", "LSET", "ME", "MID", "MOD", 
		"NAME", "NEXT", "NEW", "NOT", "NOTHING", "NULL", "OBJECT", "ON", "ON_ERROR", 
		"ON_LOCAL_ERROR", "OPEN", "OPTIONAL", "OPTION_BASE", "OPTION_EXPLICIT", 
		"OPTION_COMPARE", "OPTION_PRIVATE_MODULE", "OR", "OUTPUT", "PARAMARRAY", 
		"PRESERVE", "PRINT", "PRIVATE", "PROPERTY_GET", "PROPERTY_LET", "PROPERTY_SET", 
		"PTRSAFE", "PUBLIC", "PUT", "RANDOM", "RAISEEVENT", "READ", "READ_WRITE", 
		"REDIM", "REM", "RESET", "RESUME", "RETURN", "RSET", "SEEK", "SELECT", 
		"SET", "SHARED", "SINGLE", "SPC", "STATIC", "STEP", "STOP", "STRING", 
		"SUB", "TAB", "TEXT", "THEN", "TO", "TRUE", "TYPE", "TYPEOF", "UNLOCK", 
		"UNTIL", "VARIANT", "VERSION", "WEND", "WHILE", "WIDTH", "WITH", "WITHEVENTS", 
		"WRITE", "XOR", "':='", "'/'", "'\\'", "'='", "GEQ", "'>'", "LEQ", "'('", 
		"'<'", "'-'", "'*'", "NEQ", "'+'", "'^'", "')'", "'['", "']'", "STRINGLITERAL", 
		"OCTLITERAL", "HEXLITERAL", "FLOATLITERAL", "INTEGERLITERAL", "DATELITERAL", 
		"NEWLINE", "'''", "'_'", "WS", "GUIDLITERAL", "IDENTIFIER", "LINE_CONTINUATION", 
		"ERRORCHAR", "LOAD", "RESUME_NEXT"
	};
	public const int
		RULE_compilationUnit = 0, RULE_ccBlock = 1, RULE_ccConst = 2, RULE_ccVarLhs = 3, 
		RULE_ccIfBlock = 4, RULE_ccIf = 5, RULE_ccElseIfBlock = 6, RULE_ccElseIf = 7, 
		RULE_ccElseBlock = 8, RULE_ccElse = 9, RULE_ccEndIf = 10, RULE_ccEol = 11, 
		RULE_hashConst = 12, RULE_hashIf = 13, RULE_hashElseIf = 14, RULE_hashElse = 15, 
		RULE_hashEndIf = 16, RULE_physicalLine = 17, RULE_ccExpression = 18, RULE_intrinsicFunction = 19, 
		RULE_intrinsicFunctionName = 20, RULE_name = 21, RULE_nameValue = 22, 
		RULE_foreignName = 23, RULE_foreignIdentifier = 24, RULE_typeHint = 25, 
		RULE_literal = 26, RULE_comment = 27, RULE_keyword = 28, RULE_markerKeyword = 29, 
		RULE_statementKeyword = 30;
	public static readonly string[] ruleNames = {
		"compilationUnit", "ccBlock", "ccConst", "ccVarLhs", "ccIfBlock", "ccIf", 
		"ccElseIfBlock", "ccElseIf", "ccElseBlock", "ccElse", "ccEndIf", "ccEol", 
		"hashConst", "hashIf", "hashElseIf", "hashElse", "hashEndIf", "physicalLine", 
		"ccExpression", "intrinsicFunction", "intrinsicFunctionName", "name", 
		"nameValue", "foreignName", "foreignIdentifier", "typeHint", "literal", 
		"comment", "keyword", "markerKeyword", "statementKeyword"
	};

	public override string GrammarFileName { get { return "VBAConditionalCompilationParser.g4"; } }

	public override string[] TokenNames { get { return tokenNames; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public VBAConditionalCompilationParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class CompilationUnitContext : ParserRuleContext {
		public CcBlockContext ccBlock() {
			return GetRuleContext<CcBlockContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(VBAConditionalCompilationParser.Eof, 0); }
		public CompilationUnitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compilationUnit; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCompilationUnit(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCompilationUnit(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompilationUnit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CompilationUnitContext compilationUnit() {
		CompilationUnitContext _localctx = new CompilationUnitContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_compilationUnit);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 62; ccBlock();
			State = 63; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CcBlockContext : ParserRuleContext {
		public CcIfBlockContext ccIfBlock(int i) {
			return GetRuleContext<CcIfBlockContext>(i);
		}
		public IReadOnlyList<PhysicalLineContext> physicalLine() {
			return GetRuleContexts<PhysicalLineContext>();
		}
		public IReadOnlyList<CcIfBlockContext> ccIfBlock() {
			return GetRuleContexts<CcIfBlockContext>();
		}
		public IReadOnlyList<CcConstContext> ccConst() {
			return GetRuleContexts<CcConstContext>();
		}
		public CcConstContext ccConst(int i) {
			return GetRuleContext<CcConstContext>(i);
		}
		public PhysicalLineContext physicalLine(int i) {
			return GetRuleContext<PhysicalLineContext>(i);
		}
		public CcBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ccBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCcBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCcBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCcBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CcBlockContext ccBlock() {
		CcBlockContext _localctx = new CcBlockContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_ccBlock);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 70;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,1,_ctx);
			while ( _alt!=1 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1+1 ) {
					{
					State = 68;
					switch ( Interpreter.AdaptivePredict(_input,0,_ctx) ) {
					case 1:
						{
						State = 65; ccConst();
						}
						break;

					case 2:
						{
						State = 66; ccIfBlock();
						}
						break;

					case 3:
						{
						State = 67; physicalLine();
						}
						break;
					}
					} 
				}
				State = 72;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,1,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CcConstContext : ParserRuleContext {
		public CcVarLhsContext ccVarLhs() {
			return GetRuleContext<CcVarLhsContext>(0);
		}
		public ITerminalNode WS(int i) {
			return GetToken(VBAConditionalCompilationParser.WS, i);
		}
		public HashConstContext hashConst() {
			return GetRuleContext<HashConstContext>(0);
		}
		public IReadOnlyList<ITerminalNode> WS() { return GetTokens(VBAConditionalCompilationParser.WS); }
		public ITerminalNode EQ() { return GetToken(VBAConditionalCompilationParser.EQ, 0); }
		public CcEolContext ccEol() {
			return GetRuleContext<CcEolContext>(0);
		}
		public CcExpressionContext ccExpression() {
			return GetRuleContext<CcExpressionContext>(0);
		}
		public CcConstContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ccConst; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCcConst(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCcConst(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCcConst(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CcConstContext ccConst() {
		CcConstContext _localctx = new CcConstContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_ccConst);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 76;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==WS) {
				{
				{
				State = 73; Match(WS);
				}
				}
				State = 78;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 79; hashConst();
			State = 81;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 80; Match(WS);
				}
				}
				State = 83;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==WS );
			State = 85; ccVarLhs();
			State = 89;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==WS) {
				{
				{
				State = 86; Match(WS);
				}
				}
				State = 91;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 92; Match(EQ);
			State = 96;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==WS) {
				{
				{
				State = 93; Match(WS);
				}
				}
				State = 98;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 99; ccExpression(0);
			State = 100; ccEol();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CcVarLhsContext : ParserRuleContext {
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public CcVarLhsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ccVarLhs; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCcVarLhs(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCcVarLhs(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCcVarLhs(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CcVarLhsContext ccVarLhs() {
		CcVarLhsContext _localctx = new CcVarLhsContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_ccVarLhs);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 102; name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CcIfBlockContext : ParserRuleContext {
		public CcIfContext ccIf() {
			return GetRuleContext<CcIfContext>(0);
		}
		public CcBlockContext ccBlock() {
			return GetRuleContext<CcBlockContext>(0);
		}
		public CcElseIfBlockContext ccElseIfBlock(int i) {
			return GetRuleContext<CcElseIfBlockContext>(i);
		}
		public CcEndIfContext ccEndIf() {
			return GetRuleContext<CcEndIfContext>(0);
		}
		public CcElseBlockContext ccElseBlock() {
			return GetRuleContext<CcElseBlockContext>(0);
		}
		public IReadOnlyList<CcElseIfBlockContext> ccElseIfBlock() {
			return GetRuleContexts<CcElseIfBlockContext>();
		}
		public CcIfBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ccIfBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCcIfBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCcIfBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCcIfBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CcIfBlockContext ccIfBlock() {
		CcIfBlockContext _localctx = new CcIfBlockContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_ccIfBlock);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 104; ccIf();
			State = 105; ccBlock();
			State = 109;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,6,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 106; ccElseIfBlock();
					}
					} 
				}
				State = 111;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,6,_ctx);
			}
			State = 113;
			switch ( Interpreter.AdaptivePredict(_input,7,_ctx) ) {
			case 1:
				{
				State = 112; ccElseBlock();
				}
				break;
			}
			State = 115; ccEndIf();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CcIfContext : ParserRuleContext {
		public ITerminalNode WS(int i) {
			return GetToken(VBAConditionalCompilationParser.WS, i);
		}
		public HashIfContext hashIf() {
			return GetRuleContext<HashIfContext>(0);
		}
		public IReadOnlyList<ITerminalNode> WS() { return GetTokens(VBAConditionalCompilationParser.WS); }
		public ITerminalNode THEN() { return GetToken(VBAConditionalCompilationParser.THEN, 0); }
		public CcEolContext ccEol() {
			return GetRuleContext<CcEolContext>(0);
		}
		public CcExpressionContext ccExpression() {
			return GetRuleContext<CcExpressionContext>(0);
		}
		public CcIfContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ccIf; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCcIf(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCcIf(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCcIf(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CcIfContext ccIf() {
		CcIfContext _localctx = new CcIfContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_ccIf);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 120;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==WS) {
				{
				{
				State = 117; Match(WS);
				}
				}
				State = 122;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 123; hashIf();
			State = 125;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 124; Match(WS);
				}
				}
				State = 127;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==WS );
			State = 129; ccExpression(0);
			State = 131;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 130; Match(WS);
				}
				}
				State = 133;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==WS );
			State = 135; Match(THEN);
			State = 136; ccEol();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CcElseIfBlockContext : ParserRuleContext {
		public CcBlockContext ccBlock() {
			return GetRuleContext<CcBlockContext>(0);
		}
		public CcElseIfContext ccElseIf() {
			return GetRuleContext<CcElseIfContext>(0);
		}
		public CcElseIfBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ccElseIfBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCcElseIfBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCcElseIfBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCcElseIfBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CcElseIfBlockContext ccElseIfBlock() {
		CcElseIfBlockContext _localctx = new CcElseIfBlockContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_ccElseIfBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 138; ccElseIf();
			State = 139; ccBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CcElseIfContext : ParserRuleContext {
		public ITerminalNode WS(int i) {
			return GetToken(VBAConditionalCompilationParser.WS, i);
		}
		public IReadOnlyList<ITerminalNode> WS() { return GetTokens(VBAConditionalCompilationParser.WS); }
		public ITerminalNode THEN() { return GetToken(VBAConditionalCompilationParser.THEN, 0); }
		public CcEolContext ccEol() {
			return GetRuleContext<CcEolContext>(0);
		}
		public HashElseIfContext hashElseIf() {
			return GetRuleContext<HashElseIfContext>(0);
		}
		public CcExpressionContext ccExpression() {
			return GetRuleContext<CcExpressionContext>(0);
		}
		public CcElseIfContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ccElseIf; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCcElseIf(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCcElseIf(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCcElseIf(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CcElseIfContext ccElseIf() {
		CcElseIfContext _localctx = new CcElseIfContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_ccElseIf);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 144;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==WS) {
				{
				{
				State = 141; Match(WS);
				}
				}
				State = 146;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 147; hashElseIf();
			State = 149;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 148; Match(WS);
				}
				}
				State = 151;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==WS );
			State = 153; ccExpression(0);
			State = 155;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 154; Match(WS);
				}
				}
				State = 157;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==WS );
			State = 159; Match(THEN);
			State = 160; ccEol();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CcElseBlockContext : ParserRuleContext {
		public CcBlockContext ccBlock() {
			return GetRuleContext<CcBlockContext>(0);
		}
		public CcElseContext ccElse() {
			return GetRuleContext<CcElseContext>(0);
		}
		public CcElseBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ccElseBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCcElseBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCcElseBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCcElseBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CcElseBlockContext ccElseBlock() {
		CcElseBlockContext _localctx = new CcElseBlockContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_ccElseBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 162; ccElse();
			State = 163; ccBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CcElseContext : ParserRuleContext {
		public HashElseContext hashElse() {
			return GetRuleContext<HashElseContext>(0);
		}
		public ITerminalNode WS(int i) {
			return GetToken(VBAConditionalCompilationParser.WS, i);
		}
		public IReadOnlyList<ITerminalNode> WS() { return GetTokens(VBAConditionalCompilationParser.WS); }
		public CcEolContext ccEol() {
			return GetRuleContext<CcEolContext>(0);
		}
		public CcElseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ccElse; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCcElse(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCcElse(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCcElse(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CcElseContext ccElse() {
		CcElseContext _localctx = new CcElseContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_ccElse);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 168;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==WS) {
				{
				{
				State = 165; Match(WS);
				}
				}
				State = 170;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 171; hashElse();
			State = 172; ccEol();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CcEndIfContext : ParserRuleContext {
		public ITerminalNode WS(int i) {
			return GetToken(VBAConditionalCompilationParser.WS, i);
		}
		public IReadOnlyList<ITerminalNode> WS() { return GetTokens(VBAConditionalCompilationParser.WS); }
		public CcEolContext ccEol() {
			return GetRuleContext<CcEolContext>(0);
		}
		public HashEndIfContext hashEndIf() {
			return GetRuleContext<HashEndIfContext>(0);
		}
		public CcEndIfContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ccEndIf; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCcEndIf(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCcEndIf(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCcEndIf(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CcEndIfContext ccEndIf() {
		CcEndIfContext _localctx = new CcEndIfContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_ccEndIf);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 177;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==WS) {
				{
				{
				State = 174; Match(WS);
				}
				}
				State = 179;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 180; hashEndIf();
			State = 181; ccEol();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CcEolContext : ParserRuleContext {
		public ITerminalNode WS(int i) {
			return GetToken(VBAConditionalCompilationParser.WS, i);
		}
		public CommentContext comment() {
			return GetRuleContext<CommentContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(VBAConditionalCompilationParser.Eof, 0); }
		public IReadOnlyList<ITerminalNode> WS() { return GetTokens(VBAConditionalCompilationParser.WS); }
		public ITerminalNode NEWLINE() { return GetToken(VBAConditionalCompilationParser.NEWLINE, 0); }
		public CcEolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ccEol; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCcEol(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCcEol(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCcEol(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CcEolContext ccEol() {
		CcEolContext _localctx = new CcEolContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_ccEol);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 186;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==WS) {
				{
				{
				State = 183; Match(WS);
				}
				}
				State = 188;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 190;
			_la = _input.La(1);
			if (_la==SINGLEQUOTE) {
				{
				State = 189; comment();
				}
			}

			State = 192;
			_la = _input.La(1);
			if ( !(_la==Eof || _la==NEWLINE) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HashConstContext : ParserRuleContext {
		public ITerminalNode CONST() { return GetToken(VBAConditionalCompilationParser.CONST, 0); }
		public ITerminalNode HASH() { return GetToken(VBAConditionalCompilationParser.HASH, 0); }
		public HashConstContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hashConst; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterHashConst(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitHashConst(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHashConst(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HashConstContext hashConst() {
		HashConstContext _localctx = new HashConstContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_hashConst);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 194; Match(HASH);
			State = 195; Match(CONST);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HashIfContext : ParserRuleContext {
		public ITerminalNode IF() { return GetToken(VBAConditionalCompilationParser.IF, 0); }
		public ITerminalNode HASH() { return GetToken(VBAConditionalCompilationParser.HASH, 0); }
		public HashIfContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hashIf; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterHashIf(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitHashIf(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHashIf(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HashIfContext hashIf() {
		HashIfContext _localctx = new HashIfContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_hashIf);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 197; Match(HASH);
			State = 198; Match(IF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HashElseIfContext : ParserRuleContext {
		public ITerminalNode ELSEIF() { return GetToken(VBAConditionalCompilationParser.ELSEIF, 0); }
		public ITerminalNode HASH() { return GetToken(VBAConditionalCompilationParser.HASH, 0); }
		public HashElseIfContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hashElseIf; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterHashElseIf(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitHashElseIf(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHashElseIf(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HashElseIfContext hashElseIf() {
		HashElseIfContext _localctx = new HashElseIfContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_hashElseIf);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 200; Match(HASH);
			State = 201; Match(ELSEIF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HashElseContext : ParserRuleContext {
		public ITerminalNode ELSE() { return GetToken(VBAConditionalCompilationParser.ELSE, 0); }
		public ITerminalNode HASH() { return GetToken(VBAConditionalCompilationParser.HASH, 0); }
		public HashElseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hashElse; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterHashElse(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitHashElse(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHashElse(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HashElseContext hashElse() {
		HashElseContext _localctx = new HashElseContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_hashElse);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 203; Match(HASH);
			State = 204; Match(ELSE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HashEndIfContext : ParserRuleContext {
		public ITerminalNode END_IF() { return GetToken(VBAConditionalCompilationParser.END_IF, 0); }
		public ITerminalNode HASH() { return GetToken(VBAConditionalCompilationParser.HASH, 0); }
		public HashEndIfContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hashEndIf; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterHashEndIf(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitHashEndIf(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHashEndIf(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HashEndIfContext hashEndIf() {
		HashEndIfContext _localctx = new HashEndIfContext(_ctx, State);
		EnterRule(_localctx, 32, RULE_hashEndIf);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 206; Match(HASH);
			State = 207; Match(END_IF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PhysicalLineContext : ParserRuleContext {
		public ITerminalNode Eof(int i) {
			return GetToken(VBAConditionalCompilationParser.Eof, i);
		}
		public IReadOnlyList<ITerminalNode> Eof() { return GetTokens(VBAConditionalCompilationParser.Eof); }
		public IReadOnlyList<ITerminalNode> NEWLINE() { return GetTokens(VBAConditionalCompilationParser.NEWLINE); }
		public ITerminalNode NEWLINE(int i) {
			return GetToken(VBAConditionalCompilationParser.NEWLINE, i);
		}
		public PhysicalLineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_physicalLine; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterPhysicalLine(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitPhysicalLine(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPhysicalLine(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PhysicalLineContext physicalLine() {
		PhysicalLineContext _localctx = new PhysicalLineContext(_ctx, State);
		EnterRule(_localctx, 34, RULE_physicalLine);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 212;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABS) | (1L << ANY) | (1L << ARRAY) | (1L << B_CHAR) | (1L << BF) | (1L << CBOOL) | (1L << CBYTE) | (1L << CCUR) | (1L << CDATE) | (1L << CDBL) | (1L << CDEC) | (1L << CINT) | (1L << CIRCLE) | (1L << CLNG) | (1L << CLNGLNG) | (1L << CLNGPTR) | (1L << CSNG) | (1L << CSTR) | (1L << CURRENCY) | (1L << CVAR) | (1L << CVERR) | (1L << DEBUG) | (1L << DOEVENTS) | (1L << EXIT) | (1L << FIX) | (1L << INPUTB) | (1L << INT) | (1L << LBOUND) | (1L << LEN) | (1L << LENB) | (1L << LONGLONG) | (1L << LONGPTR) | (1L << MIDB) | (1L << MIDBTYPESUFFIX) | (1L << MIDTYPESUFFIX) | (1L << OPTION) | (1L << PSET) | (1L << SCALE) | (1L << SGN) | (1L << UBOUND) | (1L << COMMA) | (1L << COLON) | (1L << SEMICOLON) | (1L << EXCLAMATIONPOINT) | (1L << DOT) | (1L << HASH) | (1L << AT) | (1L << PERCENT) | (1L << DOLLAR) | (1L << AMPERSAND) | (1L << ACCESS) | (1L << ADDRESSOF) | (1L << ALIAS) | (1L << AND) | (1L << ATTRIBUTE) | (1L << APPEND) | (1L << AS) | (1L << BEGIN) | (1L << BINARY) | (1L << BOOLEAN) | (1L << BYVAL) | (1L << BYREF) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CASE - 64)) | (1L << (CLASS - 64)) | (1L << (CLOSE - 64)) | (1L << (CONST - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DECLARE - 64)) | (1L << (DEFBOOL - 64)) | (1L << (DEFBYTE - 64)) | (1L << (DEFDATE - 64)) | (1L << (DEFDBL - 64)) | (1L << (DEFCUR - 64)) | (1L << (DEFINT - 64)) | (1L << (DEFLNG - 64)) | (1L << (DEFLNGLNG - 64)) | (1L << (DEFLNGPTR - 64)) | (1L << (DEFOBJ - 64)) | (1L << (DEFSNG - 64)) | (1L << (DEFSTR - 64)) | (1L << (DEFVAR - 64)) | (1L << (DIM - 64)) | (1L << (DO - 64)) | (1L << (DOUBLE - 64)) | (1L << (EACH - 64)) | (1L << (ELSE - 64)) | (1L << (ELSEIF - 64)) | (1L << (EMPTY - 64)) | (1L << (END_ENUM - 64)) | (1L << (END_FUNCTION - 64)) | (1L << (END_IF - 64)) | (1L << (END_PROPERTY - 64)) | (1L << (END_SELECT - 64)) | (1L << (END_SUB - 64)) | (1L << (END_TYPE - 64)) | (1L << (END_WITH - 64)) | (1L << (END - 64)) | (1L << (ENUM - 64)) | (1L << (EQV - 64)) | (1L << (ERASE - 64)) | (1L << (ERROR - 64)) | (1L << (EVENT - 64)) | (1L << (EXIT_DO - 64)) | (1L << (EXIT_FOR - 64)) | (1L << (EXIT_FUNCTION - 64)) | (1L << (EXIT_PROPERTY - 64)) | (1L << (EXIT_SUB - 64)) | (1L << (FALSE - 64)) | (1L << (FRIEND - 64)) | (1L << (FOR - 64)) | (1L << (FUNCTION - 64)) | (1L << (GET - 64)) | (1L << (GLOBAL - 64)) | (1L << (GOSUB - 64)) | (1L << (GOTO - 64)) | (1L << (IF - 64)) | (1L << (IMP - 64)) | (1L << (IMPLEMENTS - 64)) | (1L << (IN - 64)) | (1L << (INPUT - 64)) | (1L << (IS - 64)) | (1L << (INTEGER - 64)) | (1L << (LOCK - 64)) | (1L << (LONG - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (LOOP - 128)) | (1L << (LET - 128)) | (1L << (LIB - 128)) | (1L << (LIKE - 128)) | (1L << (LINE_INPUT - 128)) | (1L << (LOCK_READ - 128)) | (1L << (LOCK_WRITE - 128)) | (1L << (LOCK_READ_WRITE - 128)) | (1L << (LSET - 128)) | (1L << (ME - 128)) | (1L << (MID - 128)) | (1L << (MOD - 128)) | (1L << (NAME - 128)) | (1L << (NEXT - 128)) | (1L << (NEW - 128)) | (1L << (NOT - 128)) | (1L << (NOTHING - 128)) | (1L << (NULL - 128)) | (1L << (OBJECT - 128)) | (1L << (ON - 128)) | (1L << (ON_ERROR - 128)) | (1L << (ON_LOCAL_ERROR - 128)) | (1L << (OPEN - 128)) | (1L << (OPTIONAL - 128)) | (1L << (OPTION_BASE - 128)) | (1L << (OPTION_EXPLICIT - 128)) | (1L << (OPTION_COMPARE - 128)) | (1L << (OPTION_PRIVATE_MODULE - 128)) | (1L << (OR - 128)) | (1L << (OUTPUT - 128)) | (1L << (PARAMARRAY - 128)) | (1L << (PRESERVE - 128)) | (1L << (PRINT - 128)) | (1L << (PRIVATE - 128)) | (1L << (PROPERTY_GET - 128)) | (1L << (PROPERTY_LET - 128)) | (1L << (PROPERTY_SET - 128)) | (1L << (PTRSAFE - 128)) | (1L << (PUBLIC - 128)) | (1L << (PUT - 128)) | (1L << (RANDOM - 128)) | (1L << (RAISEEVENT - 128)) | (1L << (READ - 128)) | (1L << (READ_WRITE - 128)) | (1L << (REDIM - 128)) | (1L << (REM - 128)) | (1L << (RESET - 128)) | (1L << (RESUME - 128)) | (1L << (RETURN - 128)) | (1L << (RSET - 128)) | (1L << (SEEK - 128)) | (1L << (SELECT - 128)) | (1L << (SET - 128)) | (1L << (SHARED - 128)) | (1L << (SINGLE - 128)) | (1L << (SPC - 128)) | (1L << (STATIC - 128)) | (1L << (STEP - 128)) | (1L << (STOP - 128)) | (1L << (STRING - 128)) | (1L << (SUB - 128)) | (1L << (TAB - 128)) | (1L << (TEXT - 128)) | (1L << (THEN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (TO - 192)) | (1L << (TRUE - 192)) | (1L << (TYPE - 192)) | (1L << (TYPEOF - 192)) | (1L << (UNLOCK - 192)) | (1L << (UNTIL - 192)) | (1L << (VARIANT - 192)) | (1L << (VERSION - 192)) | (1L << (WEND - 192)) | (1L << (WHILE - 192)) | (1L << (WIDTH - 192)) | (1L << (WITH - 192)) | (1L << (WITHEVENTS - 192)) | (1L << (WRITE - 192)) | (1L << (XOR - 192)) | (1L << (ASSIGN - 192)) | (1L << (DIV - 192)) | (1L << (INTDIV - 192)) | (1L << (EQ - 192)) | (1L << (GEQ - 192)) | (1L << (GT - 192)) | (1L << (LEQ - 192)) | (1L << (LPAREN - 192)) | (1L << (LT - 192)) | (1L << (MINUS - 192)) | (1L << (MULT - 192)) | (1L << (NEQ - 192)) | (1L << (PLUS - 192)) | (1L << (POW - 192)) | (1L << (RPAREN - 192)) | (1L << (L_SQUARE_BRACKET - 192)) | (1L << (R_SQUARE_BRACKET - 192)) | (1L << (STRINGLITERAL - 192)) | (1L << (OCTLITERAL - 192)) | (1L << (HEXLITERAL - 192)) | (1L << (FLOATLITERAL - 192)) | (1L << (INTEGERLITERAL - 192)) | (1L << (DATELITERAL - 192)) | (1L << (SINGLEQUOTE - 192)) | (1L << (UNDERSCORE - 192)) | (1L << (WS - 192)) | (1L << (GUIDLITERAL - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (LINE_CONTINUATION - 192)) | (1L << (ERRORCHAR - 192)) | (1L << (LOAD - 192)) | (1L << (RESUME_NEXT - 192)))) != 0)) {
				{
				{
				State = 209;
				_la = _input.La(1);
				if ( _la <= 0 || (_la==Eof || _la==NEWLINE) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				}
				}
				State = 214;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 215;
			_la = _input.La(1);
			if ( !(_la==Eof || _la==NEWLINE) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CcExpressionContext : ParserRuleContext {
		public ITerminalNode XOR() { return GetToken(VBAConditionalCompilationParser.XOR, 0); }
		public ITerminalNode EQV() { return GetToken(VBAConditionalCompilationParser.EQV, 0); }
		public ITerminalNode AMPERSAND() { return GetToken(VBAConditionalCompilationParser.AMPERSAND, 0); }
		public IReadOnlyList<CcExpressionContext> ccExpression() {
			return GetRuleContexts<CcExpressionContext>();
		}
		public ITerminalNode INTDIV() { return GetToken(VBAConditionalCompilationParser.INTDIV, 0); }
		public ITerminalNode NOT() { return GetToken(VBAConditionalCompilationParser.NOT, 0); }
		public ITerminalNode GEQ() { return GetToken(VBAConditionalCompilationParser.GEQ, 0); }
		public ITerminalNode LPAREN() { return GetToken(VBAConditionalCompilationParser.LPAREN, 0); }
		public ITerminalNode LEQ() { return GetToken(VBAConditionalCompilationParser.LEQ, 0); }
		public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public ITerminalNode AND() { return GetToken(VBAConditionalCompilationParser.AND, 0); }
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public ITerminalNode IMP() { return GetToken(VBAConditionalCompilationParser.IMP, 0); }
		public CcExpressionContext ccExpression(int i) {
			return GetRuleContext<CcExpressionContext>(i);
		}
		public ITerminalNode POW() { return GetToken(VBAConditionalCompilationParser.POW, 0); }
		public ITerminalNode DIV() { return GetToken(VBAConditionalCompilationParser.DIV, 0); }
		public ITerminalNode NEQ() { return GetToken(VBAConditionalCompilationParser.NEQ, 0); }
		public IntrinsicFunctionContext intrinsicFunction() {
			return GetRuleContext<IntrinsicFunctionContext>(0);
		}
		public ITerminalNode MULT() { return GetToken(VBAConditionalCompilationParser.MULT, 0); }
		public ITerminalNode LT() { return GetToken(VBAConditionalCompilationParser.LT, 0); }
		public ITerminalNode GT() { return GetToken(VBAConditionalCompilationParser.GT, 0); }
		public ITerminalNode RPAREN() { return GetToken(VBAConditionalCompilationParser.RPAREN, 0); }
		public ITerminalNode MOD() { return GetToken(VBAConditionalCompilationParser.MOD, 0); }
		public ITerminalNode OR() { return GetToken(VBAConditionalCompilationParser.OR, 0); }
		public ITerminalNode WS(int i) {
			return GetToken(VBAConditionalCompilationParser.WS, i);
		}
		public ITerminalNode IS() { return GetToken(VBAConditionalCompilationParser.IS, 0); }
		public IReadOnlyList<ITerminalNode> WS() { return GetTokens(VBAConditionalCompilationParser.WS); }
		public ITerminalNode MINUS() { return GetToken(VBAConditionalCompilationParser.MINUS, 0); }
		public ITerminalNode PLUS() { return GetToken(VBAConditionalCompilationParser.PLUS, 0); }
		public ITerminalNode EQ() { return GetToken(VBAConditionalCompilationParser.EQ, 0); }
		public ITerminalNode LIKE() { return GetToken(VBAConditionalCompilationParser.LIKE, 0); }
		public CcExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ccExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCcExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCcExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCcExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CcExpressionContext ccExpression() {
		return ccExpression(0);
	}

	private CcExpressionContext ccExpression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		CcExpressionContext _localctx = new CcExpressionContext(_ctx, _parentState);
		CcExpressionContext _prevctx = _localctx;
		int _startState = 36;
		EnterRecursionRule(_localctx, 36, RULE_ccExpression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 253;
			switch ( Interpreter.AdaptivePredict(_input,23,_ctx) ) {
			case 1:
				{
				State = 218; Match(MINUS);
				State = 222;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==WS) {
					{
					{
					State = 219; Match(WS);
					}
					}
					State = 224;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 225; ccExpression(16);
				}
				break;

			case 2:
				{
				State = 226; Match(NOT);
				State = 230;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==WS) {
					{
					{
					State = 227; Match(WS);
					}
					}
					State = 232;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 233; ccExpression(9);
				}
				break;

			case 3:
				{
				State = 234; Match(LPAREN);
				State = 238;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==WS) {
					{
					{
					State = 235; Match(WS);
					}
					}
					State = 240;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 241; ccExpression(0);
				State = 245;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==WS) {
					{
					{
					State = 242; Match(WS);
					}
					}
					State = 247;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 248; Match(RPAREN);
				}
				break;

			case 4:
				{
				State = 250; intrinsicFunction();
				}
				break;

			case 5:
				{
				State = 251; literal();
				}
				break;

			case 6:
				{
				State = 252; name();
				}
				break;
			}
			_ctx.stop = _input.Lt(-1);
			State = 437;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,49,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 435;
					switch ( Interpreter.AdaptivePredict(_input,48,_ctx) ) {
					case 1:
						{
						_localctx = new CcExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_ccExpression);
						State = 255;
						if (!(Precpred(_ctx, 17))) throw new FailedPredicateException(this, "Precpred(_ctx, 17)");
						State = 259;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 256; Match(WS);
							}
							}
							State = 261;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 262; Match(POW);
						State = 266;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 263; Match(WS);
							}
							}
							State = 268;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 269; ccExpression(18);
						}
						break;

					case 2:
						{
						_localctx = new CcExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_ccExpression);
						State = 270;
						if (!(Precpred(_ctx, 15))) throw new FailedPredicateException(this, "Precpred(_ctx, 15)");
						State = 274;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 271; Match(WS);
							}
							}
							State = 276;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 277;
						_la = _input.La(1);
						if ( !(_la==DIV || _la==MULT) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 281;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 278; Match(WS);
							}
							}
							State = 283;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 284; ccExpression(16);
						}
						break;

					case 3:
						{
						_localctx = new CcExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_ccExpression);
						State = 285;
						if (!(Precpred(_ctx, 14))) throw new FailedPredicateException(this, "Precpred(_ctx, 14)");
						State = 289;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 286; Match(WS);
							}
							}
							State = 291;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 292; Match(INTDIV);
						State = 296;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 293; Match(WS);
							}
							}
							State = 298;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 299; ccExpression(15);
						}
						break;

					case 4:
						{
						_localctx = new CcExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_ccExpression);
						State = 300;
						if (!(Precpred(_ctx, 13))) throw new FailedPredicateException(this, "Precpred(_ctx, 13)");
						State = 304;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 301; Match(WS);
							}
							}
							State = 306;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 307; Match(MOD);
						State = 311;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 308; Match(WS);
							}
							}
							State = 313;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 314; ccExpression(14);
						}
						break;

					case 5:
						{
						_localctx = new CcExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_ccExpression);
						State = 315;
						if (!(Precpred(_ctx, 12))) throw new FailedPredicateException(this, "Precpred(_ctx, 12)");
						State = 319;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 316; Match(WS);
							}
							}
							State = 321;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 322;
						_la = _input.La(1);
						if ( !(_la==MINUS || _la==PLUS) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 326;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 323; Match(WS);
							}
							}
							State = 328;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 329; ccExpression(13);
						}
						break;

					case 6:
						{
						_localctx = new CcExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_ccExpression);
						State = 330;
						if (!(Precpred(_ctx, 11))) throw new FailedPredicateException(this, "Precpred(_ctx, 11)");
						State = 334;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 331; Match(WS);
							}
							}
							State = 336;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 337; Match(AMPERSAND);
						State = 341;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 338; Match(WS);
							}
							}
							State = 343;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 344; ccExpression(12);
						}
						break;

					case 7:
						{
						_localctx = new CcExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_ccExpression);
						State = 345;
						if (!(Precpred(_ctx, 10))) throw new FailedPredicateException(this, "Precpred(_ctx, 10)");
						State = 349;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 346; Match(WS);
							}
							}
							State = 351;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 352;
						_la = _input.La(1);
						if ( !(_la==IS || _la==LIKE || ((((_la - 210)) & ~0x3f) == 0 && ((1L << (_la - 210)) & ((1L << (EQ - 210)) | (1L << (GEQ - 210)) | (1L << (GT - 210)) | (1L << (LEQ - 210)) | (1L << (LT - 210)) | (1L << (NEQ - 210)))) != 0)) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 356;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 353; Match(WS);
							}
							}
							State = 358;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 359; ccExpression(11);
						}
						break;

					case 8:
						{
						_localctx = new CcExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_ccExpression);
						State = 360;
						if (!(Precpred(_ctx, 8))) throw new FailedPredicateException(this, "Precpred(_ctx, 8)");
						State = 364;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 361; Match(WS);
							}
							}
							State = 366;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 367; Match(AND);
						State = 371;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 368; Match(WS);
							}
							}
							State = 373;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 374; ccExpression(9);
						}
						break;

					case 9:
						{
						_localctx = new CcExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_ccExpression);
						State = 375;
						if (!(Precpred(_ctx, 7))) throw new FailedPredicateException(this, "Precpred(_ctx, 7)");
						State = 379;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 376; Match(WS);
							}
							}
							State = 381;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 382; Match(OR);
						State = 386;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 383; Match(WS);
							}
							}
							State = 388;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 389; ccExpression(8);
						}
						break;

					case 10:
						{
						_localctx = new CcExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_ccExpression);
						State = 390;
						if (!(Precpred(_ctx, 6))) throw new FailedPredicateException(this, "Precpred(_ctx, 6)");
						State = 394;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 391; Match(WS);
							}
							}
							State = 396;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 397; Match(XOR);
						State = 401;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 398; Match(WS);
							}
							}
							State = 403;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 404; ccExpression(7);
						}
						break;

					case 11:
						{
						_localctx = new CcExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_ccExpression);
						State = 405;
						if (!(Precpred(_ctx, 5))) throw new FailedPredicateException(this, "Precpred(_ctx, 5)");
						State = 409;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 406; Match(WS);
							}
							}
							State = 411;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 412; Match(EQV);
						State = 416;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 413; Match(WS);
							}
							}
							State = 418;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 419; ccExpression(6);
						}
						break;

					case 12:
						{
						_localctx = new CcExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_ccExpression);
						State = 420;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 424;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 421; Match(WS);
							}
							}
							State = 426;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 427; Match(IMP);
						State = 431;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 428; Match(WS);
							}
							}
							State = 433;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 434; ccExpression(5);
						}
						break;
					}
					} 
				}
				State = 439;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,49,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class IntrinsicFunctionContext : ParserRuleContext {
		public IntrinsicFunctionNameContext intrinsicFunctionName() {
			return GetRuleContext<IntrinsicFunctionNameContext>(0);
		}
		public ITerminalNode WS(int i) {
			return GetToken(VBAConditionalCompilationParser.WS, i);
		}
		public ITerminalNode LPAREN() { return GetToken(VBAConditionalCompilationParser.LPAREN, 0); }
		public IReadOnlyList<ITerminalNode> WS() { return GetTokens(VBAConditionalCompilationParser.WS); }
		public ITerminalNode RPAREN() { return GetToken(VBAConditionalCompilationParser.RPAREN, 0); }
		public CcExpressionContext ccExpression() {
			return GetRuleContext<CcExpressionContext>(0);
		}
		public IntrinsicFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_intrinsicFunction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterIntrinsicFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitIntrinsicFunction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIntrinsicFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IntrinsicFunctionContext intrinsicFunction() {
		IntrinsicFunctionContext _localctx = new IntrinsicFunctionContext(_ctx, State);
		EnterRule(_localctx, 38, RULE_intrinsicFunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 440; intrinsicFunctionName();
			State = 441; Match(LPAREN);
			State = 445;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==WS) {
				{
				{
				State = 442; Match(WS);
				}
				}
				State = 447;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 448; ccExpression(0);
			State = 452;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==WS) {
				{
				{
				State = 449; Match(WS);
				}
				}
				State = 454;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 455; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntrinsicFunctionNameContext : ParserRuleContext {
		public ITerminalNode CSTR() { return GetToken(VBAConditionalCompilationParser.CSTR, 0); }
		public ITerminalNode CLNGLNG() { return GetToken(VBAConditionalCompilationParser.CLNGLNG, 0); }
		public ITerminalNode CDATE() { return GetToken(VBAConditionalCompilationParser.CDATE, 0); }
		public ITerminalNode CINT() { return GetToken(VBAConditionalCompilationParser.CINT, 0); }
		public ITerminalNode ABS() { return GetToken(VBAConditionalCompilationParser.ABS, 0); }
		public ITerminalNode LEN() { return GetToken(VBAConditionalCompilationParser.LEN, 0); }
		public ITerminalNode CSNG() { return GetToken(VBAConditionalCompilationParser.CSNG, 0); }
		public ITerminalNode INT() { return GetToken(VBAConditionalCompilationParser.INT, 0); }
		public ITerminalNode CCUR() { return GetToken(VBAConditionalCompilationParser.CCUR, 0); }
		public ITerminalNode LENB() { return GetToken(VBAConditionalCompilationParser.LENB, 0); }
		public ITerminalNode CBOOL() { return GetToken(VBAConditionalCompilationParser.CBOOL, 0); }
		public ITerminalNode CLNGPTR() { return GetToken(VBAConditionalCompilationParser.CLNGPTR, 0); }
		public ITerminalNode SGN() { return GetToken(VBAConditionalCompilationParser.SGN, 0); }
		public ITerminalNode CBYTE() { return GetToken(VBAConditionalCompilationParser.CBYTE, 0); }
		public ITerminalNode FIX() { return GetToken(VBAConditionalCompilationParser.FIX, 0); }
		public ITerminalNode CDBL() { return GetToken(VBAConditionalCompilationParser.CDBL, 0); }
		public ITerminalNode CVAR() { return GetToken(VBAConditionalCompilationParser.CVAR, 0); }
		public ITerminalNode CLNG() { return GetToken(VBAConditionalCompilationParser.CLNG, 0); }
		public IntrinsicFunctionNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_intrinsicFunctionName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterIntrinsicFunctionName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitIntrinsicFunctionName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIntrinsicFunctionName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IntrinsicFunctionNameContext intrinsicFunctionName() {
		IntrinsicFunctionNameContext _localctx = new IntrinsicFunctionNameContext(_ctx, State);
		EnterRule(_localctx, 40, RULE_intrinsicFunctionName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 457;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABS) | (1L << CBOOL) | (1L << CBYTE) | (1L << CCUR) | (1L << CDATE) | (1L << CDBL) | (1L << CINT) | (1L << CLNG) | (1L << CLNGLNG) | (1L << CLNGPTR) | (1L << CSNG) | (1L << CSTR) | (1L << CVAR) | (1L << FIX) | (1L << INT) | (1L << LEN) | (1L << LENB) | (1L << SGN))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NameContext : ParserRuleContext {
		public TypeHintContext typeHint() {
			return GetRuleContext<TypeHintContext>(0);
		}
		public NameValueContext nameValue() {
			return GetRuleContext<NameValueContext>(0);
		}
		public NameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NameContext name() {
		NameContext _localctx = new NameContext(_ctx, State);
		EnterRule(_localctx, 42, RULE_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 459; nameValue();
			State = 461;
			switch ( Interpreter.AdaptivePredict(_input,52,_ctx) ) {
			case 1:
				{
				State = 460; typeHint();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NameValueContext : ParserRuleContext {
		public MarkerKeywordContext markerKeyword() {
			return GetRuleContext<MarkerKeywordContext>(0);
		}
		public KeywordContext keyword() {
			return GetRuleContext<KeywordContext>(0);
		}
		public ITerminalNode IDENTIFIER() { return GetToken(VBAConditionalCompilationParser.IDENTIFIER, 0); }
		public ForeignNameContext foreignName() {
			return GetRuleContext<ForeignNameContext>(0);
		}
		public StatementKeywordContext statementKeyword() {
			return GetRuleContext<StatementKeywordContext>(0);
		}
		public NameValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nameValue; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterNameValue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitNameValue(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNameValue(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NameValueContext nameValue() {
		NameValueContext _localctx = new NameValueContext(_ctx, State);
		EnterRule(_localctx, 44, RULE_nameValue);
		try {
			State = 468;
			switch (_input.La(1)) {
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 463; Match(IDENTIFIER);
				}
				break;
			case ABS:
			case ANY:
			case ARRAY:
			case B_CHAR:
			case CBOOL:
			case CBYTE:
			case CCUR:
			case CDATE:
			case CDBL:
			case CDEC:
			case CINT:
			case CLNG:
			case CLNGLNG:
			case CLNGPTR:
			case CSNG:
			case CSTR:
			case CURRENCY:
			case CVAR:
			case CVERR:
			case DEBUG:
			case DOEVENTS:
			case FIX:
			case INPUTB:
			case INT:
			case LBOUND:
			case LEN:
			case LENB:
			case LONGLONG:
			case LONGPTR:
			case MIDB:
			case MIDBTYPESUFFIX:
			case MIDTYPESUFFIX:
			case PSET:
			case SGN:
			case UBOUND:
			case ACCESS:
			case ADDRESSOF:
			case ALIAS:
			case AND:
			case ATTRIBUTE:
			case APPEND:
			case BEGIN:
			case BINARY:
			case BOOLEAN:
			case BYVAL:
			case BYREF:
			case BYTE:
			case CLASS:
			case CLOSE:
			case DATABASE:
			case DATE:
			case DOUBLE:
			case END:
			case EQV:
			case ERROR:
			case FALSE:
			case GET:
			case IMP:
			case IN:
			case INPUT:
			case IS:
			case INTEGER:
			case LOCK:
			case LONG:
			case LIB:
			case LIKE:
			case LINE_INPUT:
			case LOCK_READ:
			case LOCK_WRITE:
			case LOCK_READ_WRITE:
			case ME:
			case MID:
			case MOD:
			case NAME:
			case NEW:
			case NOT:
			case NOTHING:
			case NULL:
			case OBJECT:
			case ON_ERROR:
			case OPEN:
			case OPTIONAL:
			case OR:
			case OUTPUT:
			case PARAMARRAY:
			case PRESERVE:
			case PRINT:
			case PTRSAFE:
			case PUT:
			case RANDOM:
			case READ:
			case READ_WRITE:
			case REM:
			case RESET:
			case SEEK:
			case SHARED:
			case SINGLE:
			case SPC:
			case STEP:
			case STRING:
			case TAB:
			case TEXT:
			case THEN:
			case TO:
			case TRUE:
			case TYPEOF:
			case UNLOCK:
			case UNTIL:
			case VARIANT:
			case VERSION:
			case WIDTH:
			case WITHEVENTS:
			case WRITE:
			case XOR:
			case LOAD:
			case RESUME_NEXT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 464; keyword();
				}
				break;
			case L_SQUARE_BRACKET:
				EnterOuterAlt(_localctx, 3);
				{
				State = 465; foreignName();
				}
				break;
			case EXIT:
			case OPTION:
			case CALL:
			case CASE:
			case CONST:
			case DECLARE:
			case DEFBOOL:
			case DEFBYTE:
			case DEFDATE:
			case DEFDBL:
			case DEFCUR:
			case DEFINT:
			case DEFLNG:
			case DEFLNGLNG:
			case DEFLNGPTR:
			case DEFOBJ:
			case DEFSNG:
			case DEFSTR:
			case DEFVAR:
			case DIM:
			case DO:
			case ELSE:
			case ELSEIF:
			case END_SELECT:
			case END_WITH:
			case ENUM:
			case ERASE:
			case EVENT:
			case EXIT_DO:
			case EXIT_FOR:
			case EXIT_FUNCTION:
			case EXIT_PROPERTY:
			case EXIT_SUB:
			case FRIEND:
			case FOR:
			case FUNCTION:
			case GLOBAL:
			case GOSUB:
			case GOTO:
			case IF:
			case IMPLEMENTS:
			case LOOP:
			case LET:
			case LSET:
			case NEXT:
			case ON:
			case PRIVATE:
			case PUBLIC:
			case RAISEEVENT:
			case REDIM:
			case RESUME:
			case RETURN:
			case RSET:
			case SELECT:
			case SET:
			case STATIC:
			case STOP:
			case SUB:
			case TYPE:
			case WEND:
			case WHILE:
			case WITH:
				EnterOuterAlt(_localctx, 4);
				{
				State = 466; statementKeyword();
				}
				break;
			case AS:
				EnterOuterAlt(_localctx, 5);
				{
				State = 467; markerKeyword();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForeignNameContext : ParserRuleContext {
		public IReadOnlyList<ForeignIdentifierContext> foreignIdentifier() {
			return GetRuleContexts<ForeignIdentifierContext>();
		}
		public ITerminalNode L_SQUARE_BRACKET() { return GetToken(VBAConditionalCompilationParser.L_SQUARE_BRACKET, 0); }
		public ForeignIdentifierContext foreignIdentifier(int i) {
			return GetRuleContext<ForeignIdentifierContext>(i);
		}
		public ITerminalNode R_SQUARE_BRACKET() { return GetToken(VBAConditionalCompilationParser.R_SQUARE_BRACKET, 0); }
		public ForeignNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_foreignName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterForeignName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitForeignName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForeignName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ForeignNameContext foreignName() {
		ForeignNameContext _localctx = new ForeignNameContext(_ctx, State);
		EnterRule(_localctx, 46, RULE_foreignName);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 470; Match(L_SQUARE_BRACKET);
			State = 474;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,54,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 471; foreignIdentifier();
					}
					} 
				}
				State = 476;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,54,_ctx);
			}
			State = 477; Match(R_SQUARE_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForeignIdentifierContext : ParserRuleContext {
		public ITerminalNode L_SQUARE_BRACKET() { return GetToken(VBAConditionalCompilationParser.L_SQUARE_BRACKET, 0); }
		public ForeignNameContext foreignName() {
			return GetRuleContext<ForeignNameContext>(0);
		}
		public ForeignIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_foreignIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterForeignIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitForeignIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForeignIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ForeignIdentifierContext foreignIdentifier() {
		ForeignIdentifierContext _localctx = new ForeignIdentifierContext(_ctx, State);
		EnterRule(_localctx, 48, RULE_foreignIdentifier);
		int _la;
		try {
			State = 481;
			switch (_input.La(1)) {
			case ABS:
			case ANY:
			case ARRAY:
			case B_CHAR:
			case BF:
			case CBOOL:
			case CBYTE:
			case CCUR:
			case CDATE:
			case CDBL:
			case CDEC:
			case CINT:
			case CIRCLE:
			case CLNG:
			case CLNGLNG:
			case CLNGPTR:
			case CSNG:
			case CSTR:
			case CURRENCY:
			case CVAR:
			case CVERR:
			case DEBUG:
			case DOEVENTS:
			case EXIT:
			case FIX:
			case INPUTB:
			case INT:
			case LBOUND:
			case LEN:
			case LENB:
			case LONGLONG:
			case LONGPTR:
			case MIDB:
			case MIDBTYPESUFFIX:
			case MIDTYPESUFFIX:
			case OPTION:
			case PSET:
			case SCALE:
			case SGN:
			case UBOUND:
			case COMMA:
			case COLON:
			case SEMICOLON:
			case EXCLAMATIONPOINT:
			case DOT:
			case HASH:
			case AT:
			case PERCENT:
			case DOLLAR:
			case AMPERSAND:
			case ACCESS:
			case ADDRESSOF:
			case ALIAS:
			case AND:
			case ATTRIBUTE:
			case APPEND:
			case AS:
			case BEGIN:
			case BINARY:
			case BOOLEAN:
			case BYVAL:
			case BYREF:
			case BYTE:
			case CALL:
			case CASE:
			case CLASS:
			case CLOSE:
			case CONST:
			case DATABASE:
			case DATE:
			case DECLARE:
			case DEFBOOL:
			case DEFBYTE:
			case DEFDATE:
			case DEFDBL:
			case DEFCUR:
			case DEFINT:
			case DEFLNG:
			case DEFLNGLNG:
			case DEFLNGPTR:
			case DEFOBJ:
			case DEFSNG:
			case DEFSTR:
			case DEFVAR:
			case DIM:
			case DO:
			case DOUBLE:
			case EACH:
			case ELSE:
			case ELSEIF:
			case EMPTY:
			case END_ENUM:
			case END_FUNCTION:
			case END_IF:
			case END_PROPERTY:
			case END_SELECT:
			case END_SUB:
			case END_TYPE:
			case END_WITH:
			case END:
			case ENUM:
			case EQV:
			case ERASE:
			case ERROR:
			case EVENT:
			case EXIT_DO:
			case EXIT_FOR:
			case EXIT_FUNCTION:
			case EXIT_PROPERTY:
			case EXIT_SUB:
			case FALSE:
			case FRIEND:
			case FOR:
			case FUNCTION:
			case GET:
			case GLOBAL:
			case GOSUB:
			case GOTO:
			case IF:
			case IMP:
			case IMPLEMENTS:
			case IN:
			case INPUT:
			case IS:
			case INTEGER:
			case LOCK:
			case LONG:
			case LOOP:
			case LET:
			case LIB:
			case LIKE:
			case LINE_INPUT:
			case LOCK_READ:
			case LOCK_WRITE:
			case LOCK_READ_WRITE:
			case LSET:
			case ME:
			case MID:
			case MOD:
			case NAME:
			case NEXT:
			case NEW:
			case NOT:
			case NOTHING:
			case NULL:
			case OBJECT:
			case ON:
			case ON_ERROR:
			case ON_LOCAL_ERROR:
			case OPEN:
			case OPTIONAL:
			case OPTION_BASE:
			case OPTION_EXPLICIT:
			case OPTION_COMPARE:
			case OPTION_PRIVATE_MODULE:
			case OR:
			case OUTPUT:
			case PARAMARRAY:
			case PRESERVE:
			case PRINT:
			case PRIVATE:
			case PROPERTY_GET:
			case PROPERTY_LET:
			case PROPERTY_SET:
			case PTRSAFE:
			case PUBLIC:
			case PUT:
			case RANDOM:
			case RAISEEVENT:
			case READ:
			case READ_WRITE:
			case REDIM:
			case REM:
			case RESET:
			case RESUME:
			case RETURN:
			case RSET:
			case SEEK:
			case SELECT:
			case SET:
			case SHARED:
			case SINGLE:
			case SPC:
			case STATIC:
			case STEP:
			case STOP:
			case STRING:
			case SUB:
			case TAB:
			case TEXT:
			case THEN:
			case TO:
			case TRUE:
			case TYPE:
			case TYPEOF:
			case UNLOCK:
			case UNTIL:
			case VARIANT:
			case VERSION:
			case WEND:
			case WHILE:
			case WIDTH:
			case WITH:
			case WITHEVENTS:
			case WRITE:
			case XOR:
			case ASSIGN:
			case DIV:
			case INTDIV:
			case EQ:
			case GEQ:
			case GT:
			case LEQ:
			case LPAREN:
			case LT:
			case MINUS:
			case MULT:
			case NEQ:
			case PLUS:
			case POW:
			case RPAREN:
			case R_SQUARE_BRACKET:
			case STRINGLITERAL:
			case OCTLITERAL:
			case HEXLITERAL:
			case FLOATLITERAL:
			case INTEGERLITERAL:
			case DATELITERAL:
			case NEWLINE:
			case SINGLEQUOTE:
			case UNDERSCORE:
			case WS:
			case GUIDLITERAL:
			case IDENTIFIER:
			case LINE_CONTINUATION:
			case ERRORCHAR:
			case LOAD:
			case RESUME_NEXT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 479;
				_la = _input.La(1);
				if ( _la <= 0 || (_la==L_SQUARE_BRACKET) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				}
				break;
			case L_SQUARE_BRACKET:
				EnterOuterAlt(_localctx, 2);
				{
				State = 480; foreignName();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeHintContext : ParserRuleContext {
		public ITerminalNode AT() { return GetToken(VBAConditionalCompilationParser.AT, 0); }
		public ITerminalNode DOLLAR() { return GetToken(VBAConditionalCompilationParser.DOLLAR, 0); }
		public ITerminalNode EXCLAMATIONPOINT() { return GetToken(VBAConditionalCompilationParser.EXCLAMATIONPOINT, 0); }
		public ITerminalNode AMPERSAND() { return GetToken(VBAConditionalCompilationParser.AMPERSAND, 0); }
		public ITerminalNode PERCENT() { return GetToken(VBAConditionalCompilationParser.PERCENT, 0); }
		public ITerminalNode POW() { return GetToken(VBAConditionalCompilationParser.POW, 0); }
		public ITerminalNode HASH() { return GetToken(VBAConditionalCompilationParser.HASH, 0); }
		public TypeHintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeHint; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterTypeHint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitTypeHint(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeHint(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeHintContext typeHint() {
		TypeHintContext _localctx = new TypeHintContext(_ctx, State);
		EnterRule(_localctx, 50, RULE_typeHint);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 483;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << EXCLAMATIONPOINT) | (1L << HASH) | (1L << AT) | (1L << PERCENT) | (1L << DOLLAR) | (1L << AMPERSAND))) != 0) || _la==POW) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralContext : ParserRuleContext {
		public ITerminalNode INTEGERLITERAL() { return GetToken(VBAConditionalCompilationParser.INTEGERLITERAL, 0); }
		public ITerminalNode NULL() { return GetToken(VBAConditionalCompilationParser.NULL, 0); }
		public ITerminalNode STRINGLITERAL() { return GetToken(VBAConditionalCompilationParser.STRINGLITERAL, 0); }
		public ITerminalNode FALSE() { return GetToken(VBAConditionalCompilationParser.FALSE, 0); }
		public ITerminalNode TRUE() { return GetToken(VBAConditionalCompilationParser.TRUE, 0); }
		public ITerminalNode NOTHING() { return GetToken(VBAConditionalCompilationParser.NOTHING, 0); }
		public ITerminalNode DATELITERAL() { return GetToken(VBAConditionalCompilationParser.DATELITERAL, 0); }
		public ITerminalNode FLOATLITERAL() { return GetToken(VBAConditionalCompilationParser.FLOATLITERAL, 0); }
		public ITerminalNode HEXLITERAL() { return GetToken(VBAConditionalCompilationParser.HEXLITERAL, 0); }
		public ITerminalNode EMPTY() { return GetToken(VBAConditionalCompilationParser.EMPTY, 0); }
		public ITerminalNode OCTLITERAL() { return GetToken(VBAConditionalCompilationParser.OCTLITERAL, 0); }
		public LiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literal; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitLiteral(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralContext literal() {
		LiteralContext _localctx = new LiteralContext(_ctx, State);
		EnterRule(_localctx, 52, RULE_literal);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 485;
			_la = _input.La(1);
			if ( !(((((_la - 91)) & ~0x3f) == 0 && ((1L << (_la - 91)) & ((1L << (EMPTY - 91)) | (1L << (FALSE - 91)) | (1L << (NOTHING - 91)) | (1L << (NULL - 91)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (TRUE - 193)) | (1L << (STRINGLITERAL - 193)) | (1L << (OCTLITERAL - 193)) | (1L << (HEXLITERAL - 193)) | (1L << (FLOATLITERAL - 193)) | (1L << (INTEGERLITERAL - 193)) | (1L << (DATELITERAL - 193)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommentContext : ParserRuleContext {
		public ITerminalNode SINGLEQUOTE() { return GetToken(VBAConditionalCompilationParser.SINGLEQUOTE, 0); }
		public IReadOnlyList<ITerminalNode> LINE_CONTINUATION() { return GetTokens(VBAConditionalCompilationParser.LINE_CONTINUATION); }
		public IReadOnlyList<ITerminalNode> NEWLINE() { return GetTokens(VBAConditionalCompilationParser.NEWLINE); }
		public ITerminalNode NEWLINE(int i) {
			return GetToken(VBAConditionalCompilationParser.NEWLINE, i);
		}
		public ITerminalNode LINE_CONTINUATION(int i) {
			return GetToken(VBAConditionalCompilationParser.LINE_CONTINUATION, i);
		}
		public CommentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_comment; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterComment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitComment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitComment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CommentContext comment() {
		CommentContext _localctx = new CommentContext(_ctx, State);
		EnterRule(_localctx, 54, RULE_comment);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 487; Match(SINGLEQUOTE);
			State = 492;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABS) | (1L << ANY) | (1L << ARRAY) | (1L << B_CHAR) | (1L << BF) | (1L << CBOOL) | (1L << CBYTE) | (1L << CCUR) | (1L << CDATE) | (1L << CDBL) | (1L << CDEC) | (1L << CINT) | (1L << CIRCLE) | (1L << CLNG) | (1L << CLNGLNG) | (1L << CLNGPTR) | (1L << CSNG) | (1L << CSTR) | (1L << CURRENCY) | (1L << CVAR) | (1L << CVERR) | (1L << DEBUG) | (1L << DOEVENTS) | (1L << EXIT) | (1L << FIX) | (1L << INPUTB) | (1L << INT) | (1L << LBOUND) | (1L << LEN) | (1L << LENB) | (1L << LONGLONG) | (1L << LONGPTR) | (1L << MIDB) | (1L << MIDBTYPESUFFIX) | (1L << MIDTYPESUFFIX) | (1L << OPTION) | (1L << PSET) | (1L << SCALE) | (1L << SGN) | (1L << UBOUND) | (1L << COMMA) | (1L << COLON) | (1L << SEMICOLON) | (1L << EXCLAMATIONPOINT) | (1L << DOT) | (1L << HASH) | (1L << AT) | (1L << PERCENT) | (1L << DOLLAR) | (1L << AMPERSAND) | (1L << ACCESS) | (1L << ADDRESSOF) | (1L << ALIAS) | (1L << AND) | (1L << ATTRIBUTE) | (1L << APPEND) | (1L << AS) | (1L << BEGIN) | (1L << BINARY) | (1L << BOOLEAN) | (1L << BYVAL) | (1L << BYREF) | (1L << BYTE))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CALL - 64)) | (1L << (CASE - 64)) | (1L << (CLASS - 64)) | (1L << (CLOSE - 64)) | (1L << (CONST - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DECLARE - 64)) | (1L << (DEFBOOL - 64)) | (1L << (DEFBYTE - 64)) | (1L << (DEFDATE - 64)) | (1L << (DEFDBL - 64)) | (1L << (DEFCUR - 64)) | (1L << (DEFINT - 64)) | (1L << (DEFLNG - 64)) | (1L << (DEFLNGLNG - 64)) | (1L << (DEFLNGPTR - 64)) | (1L << (DEFOBJ - 64)) | (1L << (DEFSNG - 64)) | (1L << (DEFSTR - 64)) | (1L << (DEFVAR - 64)) | (1L << (DIM - 64)) | (1L << (DO - 64)) | (1L << (DOUBLE - 64)) | (1L << (EACH - 64)) | (1L << (ELSE - 64)) | (1L << (ELSEIF - 64)) | (1L << (EMPTY - 64)) | (1L << (END_ENUM - 64)) | (1L << (END_FUNCTION - 64)) | (1L << (END_IF - 64)) | (1L << (END_PROPERTY - 64)) | (1L << (END_SELECT - 64)) | (1L << (END_SUB - 64)) | (1L << (END_TYPE - 64)) | (1L << (END_WITH - 64)) | (1L << (END - 64)) | (1L << (ENUM - 64)) | (1L << (EQV - 64)) | (1L << (ERASE - 64)) | (1L << (ERROR - 64)) | (1L << (EVENT - 64)) | (1L << (EXIT_DO - 64)) | (1L << (EXIT_FOR - 64)) | (1L << (EXIT_FUNCTION - 64)) | (1L << (EXIT_PROPERTY - 64)) | (1L << (EXIT_SUB - 64)) | (1L << (FALSE - 64)) | (1L << (FRIEND - 64)) | (1L << (FOR - 64)) | (1L << (FUNCTION - 64)) | (1L << (GET - 64)) | (1L << (GLOBAL - 64)) | (1L << (GOSUB - 64)) | (1L << (GOTO - 64)) | (1L << (IF - 64)) | (1L << (IMP - 64)) | (1L << (IMPLEMENTS - 64)) | (1L << (IN - 64)) | (1L << (INPUT - 64)) | (1L << (IS - 64)) | (1L << (INTEGER - 64)) | (1L << (LOCK - 64)) | (1L << (LONG - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (LOOP - 128)) | (1L << (LET - 128)) | (1L << (LIB - 128)) | (1L << (LIKE - 128)) | (1L << (LINE_INPUT - 128)) | (1L << (LOCK_READ - 128)) | (1L << (LOCK_WRITE - 128)) | (1L << (LOCK_READ_WRITE - 128)) | (1L << (LSET - 128)) | (1L << (ME - 128)) | (1L << (MID - 128)) | (1L << (MOD - 128)) | (1L << (NAME - 128)) | (1L << (NEXT - 128)) | (1L << (NEW - 128)) | (1L << (NOT - 128)) | (1L << (NOTHING - 128)) | (1L << (NULL - 128)) | (1L << (OBJECT - 128)) | (1L << (ON - 128)) | (1L << (ON_ERROR - 128)) | (1L << (ON_LOCAL_ERROR - 128)) | (1L << (OPEN - 128)) | (1L << (OPTIONAL - 128)) | (1L << (OPTION_BASE - 128)) | (1L << (OPTION_EXPLICIT - 128)) | (1L << (OPTION_COMPARE - 128)) | (1L << (OPTION_PRIVATE_MODULE - 128)) | (1L << (OR - 128)) | (1L << (OUTPUT - 128)) | (1L << (PARAMARRAY - 128)) | (1L << (PRESERVE - 128)) | (1L << (PRINT - 128)) | (1L << (PRIVATE - 128)) | (1L << (PROPERTY_GET - 128)) | (1L << (PROPERTY_LET - 128)) | (1L << (PROPERTY_SET - 128)) | (1L << (PTRSAFE - 128)) | (1L << (PUBLIC - 128)) | (1L << (PUT - 128)) | (1L << (RANDOM - 128)) | (1L << (RAISEEVENT - 128)) | (1L << (READ - 128)) | (1L << (READ_WRITE - 128)) | (1L << (REDIM - 128)) | (1L << (REM - 128)) | (1L << (RESET - 128)) | (1L << (RESUME - 128)) | (1L << (RETURN - 128)) | (1L << (RSET - 128)) | (1L << (SEEK - 128)) | (1L << (SELECT - 128)) | (1L << (SET - 128)) | (1L << (SHARED - 128)) | (1L << (SINGLE - 128)) | (1L << (SPC - 128)) | (1L << (STATIC - 128)) | (1L << (STEP - 128)) | (1L << (STOP - 128)) | (1L << (STRING - 128)) | (1L << (SUB - 128)) | (1L << (TAB - 128)) | (1L << (TEXT - 128)) | (1L << (THEN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (TO - 192)) | (1L << (TRUE - 192)) | (1L << (TYPE - 192)) | (1L << (TYPEOF - 192)) | (1L << (UNLOCK - 192)) | (1L << (UNTIL - 192)) | (1L << (VARIANT - 192)) | (1L << (VERSION - 192)) | (1L << (WEND - 192)) | (1L << (WHILE - 192)) | (1L << (WIDTH - 192)) | (1L << (WITH - 192)) | (1L << (WITHEVENTS - 192)) | (1L << (WRITE - 192)) | (1L << (XOR - 192)) | (1L << (ASSIGN - 192)) | (1L << (DIV - 192)) | (1L << (INTDIV - 192)) | (1L << (EQ - 192)) | (1L << (GEQ - 192)) | (1L << (GT - 192)) | (1L << (LEQ - 192)) | (1L << (LPAREN - 192)) | (1L << (LT - 192)) | (1L << (MINUS - 192)) | (1L << (MULT - 192)) | (1L << (NEQ - 192)) | (1L << (PLUS - 192)) | (1L << (POW - 192)) | (1L << (RPAREN - 192)) | (1L << (L_SQUARE_BRACKET - 192)) | (1L << (R_SQUARE_BRACKET - 192)) | (1L << (STRINGLITERAL - 192)) | (1L << (OCTLITERAL - 192)) | (1L << (HEXLITERAL - 192)) | (1L << (FLOATLITERAL - 192)) | (1L << (INTEGERLITERAL - 192)) | (1L << (DATELITERAL - 192)) | (1L << (SINGLEQUOTE - 192)) | (1L << (UNDERSCORE - 192)) | (1L << (WS - 192)) | (1L << (GUIDLITERAL - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (LINE_CONTINUATION - 192)) | (1L << (ERRORCHAR - 192)) | (1L << (LOAD - 192)) | (1L << (RESUME_NEXT - 192)))) != 0)) {
				{
				State = 490;
				switch ( Interpreter.AdaptivePredict(_input,56,_ctx) ) {
				case 1:
					{
					State = 488; Match(LINE_CONTINUATION);
					}
					break;

				case 2:
					{
					State = 489;
					_la = _input.La(1);
					if ( _la <= 0 || (_la==NEWLINE) ) {
					_errHandler.RecoverInline(this);
					}
					Consume();
					}
					break;
				}
				}
				State = 494;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeywordContext : ParserRuleContext {
		public ITerminalNode CLNGLNG() { return GetToken(VBAConditionalCompilationParser.CLNGLNG, 0); }
		public ITerminalNode RESET() { return GetToken(VBAConditionalCompilationParser.RESET, 0); }
		public ITerminalNode XOR() { return GetToken(VBAConditionalCompilationParser.XOR, 0); }
		public ITerminalNode LOAD() { return GetToken(VBAConditionalCompilationParser.LOAD, 0); }
		public ITerminalNode MIDTYPESUFFIX() { return GetToken(VBAConditionalCompilationParser.MIDTYPESUFFIX, 0); }
		public ITerminalNode BYREF() { return GetToken(VBAConditionalCompilationParser.BYREF, 0); }
		public ITerminalNode DEBUG() { return GetToken(VBAConditionalCompilationParser.DEBUG, 0); }
		public ITerminalNode CLNGPTR() { return GetToken(VBAConditionalCompilationParser.CLNGPTR, 0); }
		public ITerminalNode PARAMARRAY() { return GetToken(VBAConditionalCompilationParser.PARAMARRAY, 0); }
		public ITerminalNode ME() { return GetToken(VBAConditionalCompilationParser.ME, 0); }
		public ITerminalNode CDEC() { return GetToken(VBAConditionalCompilationParser.CDEC, 0); }
		public ITerminalNode WIDTH() { return GetToken(VBAConditionalCompilationParser.WIDTH, 0); }
		public ITerminalNode CSNG() { return GetToken(VBAConditionalCompilationParser.CSNG, 0); }
		public ITerminalNode LONGPTR() { return GetToken(VBAConditionalCompilationParser.LONGPTR, 0); }
		public ITerminalNode STRING() { return GetToken(VBAConditionalCompilationParser.STRING, 0); }
		public ITerminalNode MOD() { return GetToken(VBAConditionalCompilationParser.MOD, 0); }
		public ITerminalNode OR() { return GetToken(VBAConditionalCompilationParser.OR, 0); }
		public ITerminalNode DOUBLE() { return GetToken(VBAConditionalCompilationParser.DOUBLE, 0); }
		public ITerminalNode BYVAL() { return GetToken(VBAConditionalCompilationParser.BYVAL, 0); }
		public ITerminalNode IN() { return GetToken(VBAConditionalCompilationParser.IN, 0); }
		public ITerminalNode BINARY() { return GetToken(VBAConditionalCompilationParser.BINARY, 0); }
		public ITerminalNode TEXT() { return GetToken(VBAConditionalCompilationParser.TEXT, 0); }
		public ITerminalNode MIDBTYPESUFFIX() { return GetToken(VBAConditionalCompilationParser.MIDBTYPESUFFIX, 0); }
		public ITerminalNode SGN() { return GetToken(VBAConditionalCompilationParser.SGN, 0); }
		public ITerminalNode CBYTE() { return GetToken(VBAConditionalCompilationParser.CBYTE, 0); }
		public ITerminalNode PUT() { return GetToken(VBAConditionalCompilationParser.PUT, 0); }
		public ITerminalNode CVAR() { return GetToken(VBAConditionalCompilationParser.CVAR, 0); }
		public ITerminalNode SINGLE() { return GetToken(VBAConditionalCompilationParser.SINGLE, 0); }
		public ITerminalNode LONGLONG() { return GetToken(VBAConditionalCompilationParser.LONGLONG, 0); }
		public ITerminalNode CDATE() { return GetToken(VBAConditionalCompilationParser.CDATE, 0); }
		public ITerminalNode ERROR() { return GetToken(VBAConditionalCompilationParser.ERROR, 0); }
		public ITerminalNode ABS() { return GetToken(VBAConditionalCompilationParser.ABS, 0); }
		public ITerminalNode SPC() { return GetToken(VBAConditionalCompilationParser.SPC, 0); }
		public ITerminalNode INT() { return GetToken(VBAConditionalCompilationParser.INT, 0); }
		public ITerminalNode RESUME_NEXT() { return GetToken(VBAConditionalCompilationParser.RESUME_NEXT, 0); }
		public ITerminalNode NOT() { return GetToken(VBAConditionalCompilationParser.NOT, 0); }
		public ITerminalNode LBOUND() { return GetToken(VBAConditionalCompilationParser.LBOUND, 0); }
		public ITerminalNode UBOUND() { return GetToken(VBAConditionalCompilationParser.UBOUND, 0); }
		public ITerminalNode OUTPUT() { return GetToken(VBAConditionalCompilationParser.OUTPUT, 0); }
		public ITerminalNode LINE_INPUT() { return GetToken(VBAConditionalCompilationParser.LINE_INPUT, 0); }
		public ITerminalNode ARRAY() { return GetToken(VBAConditionalCompilationParser.ARRAY, 0); }
		public ITerminalNode VERSION() { return GetToken(VBAConditionalCompilationParser.VERSION, 0); }
		public ITerminalNode PTRSAFE() { return GetToken(VBAConditionalCompilationParser.PTRSAFE, 0); }
		public ITerminalNode ACCESS() { return GetToken(VBAConditionalCompilationParser.ACCESS, 0); }
		public ITerminalNode TRUE() { return GetToken(VBAConditionalCompilationParser.TRUE, 0); }
		public ITerminalNode VARIANT() { return GetToken(VBAConditionalCompilationParser.VARIANT, 0); }
		public ITerminalNode MIDB() { return GetToken(VBAConditionalCompilationParser.MIDB, 0); }
		public ITerminalNode BOOLEAN() { return GetToken(VBAConditionalCompilationParser.BOOLEAN, 0); }
		public ITerminalNode LONG() { return GetToken(VBAConditionalCompilationParser.LONG, 0); }
		public ITerminalNode REM() { return GetToken(VBAConditionalCompilationParser.REM, 0); }
		public ITerminalNode ADDRESSOF() { return GetToken(VBAConditionalCompilationParser.ADDRESSOF, 0); }
		public ITerminalNode ATTRIBUTE() { return GetToken(VBAConditionalCompilationParser.ATTRIBUTE, 0); }
		public ITerminalNode TYPEOF() { return GetToken(VBAConditionalCompilationParser.TYPEOF, 0); }
		public ITerminalNode PSET() { return GetToken(VBAConditionalCompilationParser.PSET, 0); }
		public ITerminalNode UNLOCK() { return GetToken(VBAConditionalCompilationParser.UNLOCK, 0); }
		public ITerminalNode CDBL() { return GetToken(VBAConditionalCompilationParser.CDBL, 0); }
		public ITerminalNode CLNG() { return GetToken(VBAConditionalCompilationParser.CLNG, 0); }
		public ITerminalNode LOCK_WRITE() { return GetToken(VBAConditionalCompilationParser.LOCK_WRITE, 0); }
		public ITerminalNode INTEGER() { return GetToken(VBAConditionalCompilationParser.INTEGER, 0); }
		public ITerminalNode ON_ERROR() { return GetToken(VBAConditionalCompilationParser.ON_ERROR, 0); }
		public ITerminalNode WRITE(int i) {
			return GetToken(VBAConditionalCompilationParser.WRITE, i);
		}
		public ITerminalNode FALSE() { return GetToken(VBAConditionalCompilationParser.FALSE, 0); }
		public ITerminalNode PRESERVE() { return GetToken(VBAConditionalCompilationParser.PRESERVE, 0); }
		public ITerminalNode SHARED() { return GetToken(VBAConditionalCompilationParser.SHARED, 0); }
		public ITerminalNode LENB() { return GetToken(VBAConditionalCompilationParser.LENB, 0); }
		public ITerminalNode APPEND() { return GetToken(VBAConditionalCompilationParser.APPEND, 0); }
		public ITerminalNode NULL() { return GetToken(VBAConditionalCompilationParser.NULL, 0); }
		public ITerminalNode NAME() { return GetToken(VBAConditionalCompilationParser.NAME, 0); }
		public ITerminalNode BEGIN() { return GetToken(VBAConditionalCompilationParser.BEGIN, 0); }
		public ITerminalNode LOCK() { return GetToken(VBAConditionalCompilationParser.LOCK, 0); }
		public ITerminalNode IMP() { return GetToken(VBAConditionalCompilationParser.IMP, 0); }
		public ITerminalNode INPUTB() { return GetToken(VBAConditionalCompilationParser.INPUTB, 0); }
		public ITerminalNode PRINT() { return GetToken(VBAConditionalCompilationParser.PRINT, 0); }
		public ITerminalNode NOTHING() { return GetToken(VBAConditionalCompilationParser.NOTHING, 0); }
		public ITerminalNode THEN() { return GetToken(VBAConditionalCompilationParser.THEN, 0); }
		public ITerminalNode DATABASE() { return GetToken(VBAConditionalCompilationParser.DATABASE, 0); }
		public ITerminalNode BYTE() { return GetToken(VBAConditionalCompilationParser.BYTE, 0); }
		public ITerminalNode STEP() { return GetToken(VBAConditionalCompilationParser.STEP, 0); }
		public ITerminalNode INPUT() { return GetToken(VBAConditionalCompilationParser.INPUT, 0); }
		public ITerminalNode SEEK() { return GetToken(VBAConditionalCompilationParser.SEEK, 0); }
		public ITerminalNode CURRENCY() { return GetToken(VBAConditionalCompilationParser.CURRENCY, 0); }
		public ITerminalNode LEN(int i) {
			return GetToken(VBAConditionalCompilationParser.LEN, i);
		}
		public ITerminalNode TAB() { return GetToken(VBAConditionalCompilationParser.TAB, 0); }
		public ITerminalNode RANDOM() { return GetToken(VBAConditionalCompilationParser.RANDOM, 0); }
		public ITerminalNode CBOOL() { return GetToken(VBAConditionalCompilationParser.CBOOL, 0); }
		public ITerminalNode B_CHAR() { return GetToken(VBAConditionalCompilationParser.B_CHAR, 0); }
		public ITerminalNode IS() { return GetToken(VBAConditionalCompilationParser.IS, 0); }
		public ITerminalNode ALIAS() { return GetToken(VBAConditionalCompilationParser.ALIAS, 0); }
		public ITerminalNode CVERR() { return GetToken(VBAConditionalCompilationParser.CVERR, 0); }
		public ITerminalNode DATE() { return GetToken(VBAConditionalCompilationParser.DATE, 0); }
		public ITerminalNode FIX() { return GetToken(VBAConditionalCompilationParser.FIX, 0); }
		public ITerminalNode CLASS() { return GetToken(VBAConditionalCompilationParser.CLASS, 0); }
		public ITerminalNode CSTR() { return GetToken(VBAConditionalCompilationParser.CSTR, 0); }
		public ITerminalNode CINT() { return GetToken(VBAConditionalCompilationParser.CINT, 0); }
		public ITerminalNode OBJECT() { return GetToken(VBAConditionalCompilationParser.OBJECT, 0); }
		public ITerminalNode EQV() { return GetToken(VBAConditionalCompilationParser.EQV, 0); }
		public ITerminalNode TO() { return GetToken(VBAConditionalCompilationParser.TO, 0); }
		public ITerminalNode READ() { return GetToken(VBAConditionalCompilationParser.READ, 0); }
		public ITerminalNode OPEN() { return GetToken(VBAConditionalCompilationParser.OPEN, 0); }
		public ITerminalNode LOCK_READ() { return GetToken(VBAConditionalCompilationParser.LOCK_READ, 0); }
		public ITerminalNode DOEVENTS() { return GetToken(VBAConditionalCompilationParser.DOEVENTS, 0); }
		public ITerminalNode CLOSE() { return GetToken(VBAConditionalCompilationParser.CLOSE, 0); }
		public ITerminalNode AND() { return GetToken(VBAConditionalCompilationParser.AND, 0); }
		public ITerminalNode MID() { return GetToken(VBAConditionalCompilationParser.MID, 0); }
		public ITerminalNode LOCK_READ_WRITE() { return GetToken(VBAConditionalCompilationParser.LOCK_READ_WRITE, 0); }
		public IReadOnlyList<ITerminalNode> WRITE() { return GetTokens(VBAConditionalCompilationParser.WRITE); }
		public IReadOnlyList<ITerminalNode> LEN() { return GetTokens(VBAConditionalCompilationParser.LEN); }
		public ITerminalNode ANY() { return GetToken(VBAConditionalCompilationParser.ANY, 0); }
		public ITerminalNode CCUR() { return GetToken(VBAConditionalCompilationParser.CCUR, 0); }
		public ITerminalNode NEW() { return GetToken(VBAConditionalCompilationParser.NEW, 0); }
		public ITerminalNode GET() { return GetToken(VBAConditionalCompilationParser.GET, 0); }
		public ITerminalNode LIB() { return GetToken(VBAConditionalCompilationParser.LIB, 0); }
		public ITerminalNode OPTIONAL() { return GetToken(VBAConditionalCompilationParser.OPTIONAL, 0); }
		public ITerminalNode END() { return GetToken(VBAConditionalCompilationParser.END, 0); }
		public ITerminalNode UNTIL() { return GetToken(VBAConditionalCompilationParser.UNTIL, 0); }
		public ITerminalNode LIKE() { return GetToken(VBAConditionalCompilationParser.LIKE, 0); }
		public ITerminalNode READ_WRITE() { return GetToken(VBAConditionalCompilationParser.READ_WRITE, 0); }
		public ITerminalNode WITHEVENTS() { return GetToken(VBAConditionalCompilationParser.WITHEVENTS, 0); }
		public KeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitKeyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public KeywordContext keyword() {
		KeywordContext _localctx = new KeywordContext(_ctx, State);
		EnterRule(_localctx, 56, RULE_keyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 495;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABS) | (1L << ANY) | (1L << ARRAY) | (1L << B_CHAR) | (1L << CBOOL) | (1L << CBYTE) | (1L << CCUR) | (1L << CDATE) | (1L << CDBL) | (1L << CDEC) | (1L << CINT) | (1L << CLNG) | (1L << CLNGLNG) | (1L << CLNGPTR) | (1L << CSNG) | (1L << CSTR) | (1L << CURRENCY) | (1L << CVAR) | (1L << CVERR) | (1L << DEBUG) | (1L << DOEVENTS) | (1L << FIX) | (1L << INPUTB) | (1L << INT) | (1L << LBOUND) | (1L << LEN) | (1L << LENB) | (1L << LONGLONG) | (1L << LONGPTR) | (1L << MIDB) | (1L << MIDBTYPESUFFIX) | (1L << MIDTYPESUFFIX) | (1L << PSET) | (1L << SGN) | (1L << UBOUND) | (1L << ACCESS) | (1L << ADDRESSOF) | (1L << ALIAS) | (1L << AND) | (1L << ATTRIBUTE) | (1L << APPEND) | (1L << BEGIN) | (1L << BINARY) | (1L << BOOLEAN) | (1L << BYVAL) | (1L << BYREF) | (1L << BYTE))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CLASS - 66)) | (1L << (CLOSE - 66)) | (1L << (DATABASE - 66)) | (1L << (DATE - 66)) | (1L << (DOUBLE - 66)) | (1L << (END - 66)) | (1L << (EQV - 66)) | (1L << (ERROR - 66)) | (1L << (FALSE - 66)) | (1L << (GET - 66)) | (1L << (IMP - 66)) | (1L << (IN - 66)) | (1L << (INPUT - 66)) | (1L << (IS - 66)) | (1L << (INTEGER - 66)) | (1L << (LOCK - 66)) | (1L << (LONG - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (LIB - 130)) | (1L << (LIKE - 130)) | (1L << (LINE_INPUT - 130)) | (1L << (LOCK_READ - 130)) | (1L << (LOCK_WRITE - 130)) | (1L << (LOCK_READ_WRITE - 130)) | (1L << (ME - 130)) | (1L << (MID - 130)) | (1L << (MOD - 130)) | (1L << (NAME - 130)) | (1L << (NEW - 130)) | (1L << (NOT - 130)) | (1L << (NOTHING - 130)) | (1L << (NULL - 130)) | (1L << (OBJECT - 130)) | (1L << (ON_ERROR - 130)) | (1L << (OPEN - 130)) | (1L << (OPTIONAL - 130)) | (1L << (OR - 130)) | (1L << (OUTPUT - 130)) | (1L << (PARAMARRAY - 130)) | (1L << (PRESERVE - 130)) | (1L << (PRINT - 130)) | (1L << (PTRSAFE - 130)) | (1L << (PUT - 130)) | (1L << (RANDOM - 130)) | (1L << (READ - 130)) | (1L << (READ_WRITE - 130)) | (1L << (REM - 130)) | (1L << (RESET - 130)) | (1L << (SEEK - 130)) | (1L << (SHARED - 130)) | (1L << (SINGLE - 130)) | (1L << (SPC - 130)) | (1L << (STEP - 130)) | (1L << (STRING - 130)) | (1L << (TAB - 130)) | (1L << (TEXT - 130)) | (1L << (THEN - 130)) | (1L << (TO - 130)) | (1L << (TRUE - 130)))) != 0) || ((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (TYPEOF - 195)) | (1L << (UNLOCK - 195)) | (1L << (UNTIL - 195)) | (1L << (VARIANT - 195)) | (1L << (VERSION - 195)) | (1L << (WIDTH - 195)) | (1L << (WITHEVENTS - 195)) | (1L << (WRITE - 195)) | (1L << (XOR - 195)) | (1L << (LOAD - 195)) | (1L << (RESUME_NEXT - 195)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MarkerKeywordContext : ParserRuleContext {
		public ITerminalNode AS() { return GetToken(VBAConditionalCompilationParser.AS, 0); }
		public MarkerKeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_markerKeyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterMarkerKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitMarkerKeyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMarkerKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MarkerKeywordContext markerKeyword() {
		MarkerKeywordContext _localctx = new MarkerKeywordContext(_ctx, State);
		EnterRule(_localctx, 58, RULE_markerKeyword);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 497; Match(AS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementKeywordContext : ParserRuleContext {
		public ITerminalNode CASE() { return GetToken(VBAConditionalCompilationParser.CASE, 0); }
		public ITerminalNode DEFOBJ() { return GetToken(VBAConditionalCompilationParser.DEFOBJ, 0); }
		public ITerminalNode ELSE() { return GetToken(VBAConditionalCompilationParser.ELSE, 0); }
		public ITerminalNode IF() { return GetToken(VBAConditionalCompilationParser.IF, 0); }
		public ITerminalNode ERASE() { return GetToken(VBAConditionalCompilationParser.ERASE, 0); }
		public ITerminalNode END_SELECT() { return GetToken(VBAConditionalCompilationParser.END_SELECT, 0); }
		public ITerminalNode RAISEEVENT() { return GetToken(VBAConditionalCompilationParser.RAISEEVENT, 0); }
		public ITerminalNode STOP() { return GetToken(VBAConditionalCompilationParser.STOP, 0); }
		public ITerminalNode PRIVATE() { return GetToken(VBAConditionalCompilationParser.PRIVATE, 0); }
		public ITerminalNode DEFBYTE() { return GetToken(VBAConditionalCompilationParser.DEFBYTE, 0); }
		public ITerminalNode DEFSNG() { return GetToken(VBAConditionalCompilationParser.DEFSNG, 0); }
		public ITerminalNode GOSUB() { return GetToken(VBAConditionalCompilationParser.GOSUB, 0); }
		public ITerminalNode RETURN() { return GetToken(VBAConditionalCompilationParser.RETURN, 0); }
		public ITerminalNode ENUM() { return GetToken(VBAConditionalCompilationParser.ENUM, 0); }
		public ITerminalNode GLOBAL() { return GetToken(VBAConditionalCompilationParser.GLOBAL, 0); }
		public ITerminalNode WEND() { return GetToken(VBAConditionalCompilationParser.WEND, 0); }
		public ITerminalNode DEFSTR() { return GetToken(VBAConditionalCompilationParser.DEFSTR, 0); }
		public ITerminalNode DEFLNGLNG() { return GetToken(VBAConditionalCompilationParser.DEFLNGLNG, 0); }
		public ITerminalNode DEFVAR() { return GetToken(VBAConditionalCompilationParser.DEFVAR, 0); }
		public ITerminalNode EXIT_DO() { return GetToken(VBAConditionalCompilationParser.EXIT_DO, 0); }
		public ITerminalNode EVENT() { return GetToken(VBAConditionalCompilationParser.EVENT, 0); }
		public ITerminalNode CONST() { return GetToken(VBAConditionalCompilationParser.CONST, 0); }
		public ITerminalNode ELSEIF() { return GetToken(VBAConditionalCompilationParser.ELSEIF, 0); }
		public ITerminalNode DEFINT() { return GetToken(VBAConditionalCompilationParser.DEFINT, 0); }
		public ITerminalNode SUB() { return GetToken(VBAConditionalCompilationParser.SUB, 0); }
		public ITerminalNode FOR() { return GetToken(VBAConditionalCompilationParser.FOR, 0); }
		public ITerminalNode LSET() { return GetToken(VBAConditionalCompilationParser.LSET, 0); }
		public ITerminalNode LOOP() { return GetToken(VBAConditionalCompilationParser.LOOP, 0); }
		public ITerminalNode DEFCUR() { return GetToken(VBAConditionalCompilationParser.DEFCUR, 0); }
		public ITerminalNode PUBLIC() { return GetToken(VBAConditionalCompilationParser.PUBLIC, 0); }
		public ITerminalNode DEFDATE() { return GetToken(VBAConditionalCompilationParser.DEFDATE, 0); }
		public ITerminalNode LET() { return GetToken(VBAConditionalCompilationParser.LET, 0); }
		public ITerminalNode FRIEND() { return GetToken(VBAConditionalCompilationParser.FRIEND, 0); }
		public ITerminalNode TYPE() { return GetToken(VBAConditionalCompilationParser.TYPE, 0); }
		public ITerminalNode CALL() { return GetToken(VBAConditionalCompilationParser.CALL, 0); }
		public ITerminalNode DEFBOOL() { return GetToken(VBAConditionalCompilationParser.DEFBOOL, 0); }
		public ITerminalNode STATIC() { return GetToken(VBAConditionalCompilationParser.STATIC, 0); }
		public ITerminalNode DO() { return GetToken(VBAConditionalCompilationParser.DO, 0); }
		public ITerminalNode DIM() { return GetToken(VBAConditionalCompilationParser.DIM, 0); }
		public ITerminalNode OPTION() { return GetToken(VBAConditionalCompilationParser.OPTION, 0); }
		public ITerminalNode DEFLNG() { return GetToken(VBAConditionalCompilationParser.DEFLNG, 0); }
		public ITerminalNode IMPLEMENTS() { return GetToken(VBAConditionalCompilationParser.IMPLEMENTS, 0); }
		public ITerminalNode ON() { return GetToken(VBAConditionalCompilationParser.ON, 0); }
		public ITerminalNode WITH() { return GetToken(VBAConditionalCompilationParser.WITH, 0); }
		public ITerminalNode EXIT_SUB() { return GetToken(VBAConditionalCompilationParser.EXIT_SUB, 0); }
		public ITerminalNode DECLARE() { return GetToken(VBAConditionalCompilationParser.DECLARE, 0); }
		public ITerminalNode RESUME() { return GetToken(VBAConditionalCompilationParser.RESUME, 0); }
		public ITerminalNode DEFLNGPTR() { return GetToken(VBAConditionalCompilationParser.DEFLNGPTR, 0); }
		public ITerminalNode WHILE() { return GetToken(VBAConditionalCompilationParser.WHILE, 0); }
		public ITerminalNode EXIT() { return GetToken(VBAConditionalCompilationParser.EXIT, 0); }
		public ITerminalNode EXIT_FOR() { return GetToken(VBAConditionalCompilationParser.EXIT_FOR, 0); }
		public ITerminalNode DEFDBL() { return GetToken(VBAConditionalCompilationParser.DEFDBL, 0); }
		public ITerminalNode NEXT() { return GetToken(VBAConditionalCompilationParser.NEXT, 0); }
		public ITerminalNode FUNCTION() { return GetToken(VBAConditionalCompilationParser.FUNCTION, 0); }
		public ITerminalNode END_WITH() { return GetToken(VBAConditionalCompilationParser.END_WITH, 0); }
		public ITerminalNode RSET() { return GetToken(VBAConditionalCompilationParser.RSET, 0); }
		public ITerminalNode EXIT_PROPERTY() { return GetToken(VBAConditionalCompilationParser.EXIT_PROPERTY, 0); }
		public ITerminalNode GOTO() { return GetToken(VBAConditionalCompilationParser.GOTO, 0); }
		public ITerminalNode REDIM() { return GetToken(VBAConditionalCompilationParser.REDIM, 0); }
		public ITerminalNode EXIT_FUNCTION() { return GetToken(VBAConditionalCompilationParser.EXIT_FUNCTION, 0); }
		public ITerminalNode SELECT() { return GetToken(VBAConditionalCompilationParser.SELECT, 0); }
		public ITerminalNode SET() { return GetToken(VBAConditionalCompilationParser.SET, 0); }
		public StatementKeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statementKeyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterStatementKeyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitStatementKeyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatementKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementKeywordContext statementKeyword() {
		StatementKeywordContext _localctx = new StatementKeywordContext(_ctx, State);
		EnterRule(_localctx, 60, RULE_statementKeyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 499;
			_la = _input.La(1);
			if ( !(((((_la - 24)) & ~0x3f) == 0 && ((1L << (_la - 24)) & ((1L << (EXIT - 24)) | (1L << (OPTION - 24)) | (1L << (CALL - 24)) | (1L << (CASE - 24)) | (1L << (CONST - 24)) | (1L << (DECLARE - 24)) | (1L << (DEFBOOL - 24)) | (1L << (DEFBYTE - 24)) | (1L << (DEFDATE - 24)) | (1L << (DEFDBL - 24)) | (1L << (DEFCUR - 24)) | (1L << (DEFINT - 24)) | (1L << (DEFLNG - 24)) | (1L << (DEFLNGLNG - 24)) | (1L << (DEFLNGPTR - 24)) | (1L << (DEFOBJ - 24)) | (1L << (DEFSNG - 24)) | (1L << (DEFSTR - 24)) | (1L << (DEFVAR - 24)) | (1L << (DIM - 24)) | (1L << (DO - 24)))) != 0) || ((((_la - 89)) & ~0x3f) == 0 && ((1L << (_la - 89)) & ((1L << (ELSE - 89)) | (1L << (ELSEIF - 89)) | (1L << (END_SELECT - 89)) | (1L << (END_WITH - 89)) | (1L << (ENUM - 89)) | (1L << (ERASE - 89)) | (1L << (EVENT - 89)) | (1L << (EXIT_DO - 89)) | (1L << (EXIT_FOR - 89)) | (1L << (EXIT_FUNCTION - 89)) | (1L << (EXIT_PROPERTY - 89)) | (1L << (EXIT_SUB - 89)) | (1L << (FRIEND - 89)) | (1L << (FOR - 89)) | (1L << (FUNCTION - 89)) | (1L << (GLOBAL - 89)) | (1L << (GOSUB - 89)) | (1L << (GOTO - 89)) | (1L << (IF - 89)) | (1L << (IMPLEMENTS - 89)) | (1L << (LOOP - 89)) | (1L << (LET - 89)) | (1L << (LSET - 89)) | (1L << (NEXT - 89)) | (1L << (ON - 89)))) != 0) || ((((_la - 161)) & ~0x3f) == 0 && ((1L << (_la - 161)) & ((1L << (PRIVATE - 161)) | (1L << (PUBLIC - 161)) | (1L << (RAISEEVENT - 161)) | (1L << (REDIM - 161)) | (1L << (RESUME - 161)) | (1L << (RETURN - 161)) | (1L << (RSET - 161)) | (1L << (SELECT - 161)) | (1L << (SET - 161)) | (1L << (STATIC - 161)) | (1L << (STOP - 161)) | (1L << (SUB - 161)) | (1L << (TYPE - 161)) | (1L << (WEND - 161)) | (1L << (WHILE - 161)) | (1L << (WITH - 161)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 18: return ccExpression_sempred((CcExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool ccExpression_sempred(CcExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(_ctx, 17);

		case 1: return Precpred(_ctx, 15);

		case 2: return Precpred(_ctx, 14);

		case 3: return Precpred(_ctx, 13);

		case 4: return Precpred(_ctx, 12);

		case 5: return Precpred(_ctx, 11);

		case 6: return Precpred(_ctx, 10);

		case 7: return Precpred(_ctx, 8);

		case 8: return Precpred(_ctx, 7);

		case 9: return Precpred(_ctx, 6);

		case 10: return Precpred(_ctx, 5);

		case 11: return Precpred(_ctx, 4);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\xF1\x1F8\x4\x2"+
		"\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4"+
		"\t\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10"+
		"\t\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x4\x16\t\x16\x4\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B"+
		"\t\x1B\x4\x1C\t\x1C\x4\x1D\t\x1D\x4\x1E\t\x1E\x4\x1F\t\x1F\x4 \t \x3\x2"+
		"\x3\x2\x3\x2\x3\x3\x3\x3\x3\x3\a\x3G\n\x3\f\x3\xE\x3J\v\x3\x3\x4\a\x4"+
		"M\n\x4\f\x4\xE\x4P\v\x4\x3\x4\x3\x4\x6\x4T\n\x4\r\x4\xE\x4U\x3\x4\x3\x4"+
		"\a\x4Z\n\x4\f\x4\xE\x4]\v\x4\x3\x4\x3\x4\a\x4\x61\n\x4\f\x4\xE\x4\x64"+
		"\v\x4\x3\x4\x3\x4\x3\x4\x3\x5\x3\x5\x3\x6\x3\x6\x3\x6\a\x6n\n\x6\f\x6"+
		"\xE\x6q\v\x6\x3\x6\x5\x6t\n\x6\x3\x6\x3\x6\x3\a\a\ay\n\a\f\a\xE\a|\v\a"+
		"\x3\a\x3\a\x6\a\x80\n\a\r\a\xE\a\x81\x3\a\x3\a\x6\a\x86\n\a\r\a\xE\a\x87"+
		"\x3\a\x3\a\x3\a\x3\b\x3\b\x3\b\x3\t\a\t\x91\n\t\f\t\xE\t\x94\v\t\x3\t"+
		"\x3\t\x6\t\x98\n\t\r\t\xE\t\x99\x3\t\x3\t\x6\t\x9E\n\t\r\t\xE\t\x9F\x3"+
		"\t\x3\t\x3\t\x3\n\x3\n\x3\n\x3\v\a\v\xA9\n\v\f\v\xE\v\xAC\v\v\x3\v\x3"+
		"\v\x3\v\x3\f\a\f\xB2\n\f\f\f\xE\f\xB5\v\f\x3\f\x3\f\x3\f\x3\r\a\r\xBB"+
		"\n\r\f\r\xE\r\xBE\v\r\x3\r\x5\r\xC1\n\r\x3\r\x3\r\x3\xE\x3\xE\x3\xE\x3"+
		"\xF\x3\xF\x3\xF\x3\x10\x3\x10\x3\x10\x3\x11\x3\x11\x3\x11\x3\x12\x3\x12"+
		"\x3\x12\x3\x13\a\x13\xD5\n\x13\f\x13\xE\x13\xD8\v\x13\x3\x13\x3\x13\x3"+
		"\x14\x3\x14\x3\x14\a\x14\xDF\n\x14\f\x14\xE\x14\xE2\v\x14\x3\x14\x3\x14"+
		"\x3\x14\a\x14\xE7\n\x14\f\x14\xE\x14\xEA\v\x14\x3\x14\x3\x14\x3\x14\a"+
		"\x14\xEF\n\x14\f\x14\xE\x14\xF2\v\x14\x3\x14\x3\x14\a\x14\xF6\n\x14\f"+
		"\x14\xE\x14\xF9\v\x14\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\x5\x14\x100\n"+
		"\x14\x3\x14\x3\x14\a\x14\x104\n\x14\f\x14\xE\x14\x107\v\x14\x3\x14\x3"+
		"\x14\a\x14\x10B\n\x14\f\x14\xE\x14\x10E\v\x14\x3\x14\x3\x14\x3\x14\a\x14"+
		"\x113\n\x14\f\x14\xE\x14\x116\v\x14\x3\x14\x3\x14\a\x14\x11A\n\x14\f\x14"+
		"\xE\x14\x11D\v\x14\x3\x14\x3\x14\x3\x14\a\x14\x122\n\x14\f\x14\xE\x14"+
		"\x125\v\x14\x3\x14\x3\x14\a\x14\x129\n\x14\f\x14\xE\x14\x12C\v\x14\x3"+
		"\x14\x3\x14\x3\x14\a\x14\x131\n\x14\f\x14\xE\x14\x134\v\x14\x3\x14\x3"+
		"\x14\a\x14\x138\n\x14\f\x14\xE\x14\x13B\v\x14\x3\x14\x3\x14\x3\x14\a\x14"+
		"\x140\n\x14\f\x14\xE\x14\x143\v\x14\x3\x14\x3\x14\a\x14\x147\n\x14\f\x14"+
		"\xE\x14\x14A\v\x14\x3\x14\x3\x14\x3\x14\a\x14\x14F\n\x14\f\x14\xE\x14"+
		"\x152\v\x14\x3\x14\x3\x14\a\x14\x156\n\x14\f\x14\xE\x14\x159\v\x14\x3"+
		"\x14\x3\x14\x3\x14\a\x14\x15E\n\x14\f\x14\xE\x14\x161\v\x14\x3\x14\x3"+
		"\x14\a\x14\x165\n\x14\f\x14\xE\x14\x168\v\x14\x3\x14\x3\x14\x3\x14\a\x14"+
		"\x16D\n\x14\f\x14\xE\x14\x170\v\x14\x3\x14\x3\x14\a\x14\x174\n\x14\f\x14"+
		"\xE\x14\x177\v\x14\x3\x14\x3\x14\x3\x14\a\x14\x17C\n\x14\f\x14\xE\x14"+
		"\x17F\v\x14\x3\x14\x3\x14\a\x14\x183\n\x14\f\x14\xE\x14\x186\v\x14\x3"+
		"\x14\x3\x14\x3\x14\a\x14\x18B\n\x14\f\x14\xE\x14\x18E\v\x14\x3\x14\x3"+
		"\x14\a\x14\x192\n\x14\f\x14\xE\x14\x195\v\x14\x3\x14\x3\x14\x3\x14\a\x14"+
		"\x19A\n\x14\f\x14\xE\x14\x19D\v\x14\x3\x14\x3\x14\a\x14\x1A1\n\x14\f\x14"+
		"\xE\x14\x1A4\v\x14\x3\x14\x3\x14\x3\x14\a\x14\x1A9\n\x14\f\x14\xE\x14"+
		"\x1AC\v\x14\x3\x14\x3\x14\a\x14\x1B0\n\x14\f\x14\xE\x14\x1B3\v\x14\x3"+
		"\x14\a\x14\x1B6\n\x14\f\x14\xE\x14\x1B9\v\x14\x3\x15\x3\x15\x3\x15\a\x15"+
		"\x1BE\n\x15\f\x15\xE\x15\x1C1\v\x15\x3\x15\x3\x15\a\x15\x1C5\n\x15\f\x15"+
		"\xE\x15\x1C8\v\x15\x3\x15\x3\x15\x3\x16\x3\x16\x3\x17\x3\x17\x5\x17\x1D0"+
		"\n\x17\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x5\x18\x1D7\n\x18\x3\x19\x3"+
		"\x19\a\x19\x1DB\n\x19\f\x19\xE\x19\x1DE\v\x19\x3\x19\x3\x19\x3\x1A\x3"+
		"\x1A\x5\x1A\x1E4\n\x1A\x3\x1B\x3\x1B\x3\x1C\x3\x1C\x3\x1D\x3\x1D\x3\x1D"+
		"\a\x1D\x1ED\n\x1D\f\x1D\xE\x1D\x1F0\v\x1D\x3\x1E\x3\x1E\x3\x1F\x3\x1F"+
		"\x3 \x3 \x3 \x3H\x2\x3&!\x2\x2\x4\x2\x6\x2\b\x2\n\x2\f\x2\xE\x2\x10\x2"+
		"\x12\x2\x14\x2\x16\x2\x18\x2\x1A\x2\x1C\x2\x1E\x2 \x2\"\x2$\x2&\x2(\x2"+
		"*\x2,\x2.\x2\x30\x2\x32\x2\x34\x2\x36\x2\x38\x2:\x2<\x2>\x2\x2\r\x3\x3"+
		"\xE8\xE8\x4\x2\xD2\xD2\xDB\xDB\x4\x2\xDA\xDA\xDD\xDD\a\x2~~\x85\x85\xD4"+
		"\xD7\xD9\xD9\xDC\xDC\v\x2\x3\x3\b\f\xE\xE\x10\x14\x16\x16\x1B\x1B\x1D"+
		"\x1D\x1F ))\x3\x2\xE0\xE0\x5\x2..\x30\x34\xDE\xDE\a\x2]]qq\x92\x93\xC3"+
		"\xC3\xE2\xE7\x3\x2\xE8\xE8\'\x2\x3\x6\b\xE\x10\x19\x1B%\'\')*\x35:<\x41"+
		"\x44\x45GHYY\x66\x66hhjjqquuzz|\x81\x84\x89\x8B\x8E\x90\x94\x96\x96\x98"+
		"\x99\x9E\xA2\xA7\xA7\xA9\xAA\xAC\xAD\xAF\xB0\xB4\xB4\xB7\xB9\xBB\xBB\xBD"+
		"\xBD\xBF\xC3\xC5\xC9\xCC\xCC\xCE\xD0\xF0\xF1 \x2\x1A\x1A&&\x42\x43\x46"+
		"\x46IX[\\\x62\x62\x65\x65ggiikprtvy{{\x82\x83\x8A\x8A\x8F\x8F\x95\x95"+
		"\xA3\xA3\xA8\xA8\xAB\xAB\xAE\xAE\xB1\xB3\xB5\xB6\xBA\xBA\xBC\xBC\xBE\xBE"+
		"\xC4\xC4\xCA\xCB\xCD\xCD\x224\x2@\x3\x2\x2\x2\x4H\x3\x2\x2\x2\x6N\x3\x2"+
		"\x2\x2\bh\x3\x2\x2\x2\nj\x3\x2\x2\x2\fz\x3\x2\x2\x2\xE\x8C\x3\x2\x2\x2"+
		"\x10\x92\x3\x2\x2\x2\x12\xA4\x3\x2\x2\x2\x14\xAA\x3\x2\x2\x2\x16\xB3\x3"+
		"\x2\x2\x2\x18\xBC\x3\x2\x2\x2\x1A\xC4\x3\x2\x2\x2\x1C\xC7\x3\x2\x2\x2"+
		"\x1E\xCA\x3\x2\x2\x2 \xCD\x3\x2\x2\x2\"\xD0\x3\x2\x2\x2$\xD6\x3\x2\x2"+
		"\x2&\xFF\x3\x2\x2\x2(\x1BA\x3\x2\x2\x2*\x1CB\x3\x2\x2\x2,\x1CD\x3\x2\x2"+
		"\x2.\x1D6\x3\x2\x2\x2\x30\x1D8\x3\x2\x2\x2\x32\x1E3\x3\x2\x2\x2\x34\x1E5"+
		"\x3\x2\x2\x2\x36\x1E7\x3\x2\x2\x2\x38\x1E9\x3\x2\x2\x2:\x1F1\x3\x2\x2"+
		"\x2<\x1F3\x3\x2\x2\x2>\x1F5\x3\x2\x2\x2@\x41\x5\x4\x3\x2\x41\x42\a\x2"+
		"\x2\x3\x42\x3\x3\x2\x2\x2\x43G\x5\x6\x4\x2\x44G\x5\n\x6\x2\x45G\x5$\x13"+
		"\x2\x46\x43\x3\x2\x2\x2\x46\x44\x3\x2\x2\x2\x46\x45\x3\x2\x2\x2GJ\x3\x2"+
		"\x2\x2HI\x3\x2\x2\x2H\x46\x3\x2\x2\x2I\x5\x3\x2\x2\x2JH\x3\x2\x2\x2KM"+
		"\a\xEB\x2\x2LK\x3\x2\x2\x2MP\x3\x2\x2\x2NL\x3\x2\x2\x2NO\x3\x2\x2\x2O"+
		"Q\x3\x2\x2\x2PN\x3\x2\x2\x2QS\x5\x1A\xE\x2RT\a\xEB\x2\x2SR\x3\x2\x2\x2"+
		"TU\x3\x2\x2\x2US\x3\x2\x2\x2UV\x3\x2\x2\x2VW\x3\x2\x2\x2W[\x5\b\x5\x2"+
		"XZ\a\xEB\x2\x2YX\x3\x2\x2\x2Z]\x3\x2\x2\x2[Y\x3\x2\x2\x2[\\\x3\x2\x2\x2"+
		"\\^\x3\x2\x2\x2][\x3\x2\x2\x2^\x62\a\xD4\x2\x2_\x61\a\xEB\x2\x2`_\x3\x2"+
		"\x2\x2\x61\x64\x3\x2\x2\x2\x62`\x3\x2\x2\x2\x62\x63\x3\x2\x2\x2\x63\x65"+
		"\x3\x2\x2\x2\x64\x62\x3\x2\x2\x2\x65\x66\x5&\x14\x2\x66g\x5\x18\r\x2g"+
		"\a\x3\x2\x2\x2hi\x5,\x17\x2i\t\x3\x2\x2\x2jk\x5\f\a\x2ko\x5\x4\x3\x2l"+
		"n\x5\xE\b\x2ml\x3\x2\x2\x2nq\x3\x2\x2\x2om\x3\x2\x2\x2op\x3\x2\x2\x2p"+
		"s\x3\x2\x2\x2qo\x3\x2\x2\x2rt\x5\x12\n\x2sr\x3\x2\x2\x2st\x3\x2\x2\x2"+
		"tu\x3\x2\x2\x2uv\x5\x16\f\x2v\v\x3\x2\x2\x2wy\a\xEB\x2\x2xw\x3\x2\x2\x2"+
		"y|\x3\x2\x2\x2zx\x3\x2\x2\x2z{\x3\x2\x2\x2{}\x3\x2\x2\x2|z\x3\x2\x2\x2"+
		"}\x7F\x5\x1C\xF\x2~\x80\a\xEB\x2\x2\x7F~\x3\x2\x2\x2\x80\x81\x3\x2\x2"+
		"\x2\x81\x7F\x3\x2\x2\x2\x81\x82\x3\x2\x2\x2\x82\x83\x3\x2\x2\x2\x83\x85"+
		"\x5&\x14\x2\x84\x86\a\xEB\x2\x2\x85\x84\x3\x2\x2\x2\x86\x87\x3\x2\x2\x2"+
		"\x87\x85\x3\x2\x2\x2\x87\x88\x3\x2\x2\x2\x88\x89\x3\x2\x2\x2\x89\x8A\a"+
		"\xC1\x2\x2\x8A\x8B\x5\x18\r\x2\x8B\r\x3\x2\x2\x2\x8C\x8D\x5\x10\t\x2\x8D"+
		"\x8E\x5\x4\x3\x2\x8E\xF\x3\x2\x2\x2\x8F\x91\a\xEB\x2\x2\x90\x8F\x3\x2"+
		"\x2\x2\x91\x94\x3\x2\x2\x2\x92\x90\x3\x2\x2\x2\x92\x93\x3\x2\x2\x2\x93"+
		"\x95\x3\x2\x2\x2\x94\x92\x3\x2\x2\x2\x95\x97\x5\x1E\x10\x2\x96\x98\a\xEB"+
		"\x2\x2\x97\x96\x3\x2\x2\x2\x98\x99\x3\x2\x2\x2\x99\x97\x3\x2\x2\x2\x99"+
		"\x9A\x3\x2\x2\x2\x9A\x9B\x3\x2\x2\x2\x9B\x9D\x5&\x14\x2\x9C\x9E\a\xEB"+
		"\x2\x2\x9D\x9C\x3\x2\x2\x2\x9E\x9F\x3\x2\x2\x2\x9F\x9D\x3\x2\x2\x2\x9F"+
		"\xA0\x3\x2\x2\x2\xA0\xA1\x3\x2\x2\x2\xA1\xA2\a\xC1\x2\x2\xA2\xA3\x5\x18"+
		"\r\x2\xA3\x11\x3\x2\x2\x2\xA4\xA5\x5\x14\v\x2\xA5\xA6\x5\x4\x3\x2\xA6"+
		"\x13\x3\x2\x2\x2\xA7\xA9\a\xEB\x2\x2\xA8\xA7\x3\x2\x2\x2\xA9\xAC\x3\x2"+
		"\x2\x2\xAA\xA8\x3\x2\x2\x2\xAA\xAB\x3\x2\x2\x2\xAB\xAD\x3\x2\x2\x2\xAC"+
		"\xAA\x3\x2\x2\x2\xAD\xAE\x5 \x11\x2\xAE\xAF\x5\x18\r\x2\xAF\x15\x3\x2"+
		"\x2\x2\xB0\xB2\a\xEB\x2\x2\xB1\xB0\x3\x2\x2\x2\xB2\xB5\x3\x2\x2\x2\xB3"+
		"\xB1\x3\x2\x2\x2\xB3\xB4\x3\x2\x2\x2\xB4\xB6\x3\x2\x2\x2\xB5\xB3\x3\x2"+
		"\x2\x2\xB6\xB7\x5\"\x12\x2\xB7\xB8\x5\x18\r\x2\xB8\x17\x3\x2\x2\x2\xB9"+
		"\xBB\a\xEB\x2\x2\xBA\xB9\x3\x2\x2\x2\xBB\xBE\x3\x2\x2\x2\xBC\xBA\x3\x2"+
		"\x2\x2\xBC\xBD\x3\x2\x2\x2\xBD\xC0\x3\x2\x2\x2\xBE\xBC\x3\x2\x2\x2\xBF"+
		"\xC1\x5\x38\x1D\x2\xC0\xBF\x3\x2\x2\x2\xC0\xC1\x3\x2\x2\x2\xC1\xC2\x3"+
		"\x2\x2\x2\xC2\xC3\t\x2\x2\x2\xC3\x19\x3\x2\x2\x2\xC4\xC5\a\x30\x2\x2\xC5"+
		"\xC6\a\x46\x2\x2\xC6\x1B\x3\x2\x2\x2\xC7\xC8\a\x30\x2\x2\xC8\xC9\ay\x2"+
		"\x2\xC9\x1D\x3\x2\x2\x2\xCA\xCB\a\x30\x2\x2\xCB\xCC\a\\\x2\x2\xCC\x1F"+
		"\x3\x2\x2\x2\xCD\xCE\a\x30\x2\x2\xCE\xCF\a[\x2\x2\xCF!\x3\x2\x2\x2\xD0"+
		"\xD1\a\x30\x2\x2\xD1\xD2\a`\x2\x2\xD2#\x3\x2\x2\x2\xD3\xD5\n\x2\x2\x2"+
		"\xD4\xD3\x3\x2\x2\x2\xD5\xD8\x3\x2\x2\x2\xD6\xD4\x3\x2\x2\x2\xD6\xD7\x3"+
		"\x2\x2\x2\xD7\xD9\x3\x2\x2\x2\xD8\xD6\x3\x2\x2\x2\xD9\xDA\t\x2\x2\x2\xDA"+
		"%\x3\x2\x2\x2\xDB\xDC\b\x14\x1\x2\xDC\xE0\a\xDA\x2\x2\xDD\xDF\a\xEB\x2"+
		"\x2\xDE\xDD\x3\x2\x2\x2\xDF\xE2\x3\x2\x2\x2\xE0\xDE\x3\x2\x2\x2\xE0\xE1"+
		"\x3\x2\x2\x2\xE1\xE3\x3\x2\x2\x2\xE2\xE0\x3\x2\x2\x2\xE3\x100\x5&\x14"+
		"\x12\xE4\xE8\a\x91\x2\x2\xE5\xE7\a\xEB\x2\x2\xE6\xE5\x3\x2\x2\x2\xE7\xEA"+
		"\x3\x2\x2\x2\xE8\xE6\x3\x2\x2\x2\xE8\xE9\x3\x2\x2\x2\xE9\xEB\x3\x2\x2"+
		"\x2\xEA\xE8\x3\x2\x2\x2\xEB\x100\x5&\x14\v\xEC\xF0\a\xD8\x2\x2\xED\xEF"+
		"\a\xEB\x2\x2\xEE\xED\x3\x2\x2\x2\xEF\xF2\x3\x2\x2\x2\xF0\xEE\x3\x2\x2"+
		"\x2\xF0\xF1\x3\x2\x2\x2\xF1\xF3\x3\x2\x2\x2\xF2\xF0\x3\x2\x2\x2\xF3\xF7"+
		"\x5&\x14\x2\xF4\xF6\a\xEB\x2\x2\xF5\xF4\x3\x2\x2\x2\xF6\xF9\x3\x2\x2\x2"+
		"\xF7\xF5\x3\x2\x2\x2\xF7\xF8\x3\x2\x2\x2\xF8\xFA\x3\x2\x2\x2\xF9\xF7\x3"+
		"\x2\x2\x2\xFA\xFB\a\xDF\x2\x2\xFB\x100\x3\x2\x2\x2\xFC\x100\x5(\x15\x2"+
		"\xFD\x100\x5\x36\x1C\x2\xFE\x100\x5,\x17\x2\xFF\xDB\x3\x2\x2\x2\xFF\xE4"+
		"\x3\x2\x2\x2\xFF\xEC\x3\x2\x2\x2\xFF\xFC\x3\x2\x2\x2\xFF\xFD\x3\x2\x2"+
		"\x2\xFF\xFE\x3\x2\x2\x2\x100\x1B7\x3\x2\x2\x2\x101\x105\f\x13\x2\x2\x102"+
		"\x104\a\xEB\x2\x2\x103\x102\x3\x2\x2\x2\x104\x107\x3\x2\x2\x2\x105\x103"+
		"\x3\x2\x2\x2\x105\x106\x3\x2\x2\x2\x106\x108\x3\x2\x2\x2\x107\x105\x3"+
		"\x2\x2\x2\x108\x10C\a\xDE\x2\x2\x109\x10B\a\xEB\x2\x2\x10A\x109\x3\x2"+
		"\x2\x2\x10B\x10E\x3\x2\x2\x2\x10C\x10A\x3\x2\x2\x2\x10C\x10D\x3\x2\x2"+
		"\x2\x10D\x10F\x3\x2\x2\x2\x10E\x10C\x3\x2\x2\x2\x10F\x1B6\x5&\x14\x14"+
		"\x110\x114\f\x11\x2\x2\x111\x113\a\xEB\x2\x2\x112\x111\x3\x2\x2\x2\x113"+
		"\x116\x3\x2\x2\x2\x114\x112\x3\x2\x2\x2\x114\x115\x3\x2\x2\x2\x115\x117"+
		"\x3\x2\x2\x2\x116\x114\x3\x2\x2\x2\x117\x11B\t\x3\x2\x2\x118\x11A\a\xEB"+
		"\x2\x2\x119\x118\x3\x2\x2\x2\x11A\x11D\x3\x2\x2\x2\x11B\x119\x3\x2\x2"+
		"\x2\x11B\x11C\x3\x2\x2\x2\x11C\x11E\x3\x2\x2\x2\x11D\x11B\x3\x2\x2\x2"+
		"\x11E\x1B6\x5&\x14\x12\x11F\x123\f\x10\x2\x2\x120\x122\a\xEB\x2\x2\x121"+
		"\x120\x3\x2\x2\x2\x122\x125\x3\x2\x2\x2\x123\x121\x3\x2\x2\x2\x123\x124"+
		"\x3\x2\x2\x2\x124\x126\x3\x2\x2\x2\x125\x123\x3\x2\x2\x2\x126\x12A\a\xD3"+
		"\x2\x2\x127\x129\a\xEB\x2\x2\x128\x127\x3\x2\x2\x2\x129\x12C\x3\x2\x2"+
		"\x2\x12A\x128\x3\x2\x2\x2\x12A\x12B\x3\x2\x2\x2\x12B\x12D\x3\x2\x2\x2"+
		"\x12C\x12A\x3\x2\x2\x2\x12D\x1B6\x5&\x14\x11\x12E\x132\f\xF\x2\x2\x12F"+
		"\x131\a\xEB\x2\x2\x130\x12F\x3\x2\x2\x2\x131\x134\x3\x2\x2\x2\x132\x130"+
		"\x3\x2\x2\x2\x132\x133\x3\x2\x2\x2\x133\x135\x3\x2\x2\x2\x134\x132\x3"+
		"\x2\x2\x2\x135\x139\a\x8D\x2\x2\x136\x138\a\xEB\x2\x2\x137\x136\x3\x2"+
		"\x2\x2\x138\x13B\x3\x2\x2\x2\x139\x137\x3\x2\x2\x2\x139\x13A\x3\x2\x2"+
		"\x2\x13A\x13C\x3\x2\x2\x2\x13B\x139\x3\x2\x2\x2\x13C\x1B6\x5&\x14\x10"+
		"\x13D\x141\f\xE\x2\x2\x13E\x140\a\xEB\x2\x2\x13F\x13E\x3\x2\x2\x2\x140"+
		"\x143\x3\x2\x2\x2\x141\x13F\x3\x2\x2\x2\x141\x142\x3\x2\x2\x2\x142\x144"+
		"\x3\x2\x2\x2\x143\x141\x3\x2\x2\x2\x144\x148\t\x4\x2\x2\x145\x147\a\xEB"+
		"\x2\x2\x146\x145\x3\x2\x2\x2\x147\x14A\x3\x2\x2\x2\x148\x146\x3\x2\x2"+
		"\x2\x148\x149\x3\x2\x2\x2\x149\x14B\x3\x2\x2\x2\x14A\x148\x3\x2\x2\x2"+
		"\x14B\x1B6\x5&\x14\xF\x14C\x150\f\r\x2\x2\x14D\x14F\a\xEB\x2\x2\x14E\x14D"+
		"\x3\x2\x2\x2\x14F\x152\x3\x2\x2\x2\x150\x14E\x3\x2\x2\x2\x150\x151\x3"+
		"\x2\x2\x2\x151\x153\x3\x2\x2\x2\x152\x150\x3\x2\x2\x2\x153\x157\a\x34"+
		"\x2\x2\x154\x156\a\xEB\x2\x2\x155\x154\x3\x2\x2\x2\x156\x159\x3\x2\x2"+
		"\x2\x157\x155\x3\x2\x2\x2\x157\x158\x3\x2\x2\x2\x158\x15A\x3\x2\x2\x2"+
		"\x159\x157\x3\x2\x2\x2\x15A\x1B6\x5&\x14\xE\x15B\x15F\f\f\x2\x2\x15C\x15E"+
		"\a\xEB\x2\x2\x15D\x15C\x3\x2\x2\x2\x15E\x161\x3\x2\x2\x2\x15F\x15D\x3"+
		"\x2\x2\x2\x15F\x160\x3\x2\x2\x2\x160\x162\x3\x2\x2\x2\x161\x15F\x3\x2"+
		"\x2\x2\x162\x166\t\x5\x2\x2\x163\x165\a\xEB\x2\x2\x164\x163\x3\x2\x2\x2"+
		"\x165\x168\x3\x2\x2\x2\x166\x164\x3\x2\x2\x2\x166\x167\x3\x2\x2\x2\x167"+
		"\x169\x3\x2\x2\x2\x168\x166\x3\x2\x2\x2\x169\x1B6\x5&\x14\r\x16A\x16E"+
		"\f\n\x2\x2\x16B\x16D\a\xEB\x2\x2\x16C\x16B\x3\x2\x2\x2\x16D\x170\x3\x2"+
		"\x2\x2\x16E\x16C\x3\x2\x2\x2\x16E\x16F\x3\x2\x2\x2\x16F\x171\x3\x2\x2"+
		"\x2\x170\x16E\x3\x2\x2\x2\x171\x175\a\x38\x2\x2\x172\x174\a\xEB\x2\x2"+
		"\x173\x172\x3\x2\x2\x2\x174\x177\x3\x2\x2\x2\x175\x173\x3\x2\x2\x2\x175"+
		"\x176\x3\x2\x2\x2\x176\x178\x3\x2\x2\x2\x177\x175\x3\x2\x2\x2\x178\x1B6"+
		"\x5&\x14\v\x179\x17D\f\t\x2\x2\x17A\x17C\a\xEB\x2\x2\x17B\x17A\x3\x2\x2"+
		"\x2\x17C\x17F\x3\x2\x2\x2\x17D\x17B\x3\x2\x2\x2\x17D\x17E\x3\x2\x2\x2"+
		"\x17E\x180\x3\x2\x2\x2\x17F\x17D\x3\x2\x2\x2\x180\x184\a\x9E\x2\x2\x181"+
		"\x183\a\xEB\x2\x2\x182\x181\x3\x2\x2\x2\x183\x186\x3\x2\x2\x2\x184\x182"+
		"\x3\x2\x2\x2\x184\x185\x3\x2\x2\x2\x185\x187\x3\x2\x2\x2\x186\x184\x3"+
		"\x2\x2\x2\x187\x1B6\x5&\x14\n\x188\x18C\f\b\x2\x2\x189\x18B\a\xEB\x2\x2"+
		"\x18A\x189\x3\x2\x2\x2\x18B\x18E\x3\x2\x2\x2\x18C\x18A\x3\x2\x2\x2\x18C"+
		"\x18D\x3\x2\x2\x2\x18D\x18F\x3\x2\x2\x2\x18E\x18C\x3\x2\x2\x2\x18F\x193"+
		"\a\xD0\x2\x2\x190\x192\a\xEB\x2\x2\x191\x190\x3\x2\x2\x2\x192\x195\x3"+
		"\x2\x2\x2\x193\x191\x3\x2\x2\x2\x193\x194\x3\x2\x2\x2\x194\x196\x3\x2"+
		"\x2\x2\x195\x193\x3\x2\x2\x2\x196\x1B6\x5&\x14\t\x197\x19B\f\a\x2\x2\x198"+
		"\x19A\a\xEB\x2\x2\x199\x198\x3\x2\x2\x2\x19A\x19D\x3\x2\x2\x2\x19B\x199"+
		"\x3\x2\x2\x2\x19B\x19C\x3\x2\x2\x2\x19C\x19E\x3\x2\x2\x2\x19D\x19B\x3"+
		"\x2\x2\x2\x19E\x1A2\ah\x2\x2\x19F\x1A1\a\xEB\x2\x2\x1A0\x19F\x3\x2\x2"+
		"\x2\x1A1\x1A4\x3\x2\x2\x2\x1A2\x1A0\x3\x2\x2\x2\x1A2\x1A3\x3\x2\x2\x2"+
		"\x1A3\x1A5\x3\x2\x2\x2\x1A4\x1A2\x3\x2\x2\x2\x1A5\x1B6\x5&\x14\b\x1A6"+
		"\x1AA\f\x6\x2\x2\x1A7\x1A9\a\xEB\x2\x2\x1A8\x1A7\x3\x2\x2\x2\x1A9\x1AC"+
		"\x3\x2\x2\x2\x1AA\x1A8\x3\x2\x2\x2\x1AA\x1AB\x3\x2\x2\x2\x1AB\x1AD\x3"+
		"\x2\x2\x2\x1AC\x1AA\x3\x2\x2\x2\x1AD\x1B1\az\x2\x2\x1AE\x1B0\a\xEB\x2"+
		"\x2\x1AF\x1AE\x3\x2\x2\x2\x1B0\x1B3\x3\x2\x2\x2\x1B1\x1AF\x3\x2\x2\x2"+
		"\x1B1\x1B2\x3\x2\x2\x2\x1B2\x1B4\x3\x2\x2\x2\x1B3\x1B1\x3\x2\x2\x2\x1B4"+
		"\x1B6\x5&\x14\a\x1B5\x101\x3\x2\x2\x2\x1B5\x110\x3\x2\x2\x2\x1B5\x11F"+
		"\x3\x2\x2\x2\x1B5\x12E\x3\x2\x2\x2\x1B5\x13D\x3\x2\x2\x2\x1B5\x14C\x3"+
		"\x2\x2\x2\x1B5\x15B\x3\x2\x2\x2\x1B5\x16A\x3\x2\x2\x2\x1B5\x179\x3\x2"+
		"\x2\x2\x1B5\x188\x3\x2\x2\x2\x1B5\x197\x3\x2\x2\x2\x1B5\x1A6\x3\x2\x2"+
		"\x2\x1B6\x1B9\x3\x2\x2\x2\x1B7\x1B5\x3\x2\x2\x2\x1B7\x1B8\x3\x2\x2\x2"+
		"\x1B8\'\x3\x2\x2\x2\x1B9\x1B7\x3\x2\x2\x2\x1BA\x1BB\x5*\x16\x2\x1BB\x1BF"+
		"\a\xD8\x2\x2\x1BC\x1BE\a\xEB\x2\x2\x1BD\x1BC\x3\x2\x2\x2\x1BE\x1C1\x3"+
		"\x2\x2\x2\x1BF\x1BD\x3\x2\x2\x2\x1BF\x1C0\x3\x2\x2\x2\x1C0\x1C2\x3\x2"+
		"\x2\x2\x1C1\x1BF\x3\x2\x2\x2\x1C2\x1C6\x5&\x14\x2\x1C3\x1C5\a\xEB\x2\x2"+
		"\x1C4\x1C3\x3\x2\x2\x2\x1C5\x1C8\x3\x2\x2\x2\x1C6\x1C4\x3\x2\x2\x2\x1C6"+
		"\x1C7\x3\x2\x2\x2\x1C7\x1C9\x3\x2\x2\x2\x1C8\x1C6\x3\x2\x2\x2\x1C9\x1CA"+
		"\a\xDF\x2\x2\x1CA)\x3\x2\x2\x2\x1CB\x1CC\t\x6\x2\x2\x1CC+\x3\x2\x2\x2"+
		"\x1CD\x1CF\x5.\x18\x2\x1CE\x1D0\x5\x34\x1B\x2\x1CF\x1CE\x3\x2\x2\x2\x1CF"+
		"\x1D0\x3\x2\x2\x2\x1D0-\x3\x2\x2\x2\x1D1\x1D7\a\xED\x2\x2\x1D2\x1D7\x5"+
		":\x1E\x2\x1D3\x1D7\x5\x30\x19\x2\x1D4\x1D7\x5> \x2\x1D5\x1D7\x5<\x1F\x2"+
		"\x1D6\x1D1\x3\x2\x2\x2\x1D6\x1D2\x3\x2\x2\x2\x1D6\x1D3\x3\x2\x2\x2\x1D6"+
		"\x1D4\x3\x2\x2\x2\x1D6\x1D5\x3\x2\x2\x2\x1D7/\x3\x2\x2\x2\x1D8\x1DC\a"+
		"\xE0\x2\x2\x1D9\x1DB\x5\x32\x1A\x2\x1DA\x1D9\x3\x2\x2\x2\x1DB\x1DE\x3"+
		"\x2\x2\x2\x1DC\x1DA\x3\x2\x2\x2\x1DC\x1DD\x3\x2\x2\x2\x1DD\x1DF\x3\x2"+
		"\x2\x2\x1DE\x1DC\x3\x2\x2\x2\x1DF\x1E0\a\xE1\x2\x2\x1E0\x31\x3\x2\x2\x2"+
		"\x1E1\x1E4\n\a\x2\x2\x1E2\x1E4\x5\x30\x19\x2\x1E3\x1E1\x3\x2\x2\x2\x1E3"+
		"\x1E2\x3\x2\x2\x2\x1E4\x33\x3\x2\x2\x2\x1E5\x1E6\t\b\x2\x2\x1E6\x35\x3"+
		"\x2\x2\x2\x1E7\x1E8\t\t\x2\x2\x1E8\x37\x3\x2\x2\x2\x1E9\x1EE\a\xE9\x2"+
		"\x2\x1EA\x1ED\a\xEE\x2\x2\x1EB\x1ED\n\n\x2\x2\x1EC\x1EA\x3\x2\x2\x2\x1EC"+
		"\x1EB\x3\x2\x2\x2\x1ED\x1F0\x3\x2\x2\x2\x1EE\x1EC\x3\x2\x2\x2\x1EE\x1EF"+
		"\x3\x2\x2\x2\x1EF\x39\x3\x2\x2\x2\x1F0\x1EE\x3\x2\x2\x2\x1F1\x1F2\t\v"+
		"\x2\x2\x1F2;\x3\x2\x2\x2\x1F3\x1F4\a;\x2\x2\x1F4=\x3\x2\x2\x2\x1F5\x1F6"+
		"\t\f\x2\x2\x1F6?\x3\x2\x2\x2<\x46HNU[\x62osz\x81\x87\x92\x99\x9F\xAA\xB3"+
		"\xBC\xC0\xD6\xE0\xE8\xF0\xF7\xFF\x105\x10C\x114\x11B\x123\x12A\x132\x139"+
		"\x141\x148\x150\x157\x15F\x166\x16E\x175\x17D\x184\x18C\x193\x19B\x1A2"+
		"\x1AA\x1B1\x1B5\x1B7\x1BF\x1C6\x1CF\x1D6\x1DC\x1E3\x1EC\x1EE";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace Rubberduck.Parsing
