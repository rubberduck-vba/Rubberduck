//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Rubberduck.Inspections
{
    using System;


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class InspectionsUI
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal InspectionsUI()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if (object.ReferenceEquals(resourceMan, null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Rubberduck.Inspections.InspectionsUI", typeof(InspectionsUI).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Parameter is passed by value, but is assigned a new value/reference. Consider making a local copy instead..
        /// </summary>
        internal static string AssignedByValParameterInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("AssignedByValParameterInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to ByVal parameter is assigned.
        /// </summary>
        internal static string AssignedByValParameterInspectionName
        {
            get
            {
                return ResourceManager.GetString("AssignedByValParameterInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Value assigned to &apos;{0}&apos; is never used.
        /// </summary>
        internal static string AssignmentValueNeverUsedInspection
        {
            get
            {
                return ResourceManager.GetString("AssignmentValueNeverUsedInspection", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Value is re-assigned before assigned value is used.
        /// </summary>
        internal static string AssignmentValueNeverUsedInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("AssignmentValueNeverUsedInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Remove unused assignment.
        /// </summary>
        internal static string AssignmentValueNeverUsedInspectionName
        {
            get
            {
                return ResourceManager.GetString("AssignmentValueNeverUsedInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Remove unused assignment to &apos;{0}&apos;.
        /// </summary>
        internal static string AssignmentValueNeverUsedInspectionQuickFix
        {
            get
            {
                return ResourceManager.GetString("AssignmentValueNeverUsedInspectionQuickFix", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Code quality issues.
        /// </summary>
        internal static string CodeQualityIssues
        {
            get
            {
                return ResourceManager.GetString("CodeQualityIssues", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Constant value is declared but Rubberduck could not find any reference to it. Consider removing the unused declaration..
        /// </summary>
        internal static string ConstantNotUsedInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("ConstantNotUsedInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Constant is not referred to.
        /// </summary>
        internal static string ConstantNotUsedInspectionName
        {
            get
            {
                return ResourceManager.GetString("ConstantNotUsedInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Consider naming your VBA project..
        /// </summary>
        internal static string DefaultProjectNameInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("DefaultProjectNameInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Project has default project name.
        /// </summary>
        internal static string DefaultProjectNameInspectionName
        {
            get
            {
                return ResourceManager.GetString("DefaultProjectNameInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Prefer &apos;vbNullString&apos; to an empty string literal.
        /// </summary>
        internal static string EmptyStringLiteralInspection
        {
            get
            {
                return ResourceManager.GetString("EmptyStringLiteralInspection", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to The built-in constant &apos;vbNullString&apos; is a null string pointer taking up 0 bytes of memory, that unambiguously conveys the intent of an empty string..
        /// </summary>
        internal static string EmptyStringLiteralInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("EmptyStringLiteralInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Empty string literal.
        /// </summary>
        internal static string EmptyStringLiteralInspectionName
        {
            get
            {
                return ResourceManager.GetString("EmptyStringLiteralInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Replace empty string with the &apos;vbNullString&apos; constant.
        /// </summary>
        internal static string EmptyStringLiteralInspectionQuickFix
        {
            get
            {
                return ResourceManager.GetString("EmptyStringLiteralInspectionQuickFix", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Make field &apos;{0}&apos; a property.
        /// </summary>
        internal static string EncapsulatePublicFieldInspection
        {
            get
            {
                return ResourceManager.GetString("EncapsulatePublicFieldInspection", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Use properties rather than public fields..
        /// </summary>
        internal static string EncapsulatePublicFieldInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("EncapsulatePublicFieldInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Use properties rather than public fields..
        /// </summary>
        internal static string EncapsulatePublicFieldInspectionName
        {
            get
            {
                return ResourceManager.GetString("EncapsulatePublicFieldInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Encapsulate field &apos;{0}&apos; with property.
        /// </summary>
        internal static string EncapsulatePublicFieldInspectionQuickFix
        {
            get
            {
                return ResourceManager.GetString("EncapsulatePublicFieldInspectionQuickFix", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Ignore once.
        /// </summary>
        internal static string IgnoreOnce
        {
            get
            {
                return ResourceManager.GetString("IgnoreOnce", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Implicit references to the active sheet make the code frail and harder to debug. Consider making these references explicit when they&apos;re intended, and prefer working off object references..
        /// </summary>
        internal static string ImplicitActiveSheetReferenceInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("ImplicitActiveSheetReferenceInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Implicit reference to ActiveSheet.
        /// </summary>
        internal static string ImplicitActiveSheetReferenceInspectionName
        {
            get
            {
                return ResourceManager.GetString("ImplicitActiveSheetReferenceInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Implicit references to the active workbook make the code frail and harder to debug. Consider making these references explicit when they&apos;re intended, and prefer working off object references..
        /// </summary>
        internal static string ImplicitActiveWorkbookReferenceInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("ImplicitActiveWorkbookReferenceInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Implicit reference to ActiveWorkbook.
        /// </summary>
        internal static string ImplicitActiveWorkbookReferenceInspectionName
        {
            get
            {
                return ResourceManager.GetString("ImplicitActiveWorkbookReferenceInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Parameters are passed by reference unless specified otherwise, which can be confusing and bug-prone. Prefer passing parameters by value, and specify ByRef explicitly when passing parameters by reference..
        /// </summary>
        internal static string ImplicitByRefParameterInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("ImplicitByRefParameterInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Implicit ByRef parameter.
        /// </summary>
        internal static string ImplicitByRefParameterInspectionName
        {
            get
            {
                return ResourceManager.GetString("ImplicitByRefParameterInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Module members are public by default, which can be counter-intuitive. Consider specifying explicit access modifiers to avoid ambiguity..
        /// </summary>
        internal static string ImplicitPublicMemberInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("ImplicitPublicMemberInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Implicitly public member.
        /// </summary>
        internal static string ImplicitPublicMemberInspectionName
        {
            get
            {
                return ResourceManager.GetString("ImplicitPublicMemberInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Members with a return value implicitly return a &apos;Variant&apos; unless specified otherwise. Consider returning an explicit &apos;Variant&apos; when the return type isn&apos;t known, or specify it explicitly..
        /// </summary>
        internal static string ImplicitVariantReturnTypeInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("ImplicitVariantReturnTypeInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Return type is implicitly &apos;Variant&apos;.
        /// </summary>
        internal static string ImplicitVariantReturnTypeInspectionName
        {
            get
            {
                return ResourceManager.GetString("ImplicitVariantReturnTypeInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Language opportunities.
        /// </summary>
        internal static string LanguageOpportunities
        {
            get
            {
                return ResourceManager.GetString("LanguageOpportunities", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Maintainability &amp; readability issues.
        /// </summary>
        internal static string MaintainabilityAndReadabilityIssues
        {
            get
            {
                return ResourceManager.GetString("MaintainabilityAndReadabilityIssues", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Move field closer to usage.
        /// </summary>
        internal static string MoveFieldCloseToUsageInspection
        {
            get
            {
                return ResourceManager.GetString("MoveFieldCloseToUsageInspection", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to A field that is only used in one method should be a local variable..
        /// </summary>
        internal static string MoveFieldCloseToUsageInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("MoveFieldCloseToUsageInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Move field closer to usage.
        /// </summary>
        internal static string MoveFieldCloseToUsageInspectionName
        {
            get
            {
                return ResourceManager.GetString("MoveFieldCloseToUsageInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Move field &apos;{0}&apos; closer to usage.
        /// </summary>
        internal static string MoveFieldCloseToUsageInspectionQuickFix
        {
            get
            {
                return ResourceManager.GetString("MoveFieldCloseToUsageInspectionQuickFix", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Consider continuing long signatures between parameters. Splitting a parameter declaration across multiple lines arguably hurts readability..
        /// </summary>
        internal static string MultilineParameterInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("MultilineParameterInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Parameter declaration is split on multiple lines.
        /// </summary>
        internal static string MultilineParameterInspectionName
        {
            get
            {
                return ResourceManager.GetString("MultilineParameterInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Declaring multiple variables in the same instruction is legal, but should be used sparingly. Consider declaring variables closer to their usage, in a single instruction per declaration..
        /// </summary>
        internal static string MultipleDeclarationsInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("MultipleDeclarationsInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Instruction contains multiple declarations.
        /// </summary>
        internal static string MultipleDeclarationsInspectionName
        {
            get
            {
                return ResourceManager.GetString("MultipleDeclarationsInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; has more than one &apos;@Folder&apos; annotation..
        /// </summary>
        internal static string MultipleFolderAnnotationsInspection
        {
            get
            {
                return ResourceManager.GetString("MultipleFolderAnnotationsInspection", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Rubberduck only uses the first &apos;@Folder&apos; annotation in a code module; consider removing extraneous ones..
        /// </summary>
        internal static string MultipleFolderAnnotationsInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("MultipleFolderAnnotationsInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; has more than one folder annotation..
        /// </summary>
        internal static string MultipleFolderAnnotationsInspectionName
        {
            get
            {
                return ResourceManager.GetString("MultipleFolderAnnotationsInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to This is likely a bug. The return value of a function or property getter must be assigned before exiting, otherwise the program will not be working with expected results. If a function has no meaningful return value, consider declaring it as a &apos;Sub&apos; procedure instead..
        /// </summary>
        internal static string NonReturningFunctionInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("NonReturningFunctionInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Non-returning function or property getter.
        /// </summary>
        internal static string NonReturningFunctionInspectionName
        {
            get
            {
                return ResourceManager.GetString("NonReturningFunctionInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to The &apos;Call&apos; statement is no longer required to call procedures, and only exists in the language to support legacy code that required it; it can be safely rewritten to an implicit call..
        /// </summary>
        internal static string ObsoleteCallStatementInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("ObsoleteCallStatementInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to &apos;Call&apos; statement usage.
        /// </summary>
        internal static string ObsoleteCallStatementInspectionName
        {
            get
            {
                return ResourceManager.GetString("ObsoleteCallStatementInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to The &apos;Rem&apos; statement only exists in the language to support legacy code that required it; it can be safely replaced with an apostrophe / single-quote comment..
        /// </summary>
        internal static string ObsoleteCommentSyntaxInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("ObsoleteCommentSyntaxInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to &apos;Rem&apos; statement usage.
        /// </summary>
        internal static string ObsoleteCommentSyntaxInspectionName
        {
            get
            {
                return ResourceManager.GetString("ObsoleteCommentSyntaxInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to The &apos;Global&apos; keyword only exists in the language to support legacy code that required it; it can be safely replaced with the &apos;Public&apos; modifier..
        /// </summary>
        internal static string ObsoleteGlobalInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("ObsoleteGlobalInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to &apos;Global&apos; statement usage.
        /// </summary>
        internal static string ObsoleteGlobalInspectionName
        {
            get
            {
                return ResourceManager.GetString("ObsoleteGlobalInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to The &apos;Let&apos; statement only exists in the language to support legacy code that required it; it can be safely removed, since modern VBA does not require that keyword for value assignments..
        /// </summary>
        internal static string ObsoleteLetStatementInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("ObsoleteLetStatementInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to &apos;Let&apos; statement usage.
        /// </summary>
        internal static string ObsoleteLetStatementInspectionName
        {
            get
            {
                return ResourceManager.GetString("ObsoleteLetStatementInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Type hint characters only exist in the language to support legacy code that required it; they can be safely replaced in declarations with an &quot;As&quot; type clause that specifies the type explicitly, and they can be omitted in other identifier references..
        /// </summary>
        internal static string ObsoleteTypeHintInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("ObsoleteTypeHintInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Type hint usage.
        /// </summary>
        internal static string ObsoleteTypeHintInspectionName
        {
            get
            {
                return ResourceManager.GetString("ObsoleteTypeHintInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Arrays are typically zero-based. This option changes the default lower boundary for implicitly-sized arrays, which can introduce off-by-one errors if one isn&apos;t cautious..
        /// </summary>
        internal static string OptionBaseInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("OptionBaseInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to &apos;Option Base 1&apos; is specified.
        /// </summary>
        internal static string OptionBaseInspectionName
        {
            get
            {
                return ResourceManager.GetString("OptionBaseInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Rubberduck works best when all used identifiers are declared. Allowing the usage of undeclared variables can cause easily avoidable bugs. Always specify Option Explicit..
        /// </summary>
        internal static string OptionExplicitInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("OptionExplicitInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to &apos;Option Explicit&apos; is not specified.
        /// </summary>
        internal static string OptionExplicitInspectionName
        {
            get
            {
                return ResourceManager.GetString("OptionExplicitInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to A parameter that is passed by reference and isn&apos;t assigned a new value/reference, could be passed by value instead..
        /// </summary>
        internal static string ParameterCanBeByValInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("ParameterCanBeByValInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Parameter can be passed by value.
        /// </summary>
        internal static string ParameterCanBeByValInspectionName
        {
            get
            {
                return ResourceManager.GetString("ParameterCanBeByValInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to A parameter is passed into a member that does not use it. Consider removing that parameter..
        /// </summary>
        internal static string ParameterNotUsedInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("ParameterNotUsedInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Parameter is not referred to.
        /// </summary>
        internal static string ParameterNotUsedInspectionName
        {
            get
            {
                return ResourceManager.GetString("ParameterNotUsedInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Rubberduck could not find any caller for a procedure. If the procedure is hooked to a macro-button, used as a user-defined function (UDF) or handles an application event that Rubberduck didn&apos;t know of you can safely ignore this inspection result; otherwise, consider removing it..
        /// </summary>
        internal static string ProcedureNotUsedInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("ProcedureNotUsedInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Procedure is not referred to.
        /// </summary>
        internal static string ProcedureNotUsedInspectionName
        {
            get
            {
                return ResourceManager.GetString("ProcedureNotUsedInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Procedure &apos;{0}&apos; can be written as a function..
        /// </summary>
        internal static string ProcedureShouldBeFunctionInspection
        {
            get
            {
                return ResourceManager.GetString("ProcedureShouldBeFunctionInspection", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to A procedure that only has one parameter passed by reference that is assigned a new value/reference before the procedure exits, is using a ByRef parameter as a return value: consider making it a function instead..
        /// </summary>
        internal static string ProcedureShouldBeFunctionInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("ProcedureShouldBeFunctionInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Procedure can be written as a function.
        /// </summary>
        internal static string ProcedureShouldBeFunctionInspectionName
        {
            get
            {
                return ResourceManager.GetString("ProcedureShouldBeFunctionInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Implement as function and update usages..
        /// </summary>
        internal static string ProcedureShouldBeFunctionInspectionQuickFix
        {
            get
            {
                return ResourceManager.GetString("ProcedureShouldBeFunctionInspectionQuickFix", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Declaration &apos;{0}&apos; is self-assigned.
        /// </summary>
        internal static string SelfAssignedDeclarationInspection
        {
            get
            {
                return ResourceManager.GetString("SelfAssignedDeclarationInspection", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to A declaration should not be self-assigned..
        /// </summary>
        internal static string SelfAssignedDeclarationInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("SelfAssignedDeclarationInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Self-assigned property.
        /// </summary>
        internal static string SelfAssignedDeclarationInspectionName
        {
            get
            {
                return ResourceManager.GetString("SelfAssignedDeclarationInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to This is likely a bug. A variable is being referred to, but is never assigned..
        /// </summary>
        internal static string UnassignedVariableUsageInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("UnassignedVariableUsageInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Variable is used but not assigned.
        /// </summary>
        internal static string UnassignedVariableUsageInspectionName
        {
            get
            {
                return ResourceManager.GetString("UnassignedVariableUsageInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to A string-returning equivalent function exists and should preferably be used to avoid implicit type conversions..
        /// </summary>
        internal static string UntypedFunctionUsageInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("UntypedFunctionUsageInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Use of variant-returning string function.
        /// </summary>
        internal static string UntypedFunctionUsageInspectionName
        {
            get
            {
                return ResourceManager.GetString("UntypedFunctionUsageInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Consider renaming {0} &apos;{1}&apos;.
        /// </summary>
        internal static string UseMeaningfulNameInspection
        {
            get
            {
                return ResourceManager.GetString("UseMeaningfulNameInspection", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Identifier names should indicate what they&apos;re used for and should be readable; avoid disemvoweling, numeric suffixes, and 1-2 character names..
        /// </summary>
        internal static string UseMeaningfulNameInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("UseMeaningfulNameInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Use meaningful names.
        /// </summary>
        internal static string UseMeaningfulNameInspectionName
        {
            get
            {
                return ResourceManager.GetString("UseMeaningfulNameInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to A variable is declared, but never assigned a value/reference. If Rubberduck is correct, the variable could probably be safely removed..
        /// </summary>
        internal static string VariableNotAssignedInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("VariableNotAssignedInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Unassigned variable.
        /// </summary>
        internal static string VariableNotAssignedInspectionName
        {
            get
            {
                return ResourceManager.GetString("VariableNotAssignedInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to A variable is declared and assigned a value/reference, but it&apos;s never referred to..
        /// </summary>
        internal static string VariableNotUsedInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("VariableNotUsedInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Variable is not referred to.
        /// </summary>
        internal static string VariableNotUsedInspectionName
        {
            get
            {
                return ResourceManager.GetString("VariableNotUsedInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to A variable whose type isn&apos;t explicitly declared, is implicitly &apos;Variant&apos;. Consider making it an explicit &apos;Variant&apos; if that&apos;s intended, or declare a more specific type..
        /// </summary>
        internal static string VariableTypeNotDeclaredInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("VariableTypeNotDeclaredInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Variable is implicitly &apos;Variant&apos;.
        /// </summary>
        internal static string VariableTypeNotDeclaredInspectionName
        {
            get
            {
                return ResourceManager.GetString("VariableTypeNotDeclaredInspectionName", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Property &apos;{0}&apos; has no getter.
        /// </summary>
        internal static string WriteOnlyPropertyInspection
        {
            get
            {
                return ResourceManager.GetString("WriteOnlyPropertyInspection", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to A property that exposes a mutator but no accessor is a design smell and makes a confusing API. Consider exposing a getter, or converting the mutator to a method..
        /// </summary>
        internal static string WriteOnlyPropertyInspectionMeta
        {
            get
            {
                return ResourceManager.GetString("WriteOnlyPropertyInspectionMeta", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Write-only property.
        /// </summary>
        internal static string WriteOnlyPropertyInspectionName
        {
            get
            {
                return ResourceManager.GetString("WriteOnlyPropertyInspectionName", resourceCulture);
            }
        }
    }
}
