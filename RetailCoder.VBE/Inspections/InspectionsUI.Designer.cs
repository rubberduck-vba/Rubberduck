//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Rubberduck.Inspections {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class InspectionsUI {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal InspectionsUI() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Rubberduck.Inspections.InspectionsUI", typeof(InspectionsUI).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter is passed by value, but is assigned a new value/reference. Consider making a local copy instead..
        /// </summary>
        internal static string AssignedByValParameterInspectionMeta {
            get {
                return ResourceManager.GetString("AssignedByValParameterInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to ByVal parameter is assigned.
        /// </summary>
        internal static string AssignedByValParameterInspectionName {
            get {
                return ResourceManager.GetString("AssignedByValParameterInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Code quality issues.
        /// </summary>
        internal static string CodeQualityIssues {
            get {
                return ResourceManager.GetString("CodeQualityIssues", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Constant value is declared but Rubberduck could not find any reference to it. Consider removing the unused declaration..
        /// </summary>
        internal static string ConstantNotUsedInspectionMeta {
            get {
                return ResourceManager.GetString("ConstantNotUsedInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Constant is not referred to.
        /// </summary>
        internal static string ConstantNotUsedInspectionName {
            get {
                return ResourceManager.GetString("ConstantNotUsedInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider naming your VBA project..
        /// </summary>
        internal static string DefaultProjectNameInspectionMeta {
            get {
                return ResourceManager.GetString("DefaultProjectNameInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Project has default project name.
        /// </summary>
        internal static string DefaultProjectNameInspectionName {
            get {
                return ResourceManager.GetString("DefaultProjectNameInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Prefer &apos;vbNullString&apos; to an empty string literal.
        /// </summary>
        internal static string EmptyStringLiteralInspection {
            get {
                return ResourceManager.GetString("EmptyStringLiteralInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The built-in constant &apos;vbNullString&apos; is a null string pointer taking up 0 bytes of memory, that unambiguously conveys the intent of an empty string..
        /// </summary>
        internal static string EmptyStringLiteralInspectionMeta {
            get {
                return ResourceManager.GetString("EmptyStringLiteralInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Empty string literal.
        /// </summary>
        internal static string EmptyStringLiteralInspectionName {
            get {
                return ResourceManager.GetString("EmptyStringLiteralInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Replace empty string with the &apos;vbNullString&apos; constant.
        /// </summary>
        internal static string EmptyStringLiteralInspectionQuickFix {
            get {
                return ResourceManager.GetString("EmptyStringLiteralInspectionQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Make field &apos;{0}&apos; a property.
        /// </summary>
        internal static string EncapsulatePublicFieldInspection {
            get {
                return ResourceManager.GetString("EncapsulatePublicFieldInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use properties rather than public fields..
        /// </summary>
        internal static string EncapsulatePublicFieldInspectionMeta {
            get {
                return ResourceManager.GetString("EncapsulatePublicFieldInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use properties rather than public fields..
        /// </summary>
        internal static string EncapsulatePublicFieldInspectionName {
            get {
                return ResourceManager.GetString("EncapsulatePublicFieldInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Encapsulate field &apos;{0}&apos; with property.
        /// </summary>
        internal static string EncapsulatePublicFieldInspectionQuickFix {
            get {
                return ResourceManager.GetString("EncapsulatePublicFieldInspectionQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Return value of function &apos;{0}&apos; is never used..
        /// </summary>
        internal static string FunctionReturnValueNotUsedInspection {
            get {
                return ResourceManager.GetString("FunctionReturnValueNotUsedInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Function return value is never used..
        /// </summary>
        internal static string FunctionReturnValueNotUsedInspectionName {
            get {
                return ResourceManager.GetString("FunctionReturnValueNotUsedInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ignore once.
        /// </summary>
        internal static string IgnoreOnce {
            get {
                return ResourceManager.GetString("IgnoreOnce", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implicit references to the active sheet make the code frail and harder to debug. Consider making these references explicit when they&apos;re intended, and prefer working off object references..
        /// </summary>
        internal static string ImplicitActiveSheetReferenceInspectionMeta {
            get {
                return ResourceManager.GetString("ImplicitActiveSheetReferenceInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implicit reference to ActiveSheet.
        /// </summary>
        internal static string ImplicitActiveSheetReferenceInspectionName {
            get {
                return ResourceManager.GetString("ImplicitActiveSheetReferenceInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implicit references to the active workbook make the code frail and harder to debug. Consider making these references explicit when they&apos;re intended, and prefer working off object references..
        /// </summary>
        internal static string ImplicitActiveWorkbookReferenceInspectionMeta {
            get {
                return ResourceManager.GetString("ImplicitActiveWorkbookReferenceInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implicit reference to ActiveWorkbook.
        /// </summary>
        internal static string ImplicitActiveWorkbookReferenceInspectionName {
            get {
                return ResourceManager.GetString("ImplicitActiveWorkbookReferenceInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameters are passed by reference unless specified otherwise, which can be confusing and bug-prone. Prefer passing parameters by value, and specify ByRef explicitly when passing parameters by reference..
        /// </summary>
        internal static string ImplicitByRefParameterInspectionMeta {
            get {
                return ResourceManager.GetString("ImplicitByRefParameterInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implicit ByRef parameter.
        /// </summary>
        internal static string ImplicitByRefParameterInspectionName {
            get {
                return ResourceManager.GetString("ImplicitByRefParameterInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Module members are public by default, which can be counter-intuitive. Consider specifying explicit access modifiers to avoid ambiguity..
        /// </summary>
        internal static string ImplicitPublicMemberInspectionMeta {
            get {
                return ResourceManager.GetString("ImplicitPublicMemberInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implicitly public member.
        /// </summary>
        internal static string ImplicitPublicMemberInspectionName {
            get {
                return ResourceManager.GetString("ImplicitPublicMemberInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Members with a return value implicitly return a &apos;Variant&apos; unless specified otherwise. Consider returning an explicit &apos;Variant&apos; when the return type isn&apos;t known, or specify it explicitly..
        /// </summary>
        internal static string ImplicitVariantReturnTypeInspectionMeta {
            get {
                return ResourceManager.GetString("ImplicitVariantReturnTypeInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Return type is implicitly &apos;Variant&apos;.
        /// </summary>
        internal static string ImplicitVariantReturnTypeInspectionName {
            get {
                return ResourceManager.GetString("ImplicitVariantReturnTypeInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Language opportunities.
        /// </summary>
        internal static string LanguageOpportunities {
            get {
                return ResourceManager.GetString("LanguageOpportunities", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Maintainability &amp; readability issues.
        /// </summary>
        internal static string MaintainabilityAndReadabilityIssues {
            get {
                return ResourceManager.GetString("MaintainabilityAndReadabilityIssues", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Move field closer to usage.
        /// </summary>
        internal static string MoveFieldCloserToUsageInspection {
            get {
                return ResourceManager.GetString("MoveFieldCloserToUsageInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A field that is only used in one method should be a local variable..
        /// </summary>
        internal static string MoveFieldCloserToUsageInspectionMeta {
            get {
                return ResourceManager.GetString("MoveFieldCloserToUsageInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Move field closer to usage.
        /// </summary>
        internal static string MoveFieldCloserToUsageInspectionName {
            get {
                return ResourceManager.GetString("MoveFieldCloserToUsageInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Move field &apos;{0}&apos; closer to usage.
        /// </summary>
        internal static string MoveFieldCloserToUsageInspectionQuickFix {
            get {
                return ResourceManager.GetString("MoveFieldCloserToUsageInspectionQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider continuing long signatures between parameters. Splitting a parameter declaration across multiple lines arguably hurts readability..
        /// </summary>
        internal static string MultilineParameterInspectionMeta {
            get {
                return ResourceManager.GetString("MultilineParameterInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter declaration is split on multiple lines.
        /// </summary>
        internal static string MultilineParameterInspectionName {
            get {
                return ResourceManager.GetString("MultilineParameterInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Declaring multiple variables in the same instruction is legal, but should be used sparingly. Consider declaring variables closer to their usage, in a single instruction per declaration..
        /// </summary>
        internal static string MultipleDeclarationsInspectionMeta {
            get {
                return ResourceManager.GetString("MultipleDeclarationsInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Instruction contains multiple declarations.
        /// </summary>
        internal static string MultipleDeclarationsInspectionName {
            get {
                return ResourceManager.GetString("MultipleDeclarationsInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; has more than one &apos;@Folder&apos; annotation..
        /// </summary>
        internal static string MultipleFolderAnnotationsInspection {
            get {
                return ResourceManager.GetString("MultipleFolderAnnotationsInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rubberduck only uses the first &apos;@Folder&apos; annotation in a code module; consider removing extraneous ones..
        /// </summary>
        internal static string MultipleFolderAnnotationsInspectionMeta {
            get {
                return ResourceManager.GetString("MultipleFolderAnnotationsInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; has more than one folder annotation..
        /// </summary>
        internal static string MultipleFolderAnnotationsInspectionName {
            get {
                return ResourceManager.GetString("MultipleFolderAnnotationsInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This is likely a bug. The return value of a function or property getter must be assigned before exiting, otherwise the program will not be working with expected results. If a function has no meaningful return value, consider declaring it as a &apos;Sub&apos; procedure instead..
        /// </summary>
        internal static string NonReturningFunctionInspectionMeta {
            get {
                return ResourceManager.GetString("NonReturningFunctionInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Non-returning function or property getter.
        /// </summary>
        internal static string NonReturningFunctionInspectionName {
            get {
                return ResourceManager.GetString("NonReturningFunctionInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The &apos;Call&apos; statement is no longer required to call procedures, and only exists in the language to support legacy code that required it; it can be safely rewritten to an implicit call..
        /// </summary>
        internal static string ObsoleteCallStatementInspectionMeta {
            get {
                return ResourceManager.GetString("ObsoleteCallStatementInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;Call&apos; statement usage.
        /// </summary>
        internal static string ObsoleteCallStatementInspectionName {
            get {
                return ResourceManager.GetString("ObsoleteCallStatementInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The &apos;Rem&apos; statement only exists in the language to support legacy code that required it; it can be safely replaced with an apostrophe / single-quote comment..
        /// </summary>
        internal static string ObsoleteCommentSyntaxInspectionMeta {
            get {
                return ResourceManager.GetString("ObsoleteCommentSyntaxInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;Rem&apos; statement usage.
        /// </summary>
        internal static string ObsoleteCommentSyntaxInspectionName {
            get {
                return ResourceManager.GetString("ObsoleteCommentSyntaxInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The &apos;Global&apos; keyword only exists in the language to support legacy code that required it; it can be safely replaced with the &apos;Public&apos; modifier..
        /// </summary>
        internal static string ObsoleteGlobalInspectionMeta {
            get {
                return ResourceManager.GetString("ObsoleteGlobalInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;Global&apos; statement usage.
        /// </summary>
        internal static string ObsoleteGlobalInspectionName {
            get {
                return ResourceManager.GetString("ObsoleteGlobalInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The &apos;Let&apos; statement only exists in the language to support legacy code that required it; it can be safely removed, since modern VBA does not require that keyword for value assignments..
        /// </summary>
        internal static string ObsoleteLetStatementInspectionMeta {
            get {
                return ResourceManager.GetString("ObsoleteLetStatementInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;Let&apos; statement usage.
        /// </summary>
        internal static string ObsoleteLetStatementInspectionName {
            get {
                return ResourceManager.GetString("ObsoleteLetStatementInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type hint characters only exist in the language to support legacy code that required it; they can be safely replaced in declarations with an &quot;As&quot; type clause that specifies the type explicitly, and they can be omitted in other identifier references..
        /// </summary>
        internal static string ObsoleteTypeHintInspectionMeta {
            get {
                return ResourceManager.GetString("ObsoleteTypeHintInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type hint usage.
        /// </summary>
        internal static string ObsoleteTypeHintInspectionName {
            get {
                return ResourceManager.GetString("ObsoleteTypeHintInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Arrays are typically zero-based. This option changes the default lower boundary for implicitly-sized arrays, which can introduce off-by-one errors if one isn&apos;t cautious..
        /// </summary>
        internal static string OptionBaseInspectionMeta {
            get {
                return ResourceManager.GetString("OptionBaseInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;Option Base 1&apos; is specified.
        /// </summary>
        internal static string OptionBaseInspectionName {
            get {
                return ResourceManager.GetString("OptionBaseInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rubberduck works best when all used identifiers are declared. Allowing the usage of undeclared variables can cause easily avoidable bugs. Always specify Option Explicit..
        /// </summary>
        internal static string OptionExplicitInspectionMeta {
            get {
                return ResourceManager.GetString("OptionExplicitInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;Option Explicit&apos; is not specified.
        /// </summary>
        internal static string OptionExplicitInspectionName {
            get {
                return ResourceManager.GetString("OptionExplicitInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A parameter that is passed by reference and isn&apos;t assigned a new value/reference, could be passed by value instead..
        /// </summary>
        internal static string ParameterCanBeByValInspectionMeta {
            get {
                return ResourceManager.GetString("ParameterCanBeByValInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter can be passed by value.
        /// </summary>
        internal static string ParameterCanBeByValInspectionName {
            get {
                return ResourceManager.GetString("ParameterCanBeByValInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A parameter is passed into a member that does not use it. Consider removing that parameter..
        /// </summary>
        internal static string ParameterNotUsedInspectionMeta {
            get {
                return ResourceManager.GetString("ParameterNotUsedInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter is not referred to.
        /// </summary>
        internal static string ParameterNotUsedInspectionName {
            get {
                return ResourceManager.GetString("ParameterNotUsedInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rubberduck could not find any caller for a procedure. If the procedure is hooked to a macro-button, used as a user-defined function (UDF) or handles an application event that Rubberduck didn&apos;t know of you can safely ignore this inspection result; otherwise, consider removing it..
        /// </summary>
        internal static string ProcedureNotUsedInspectionMeta {
            get {
                return ResourceManager.GetString("ProcedureNotUsedInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Procedure is not referred to.
        /// </summary>
        internal static string ProcedureNotUsedInspectionName {
            get {
                return ResourceManager.GetString("ProcedureNotUsedInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Procedure &apos;{0}&apos; can be written as a function..
        /// </summary>
        internal static string ProcedureShouldBeFunctionInspection {
            get {
                return ResourceManager.GetString("ProcedureShouldBeFunctionInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A procedure that only has one parameter passed by reference that is assigned a new value/reference before the procedure exits, is using a ByRef parameter as a return value: consider making it a function instead..
        /// </summary>
        internal static string ProcedureShouldBeFunctionInspectionMeta {
            get {
                return ResourceManager.GetString("ProcedureShouldBeFunctionInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Procedure can be written as a function.
        /// </summary>
        internal static string ProcedureShouldBeFunctionInspectionName {
            get {
                return ResourceManager.GetString("ProcedureShouldBeFunctionInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implement as function and update usages..
        /// </summary>
        internal static string ProcedureShouldBeFunctionInspectionQuickFix {
            get {
                return ResourceManager.GetString("ProcedureShouldBeFunctionInspectionQuickFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Declaration &apos;{0}&apos; is self-assigned.
        /// </summary>
        internal static string SelfAssignedDeclarationInspection {
            get {
                return ResourceManager.GetString("SelfAssignedDeclarationInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A declaration should not be self-assigned..
        /// </summary>
        internal static string SelfAssignedDeclarationInspectionMeta {
            get {
                return ResourceManager.GetString("SelfAssignedDeclarationInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Self-assigned property.
        /// </summary>
        internal static string SelfAssignedDeclarationInspectionName {
            get {
                return ResourceManager.GetString("SelfAssignedDeclarationInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This is likely a bug. A variable is being referred to, but is never assigned..
        /// </summary>
        internal static string UnassignedVariableUsageInspectionMeta {
            get {
                return ResourceManager.GetString("UnassignedVariableUsageInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Variable is used but not assigned.
        /// </summary>
        internal static string UnassignedVariableUsageInspectionName {
            get {
                return ResourceManager.GetString("UnassignedVariableUsageInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A string-returning equivalent function exists and should preferably be used to avoid implicit type conversions..
        /// </summary>
        internal static string UntypedFunctionUsageInspectionMeta {
            get {
                return ResourceManager.GetString("UntypedFunctionUsageInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use of variant-returning string function.
        /// </summary>
        internal static string UntypedFunctionUsageInspectionName {
            get {
                return ResourceManager.GetString("UntypedFunctionUsageInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider renaming {0} &apos;{1}&apos;.
        /// </summary>
        internal static string UseMeaningfulNameInspection {
            get {
                return ResourceManager.GetString("UseMeaningfulNameInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identifier names should indicate what they&apos;re used for and should be readable; avoid disemvoweling, numeric suffixes, and 1-2 character names..
        /// </summary>
        internal static string UseMeaningfulNameInspectionMeta {
            get {
                return ResourceManager.GetString("UseMeaningfulNameInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use meaningful names.
        /// </summary>
        internal static string UseMeaningfulNameInspectionName {
            get {
                return ResourceManager.GetString("UseMeaningfulNameInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A variable is declared, but never assigned a value/reference. If Rubberduck is correct, the variable could probably be safely removed..
        /// </summary>
        internal static string VariableNotAssignedInspectionMeta {
            get {
                return ResourceManager.GetString("VariableNotAssignedInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unassigned variable.
        /// </summary>
        internal static string VariableNotAssignedInspectionName {
            get {
                return ResourceManager.GetString("VariableNotAssignedInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A variable is declared and assigned a value/reference, but it&apos;s never referred to..
        /// </summary>
        internal static string VariableNotUsedInspectionMeta {
            get {
                return ResourceManager.GetString("VariableNotUsedInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Variable is not referred to.
        /// </summary>
        internal static string VariableNotUsedInspectionName {
            get {
                return ResourceManager.GetString("VariableNotUsedInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A variable whose type isn&apos;t explicitly declared, is implicitly &apos;Variant&apos;. Consider making it an explicit &apos;Variant&apos; if that&apos;s intended, or declare a more specific type..
        /// </summary>
        internal static string VariableTypeNotDeclaredInspectionMeta {
            get {
                return ResourceManager.GetString("VariableTypeNotDeclaredInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Variable is implicitly &apos;Variant&apos;.
        /// </summary>
        internal static string VariableTypeNotDeclaredInspectionName {
            get {
                return ResourceManager.GetString("VariableTypeNotDeclaredInspectionName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Property &apos;{0}&apos; has no getter.
        /// </summary>
        internal static string WriteOnlyPropertyInspection {
            get {
                return ResourceManager.GetString("WriteOnlyPropertyInspection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A property that exposes a mutator but no accessor is a design smell and makes a confusing API. Consider exposing a getter, or converting the mutator to a method..
        /// </summary>
        internal static string WriteOnlyPropertyInspectionMeta {
            get {
                return ResourceManager.GetString("WriteOnlyPropertyInspectionMeta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Write-only property.
        /// </summary>
        internal static string WriteOnlyPropertyInspectionName {
            get {
                return ResourceManager.GetString("WriteOnlyPropertyInspectionName", resourceCulture);
            }
        }
    }
}
