<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AnalyzerCategory" xml:space="preserve">
    <value>Gestione COM</value>
  </data>
  <data name="ChainedWrapperDescription" xml:space="preserve">
    <value>Tutti i tipi derivati da SafeComWrappers non dovrebbero essere chained perché portano a risoorse non gestite. Usare una variabile locale esplicita per ogni membro chained.</value>
  </data>
  <data name="ChainedWrapperMessageFormat" xml:space="preserve">
    <value>Il tipo '{0}' deriva da un SafeComWrapper base. E' chiamato attraverso un altro tipo derivato da SafeComWrapper '{1}' nell'espressione '{2}'.</value>
  </data>
  <data name="ChainedWrapperTitle" xml:space="preserve">
    <value>Chained Wrappers</value>
  </data>
  <data name="DuplicateNameAttribute" xml:space="preserve">
    <value>Valore duplicato nell'attributo 'name'</value>
  </data>
  <data name="DuplicateNameAttributeDescription" xml:space="preserve">
    <value>L'attributo 'name' è usato per identificare univocamente un elemento. Di consenguenza deve essere univoco.</value>
  </data>
  <data name="DuplicateNameAttributeMessageFormat" xml:space="preserve">
    <value>Il valore '{0}' è usato nell'attributo 'name' di elementi '{1}' multipli.</value>
  </data>
  <data name="FileSystemUsageCategory" xml:space="preserve">
    <value>Gestione API di Filesystem</value>
  </data>
  <data name="FileSystemUsageDescription" xml:space="preserve">
    <value>Per evitare problemi con la verificabilità e il controllo dei comportamenti, tutto il codice di produzione dovrebbe usare astrazioni (es. System.IO.Abstractions invece di System.IO). Per utilizzi non di filesystem come l'uso di stream utilizzare statement con le classi (es. "using Path = System.IO.Path;").</value>
  </data>
  <data name="FileSystemUsageMessageFormat" xml:space="preserve">
    <value>Il file '{0}' contiene un utilizzo non qualificato di System.IO. Dovrebbero essere usate Astrazioni al suo posto.</value>
  </data>
  <data name="FileSystemUsageTile" xml:space="preserve">
    <value>Utilizzo non valido di API di filesystem</value>
  </data>
  <data name="InvalidTypeAttribute" xml:space="preserve">
    <value>Valore non valido per l'attributo 'type'.</value>
  </data>
  <data name="InvalidTypeAttributeDescription" xml:space="preserve">
    <value>I valori dell'attributo 'type' sono limitati ai valori 'Standard Module', 'Class Module', 'Document' e 'User Form'.</value>
  </data>
  <data name="InvalidTypeAttributeMessageFormat" xml:space="preserve">
    <value>Il valore '{0}' non è valido per l'attributo 'type'.</value>
  </data>
  <data name="MissingAnnotationSummaryElementDescription" xml:space="preserve">
    <value>Tutte le annotazioni devono avere un breve commento xml-doc &lt;summary&gt; che descrive per cosa viene utilizzata l'annotazione, leggibile comodamente in IntelliSense.</value>
  </data>
  <data name="MissingClassInterfaceDescription" xml:space="preserve">
    <value>Le classi visibili da COM devono avere un attributo ClassInterface esplicito ed essere impostate su `None`. Ciò è necessario per evitare problemi con le versioni.</value>
  </data>
  <data name="MissingClassInterfaceMessageFormat" xml:space="preserve">
    <value>La classe visibile da COM '{0}' non ha un attributo ClassInterface esplicito che è anche impostato a 'ClassInterfaceType.None'.</value>
  </data>
  <data name="MissingClassInterfaceTitle" xml:space="preserve">
    <value>Attributo ClassInterface Mancante</value>
  </data>
  <data name="MissingComDefaultInterfaceDescription" xml:space="preserve">
    <value>Le classi visibili da COM devono avere un attributo ComDefaultInterface esplicito che fa riferimento a un'interfaccia visibile da COM.</value>
  </data>
  <data name="MissingComDefaultInterfaceId" xml:space="preserve">
    <value>ComDefaultInterface mancante</value>
  </data>
  <data name="MissingComDefaultInterfaceMessageFormat" xml:space="preserve">
    <value>La classe visibile da COM '{0}' deve avere un attributo ComDefaultInterface esplicito utilizzando un tipo di riferimento a un'interfaccia visibile da COM. Non utilizzare una stringa per fornire il nome dell'interfaccia. </value>
  </data>
  <data name="MissingComDefaultInterfaceTitle" xml:space="preserve">
    <value>Attributo ComDefaultInterface mancante</value>
  </data>
  <data name="MissingExampleElement" xml:space="preserve">
    <value>Elemento xml-doc 'example' mancante</value>
  </data>
  <data name="MissingExampleElementDescription" xml:space="preserve">
    <value>Le ispezioni xml-doc dovrebbero avere almeno un elemento 'example', meglio ancora se due. Se viene fornito un solo esempio, il sito web presuppone che l'esempio di codice inneschi l'ispezione. Se vengono forniti due esempi, si presume che il secondo esempio non attivi l'ispezione. Si presume che qualsiasi altro esempio inneschi l'ispezione.</value>
  </data>
  <data name="MissingExampleElementMessageFormat" xml:space="preserve">
    <value>La documentatione XML di tipo '{0}' non ha alcun elemento &lt;example&gt;.</value>
  </data>
  <data name="MissingGuidDescription" xml:space="preserve">
    <value>I tipi visibili da COM devono avere un attributo Guid esplicito. Ciò è necessario per evitare problemi con le versioni. Fare riferimento alle costanti RubberduckGuid.</value>
    <comment>Una descrizione opzionale più lunga localizzabile del dignostico.</comment>
  </data>
  <data name="MissingGuidId" xml:space="preserve">
    <value>Guid mancante</value>
  </data>
  <data name="MissingGuidMessageFormat" xml:space="preserve">
    <value>Il tipo visibile da COM '{0}' non dispone di un attributo Guid esplicito che fa riferimento a una costante RubberduckGuid.</value>
    <comment>Il messaggio formattabile che il diagnostico visualizza.</comment>
  </data>
  <data name="MissingGuidTitle" xml:space="preserve">
    <value>Attributo Guid Mancante</value>
    <comment>Il titolo del diagnostico.</comment>
  </data>
  <data name="MissingHasResultAttribute" xml:space="preserve">
    <value>L'elemento 'example' richiede un attributo 'hasresult' (bool), che non è fornito.</value>
  </data>
  <data name="MissingHasResultAttributeDescription" xml:space="preserve">
    <value>Questo valore di attributo verrà utilizzato per identificare chiaramente quali esempi sono per il codice che attiva un'ispezione, rispetto agli esempi per il codice che non lo fa.</value>
  </data>
  <data name="MissingHasResultAttributeMessageFormat" xml:space="preserve">
    <value>L'elemento 'example' non ha l'attributo 'hasresult'.</value>
  </data>
  <data name="MissingInspectionHostAppElement" xml:space="preserve">
    <value>Elemento xml-doc 'hostApp' mancante</value>
  </data>
  <data name="MissingInspectionHostAppElementDescription" xml:space="preserve">
    <value>La documentazione XML per le ispezioni con un [RequiredHostAttribute] deve includere un elemento &lt;hostApp&gt; con un attributo 'name' con lo stesso valore di [RequiredHostAttribute]. Ad esempio [RequiredHost ("Excel")] impone &lt;hostApp name = "Excel" /&gt;.</value>
  </data>
  <data name="MissingInspectionHostAppElementMessageFormat" xml:space="preserve">
    <value>Nella documentazione XML per il tipo '{0}' manca un elemento 'hostApp'.</value>
  </data>
  <data name="MissingInspectionReferenceElement" xml:space="preserve">
    <value>Elemento xml-doc 'reference' mancante</value>
  </data>
  <data name="MissingInspectionReferenceElementDescription" xml:space="preserve">
    <value>La documentazione XML per le ispezioni con un [RequiredLibraryAttribute] deve includere un elemento &lt;reference&gt; con un attributo 'name' con lo stesso valore di [RequiredLibraryAttribute]. Ad esempio [RequiredLibrary ("Excel")] impone &lt;reference name = "Excel" /&gt;.</value>
  </data>
  <data name="MissingInspectionReferenceElementMessageFormat" xml:space="preserve">
    <value>Nella documentazione XML per il tipo '{0}' manca un elemento 'reference'.</value>
  </data>
  <data name="MissingInspectionSummaryElementDescription" xml:space="preserve">
    <value>Tutte le ispezioni devono contenere un breve commento xml-doc &lt;summary&gt; che descrive ciò che l'ispezione sta cercando, leggibile comodamente in IntelliSense.</value>
  </data>
  <data name="MissingInspectionWhyElement" xml:space="preserve">
    <value>Elemento xml-doc 'why' mancante</value>
  </data>
  <data name="MissingInspectionWhyElementDescription" xml:space="preserve">
    <value>Le ispezioni xml-doc devono avere un elemento 'why' che contiene un paragrafo che spiega il ragionamento alla base dell'ispezione.</value>
  </data>
  <data name="MissingInspectionWhyElementMessageFormat" xml:space="preserve">
    <value>Nella documentazione XML per il tipo '{0}' manca un elemento &lt;why&gt;.</value>
  </data>
  <data name="MissingInterfaceTypeDescription" xml:space="preserve">
    <value>Le interfacce visibili da COM devono avere un attributo InterfaceType esplicito, in genere impostato su Dual o Dispatch per le interfacce degli eventi. </value>
  </data>
  <data name="MissingInterfaceTypeId" xml:space="preserve">
    <value>MissingInterfaceType</value>
  </data>
  <data name="MissingInterfaceTypeMessageFormat" xml:space="preserve">
    <value>L'interfaccia visibili da COM '{0}' non dispone di un attributo InterfaceType esplicito con il tipo di interfaccia impostato. InterfaceIsDual è la scelta consigliata, a meno che non si tratti di un evento, nel qual caso si consiglia invece InterfaceIsIDispatch.</value>
  </data>
  <data name="MissingInterfaceTypeTitle" xml:space="preserve">
    <value>Attributo InterfaceType Mancante</value>
  </data>
  <data name="MissingModuleElement" xml:space="preserve">
    <value>Nella documentazione XML di esempio manca un elemento 'module'.</value>
  </data>
  <data name="MissingModuleElementDescription" xml:space="preserve">
    <value>Tutti gli esempi xml-doc di ispezione dovrebbero includere uno o più elementi 'module' con un attributo 'name'.</value>
  </data>
  <data name="MissingModuleElementMessageFormat" xml:space="preserve">
    <value>L'elemento 'example' non ha alcun child 'module'.</value>
  </data>
  <data name="MissingNameAttribute" xml:space="preserve">
    <value>Attributo 'name' mancante.</value>
  </data>
  <data name="MissingNameAttributeDescription" xml:space="preserve">
    <value>Questo valore dell'attributo sarà utilizzato per identificare chiaramente ogni modulo in un esempio di codice.</value>
  </data>
  <data name="MissingNameAttributeMessageFormat" xml:space="preserve">
    <value>Un elemento '{0}' richiede un valore di attributo 'name'.</value>
  </data>
  <data name="MissingProgIdDescription" xml:space="preserve">
    <value>Le classi visibili da COM devono avere un attributo ProgId esplicito. Ciò è necessario per evitare problemi con le versioni. Fare riferimento alle costanti RubberduckProgId.</value>
  </data>
  <data name="MissingProgIdId" xml:space="preserve">
    <value>MissingProgId</value>
  </data>
  <data name="MissingProgIdMessageFormat" xml:space="preserve">
    <value>La classe visibile da COM '{0}' non ha un attributo ProgId esplicito che fa riferimento a una costante RubberduckProgId.</value>
  </data>
  <data name="MissingProgIdTitle" xml:space="preserve">
    <value>Attributo ProgId mancante</value>
  </data>
  <data name="MissingRequiredHostAttribute" xml:space="preserve">
    <value>Attributo 'RequiredHost' mancante</value>
  </data>
  <data name="MissingRequiredHostAttributeDescription" xml:space="preserve">
    <value>L'elemento &lt;hostApp name = "RequiredHost" /&gt; intende documentare la presenza di un [RequiredHostAttribute]. Se l'attributo è mancante correttamente, l'elemento xml-doc dovrebbe essere rimosso.</value>
  </data>
  <data name="MissingRequiredHostAttributeMessageFormat" xml:space="preserve">
    <value>La documentazione XML di tipo '{0}' include un elemento &lt;hostApp&gt;, ma nessun [RequiredHostAttribute] corrispondente è presente nel tipo di ispezione. Previsto: [RequiredHost ("{1}")].</value>
  </data>
  <data name="MissingRequiredLibAttribute" xml:space="preserve">
    <value>Attributo 'RequiredLibrary' mancante</value>
  </data>
  <data name="MissingRequiredLibAttributeDescription" xml:space="preserve">
    <value>L'elemento &lt;reference name="RequiredLibrary" /&gt; intende documentare la presenza di un [RequiredLibraryAttribute]. Se l'attributo è mancante correttamente, l'elemento xml-doc dovrebbe essere rimosso.</value>
  </data>
  <data name="MissingRequiredLibAttributeMessageFormat" xml:space="preserve">
    <value>La documentazione XML di tipo '{0}' include un elemento &lt;reference&gt;, ma nessun [RequiredLibraryAttribute] corrispondente è presente nel tipo di ispezione. Previsto: [RequiredLibrary ("{1}")].</value>
  </data>
  <data name="MissingSummaryElement" xml:space="preserve">
    <value>Elemento xml-doc 'summary' mancante</value>
  </data>
  <data name="MissingSummaryElementMessageFormat" xml:space="preserve">
    <value>Nella documentazione XML per il tipo '{0}' manca un elemento &lt;summary&gt;.</value>
  </data>
  <data name="MissingTypeAttribute" xml:space="preserve">
    <value>Attributo 'type' mancante.</value>
  </data>
  <data name="MissingTypeAttributeDescription" xml:space="preserve">
    <value>Questo valore di attributo sarà utilizzato per determinare il tipo di componente di ogni modulo in un esempio di codice.</value>
  </data>
  <data name="MissingTypeAttributeMessageFormat" xml:space="preserve">
    <value>Un elemento '{0}' richiede un valore di attributo 'type'.</value>
  </data>
  <data name="XmlDocAnalyzerCategory" xml:space="preserve">
    <value>Compatibilità del progetto ad un sito web</value>
  </data>
  <data name="MissingClassInterfaceId" xml:space="preserve">
    <value>ClassInterface mancante</value>
  </data>
</root>