<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AnalyzerCategory" xml:space="preserve">
    <value>COM Management</value>
  </data>
  <data name="ChainedWrapperDescription" xml:space="preserve">
    <value>All types derived from SafeComWrappers should not be chained as it leaks unmanaged resources. Use an explicit local variable for each chained member.</value>
  </data>
  <data name="ChainedWrapperMessageFormat" xml:space="preserve">
    <value>The type '{0}' derives from a SafeComWrapper base. It is called via other SafeComWrapper-derived type '{1}' in the expression '{2}'.</value>
  </data>
  <data name="ChainedWrapperTitle" xml:space="preserve">
    <value>Chained Wrappers</value>
  </data>
  <data name="MissingClassInterfaceDescription" xml:space="preserve">
    <value>COM-visible classes must have an explicit ClassInterface attribute and be set to `None`. This is required to avoid versioning problems.</value>
  </data>
  <data name="MissingClassInterfaceId" xml:space="preserve">
    <value>MissingClassInterface</value>
  </data>
  <data name="MissingClassInterfaceMessageFormat" xml:space="preserve">
    <value>COM-visible class '{0}' does not have an explicit ClassInterface attribute that is also set to 'ClassInterfaceType.None'.</value>
  </data>
  <data name="MissingClassInterfaceTitle" xml:space="preserve">
    <value>Missing ClassInterface Attribute</value>
  </data>
  <data name="MissingComDefaultInterfaceDescription" xml:space="preserve">
    <value>COM-visible classes must have an explicit ComDefaultInterface attribute referring to a COM-visible interface.</value>
  </data>
  <data name="MissingComDefaultInterfaceId" xml:space="preserve">
    <value>MissingComDefaultInterface</value>
  </data>
  <data name="MissingComDefaultInterfaceMessageFormat" xml:space="preserve">
    <value>COM-visible class '{0}' must have an explicit ComDefaultInterface attribute using a typeof reference to a COM-visible interface. Do not use string to provide the interface name. </value>
  </data>
  <data name="MissingComDefaultInterfaceTitle" xml:space="preserve">
    <value>Missing ComDefaultInterface Attribute</value>
  </data>
  <data name="MissingExampleElement" xml:space="preserve">
    <value>Missing xml-doc 'example' element</value>
  </data>
  <data name="MissingExampleElementDescription" xml:space="preserve">
    <value>Inspections xml-doc should have at least one 'example' element, ideally two. If only one example is provided, website assumes the code example triggers the inspection. If two examples are provided, the second example is assumed to not trigger the inspection. Any further example is assumed to trigger the inspection.</value>
  </data>
  <data name="MissingExampleElementMessageFormat" xml:space="preserve">
    <value>XML documentation of type '{0}' has no &lt;example&gt; element.</value>
  </data>
  <data name="MissingGuidDescription" xml:space="preserve">
    <value>COM-visible types must have an explicit Guid attribute. This is required to avoid verisoning problems. Refer to RubberduckGuid constants.</value>
    <comment>An optional longer localizable description of the diagnostic.</comment>
  </data>
  <data name="MissingGuidId" xml:space="preserve">
    <value>MissingGuid</value>
  </data>
  <data name="MissingGuidMessageFormat" xml:space="preserve">
    <value>COM-visible type '{0}' does not have an explicit Guid attribute that references a RubberduckGuid constant.</value>
    <comment>The format-able message the diagnostic displays.</comment>
  </data>
  <data name="MissingGuidTitle" xml:space="preserve">
    <value>Missing Guid Attribute</value>
    <comment>The title of the diagnostic.</comment>
  </data>
  <data name="MissingHasResultAttribute" xml:space="preserve">
    <value>'example' element requires a 'hasresult' attribute (bool), which isn't supplied.</value>
  </data>
  <data name="MissingHasResultAttributeDescription" xml:space="preserve">
    <value>This attribute value will be used to clearly identify which examples are for code that triggers an inspection, vs examples for code that doesn't.</value>
  </data>
  <data name="MissingHasResultAttributeMessageFormat" xml:space="preserve">
    <value>'example' element has no 'hasresult' attribute.</value>
  </data>
  <data name="MissingInspectionReferenceElement" xml:space="preserve">
    <value>Missing xml-doc 'reference' element</value>
  </data>
  <data name="MissingInspectionReferenceElementDescription" xml:space="preserve">
    <value>XML documentation for inspections with a [RequiredLibraryAttribute] must include a &lt;reference&gt; element with a 'name' attribute with the same value as the [RequiredLibraryAttribute]. For example [RequiredLibrary("Excel")] mandates &lt;reference name="Excel" /&gt;.</value>
  </data>
  <data name="MissingInspectionReferenceElementMessageFormat" xml:space="preserve">
    <value>XML documentation for type '{0}' is missing a 'reference' element.</value>
  </data>
  <data name="MissingSummaryElement" xml:space="preserve">
    <value>Missing xml-doc 'summary' element</value>
  </data>
  <data name="MissingInspectionSummaryElementDescription" xml:space="preserve">
    <value>All inspections must have a short &lt;summary&gt; xml-doc comment describing what the inspection is looking for, that reads comfortably in IntelliSense.</value>
  </data>
  <data name="MissingSummaryElementMessageFormat" xml:space="preserve">
    <value>XML documentation for type '{0}' is missing a &lt;summary&gt; element.</value>
  </data>
  <data name="MissingInspectionWhyElement" xml:space="preserve">
    <value>Missing xml-doc 'why' element</value>
  </data>
  <data name="MissingInspectionWhyElementDescription" xml:space="preserve">
    <value>Inspections xml-doc must have a 'why' element that contains a paragraph explaining the reasoning behind the inspection.</value>
  </data>
  <data name="MissingInspectionWhyElementMessageFormat" xml:space="preserve">
    <value>XML documentation for type '{0}' is missing a &lt;why&gt; element.</value>
  </data>
  <data name="MissingInterfaceTypeDescription" xml:space="preserve">
    <value>COM-visible interfaces must have an explicit InterfaceType attribute, typically set to Dual or Dispatch for event interfaces. </value>
  </data>
  <data name="MissingInterfaceTypeId" xml:space="preserve">
    <value>MissingInterfaceType</value>
  </data>
  <data name="MissingInterfaceTypeMessageFormat" xml:space="preserve">
    <value>COM-visible interface '{0}' does not have an explicit InterfaceType attribute with the type of interface set. InterfaceIsDual is the recommended choice, unless it's an event, in which case, InterfaceIsIDispatch is recommended instead.</value>
  </data>
  <data name="MissingInterfaceTypeTitle" xml:space="preserve">
    <value>Missing InterfaceType Attribute</value>
  </data>
  <data name="MissingModuleElement" xml:space="preserve">
    <value>XML documentation example is missing a 'module' element.</value>
  </data>
  <data name="MissingModuleElementDescription" xml:space="preserve">
    <value>All inspection xml-doc examples should include one or more 'module' element with a 'name' attribute.</value>
  </data>
  <data name="MissingModuleElementMessageFormat" xml:space="preserve">
    <value>'example' element has no 'module' child.</value>
  </data>
  <data name="MissingNameAttribute" xml:space="preserve">
    <value>Missing 'name' attribute.</value>
  </data>
  <data name="MissingNameAttributeDescription" xml:space="preserve">
    <value>This attribute value will be used to clearly identify each module in a code example.</value>
  </data>
  <data name="MissingNameAttributeMessageFormat" xml:space="preserve">
    <value>A '{0}' element requires a 'name' attribute value.</value>
  </data>
  <data name="MissingProgIdDescription" xml:space="preserve">
    <value>COM-visible classes must have an explicit ProgId attribute. This is required to avoid verisoning problems. Refer to RubberduckProgId constants.</value>
  </data>
  <data name="MissingProgIdId" xml:space="preserve">
    <value>MissingProgId</value>
  </data>
  <data name="MissingProgIdMessageFormat" xml:space="preserve">
    <value>COM-visible class '{0}' does not have an explicit ProgId attribute that references a RubberduckProgId constant.</value>
  </data>
  <data name="MissingProgIdTitle" xml:space="preserve">
    <value>Missing ProgId Attribute</value>
  </data>
  <data name="MissingRequiredLibAttribute" xml:space="preserve">
    <value>Missing 'RequiredLibrary' attribute</value>
  </data>
  <data name="MissingRequiredLibAttributeDescription" xml:space="preserve">
    <value>The &lt;reference name="RequiredLibrary" /&gt; element means to document the presence of a [RequiredLibraryAttribute]. If the attribute is correctly missing, the xml-doc element should be removed.</value>
  </data>
  <data name="MissingRequiredLibAttributeMessageFormat" xml:space="preserve">
    <value>XML documentation of type '{0}' includes a &lt;reference&gt; element, but no corresponding [RequiredLibraryAttribute] is decorating the inspection type. Expected: [RequiredLibrary("{1}")].</value>
  </data>
  <data name="XmlDocAnalyzerCategory" xml:space="preserve">
    <value>Project website compatibility</value>
  </data>
  <data name="MissingTypeAttribute" xml:space="preserve">
    <value>Missing 'type' attribute.</value>
  </data>
  <data name="MissingTypeAttributeDescription" xml:space="preserve">
    <value>This attribute value will be used to determine the component type of each module in a code example.</value>
  </data>
  <data name="MissingTypeAttributeMessageFormat" xml:space="preserve">
    <value>A '{0}' element requires a 'type' attribute value.</value>
  </data>
  <data name="InvalidTypeAttribute" xml:space="preserve">
    <value>Invalid value for 'type' attribute.</value>
  </data>
  <data name="InvalidTypeAttributeDescription" xml:space="preserve">
    <value>The values of the 'type' attribute are restricted to the value 'Standard Module', 'Class Module', 'Document' and 'User Form'.</value>
  </data>
  <data name="InvalidTypeAttributeMessageFormat" xml:space="preserve">
    <value>The value '{0}' is not legal for the 'type' attribute.</value>
  </data>
  <data name="DuplicateNameAttribute" xml:space="preserve">
    <value>Duplicate value in 'name' attribute</value>
  </data>
  <data name="DuplicateNameAttributeDescription" xml:space="preserve">
    <value>The 'name' attribute is used to uniquely identify an element. Consequently, it has to be unique.</value>
  </data>
  <data name="DuplicateNameAttributeMessageFormat" xml:space="preserve">
    <value>The value '{0}' is used in the 'name' attribute of multiple '{1}' elements.</value>
  </data>
  <data name="MissingRequiredHostAttribute" xml:space="preserve">
    <value>Missing 'RequiredHost' attribute</value>
  </data>
  <data name="MissingRequiredHostAttributeDescription" xml:space="preserve">
    <value>The &lt;hostApp name="RequiredHost" /&gt; element means to document the presence of a [RequiredHostAttribute]. If the attribute is correctly missing, the xml-doc element should be removed.</value>
  </data>
  <data name="MissingRequiredHostAttributeMessageFormat" xml:space="preserve">
    <value>XML documentation of type '{0}' includes a &lt;hostApp&gt; element, but no corresponding [RequiredHostAttribute] is decorating the inspection type. Expected: [RequiredHost("{1}")].</value>
  </data>
  <data name="MissingInspectionHostAppElement" xml:space="preserve">
    <value>Missing xml-doc 'hostApp' element</value>
  </data>
  <data name="MissingInspectionHostAppElementDescription" xml:space="preserve">
    <value>XML documentation for inspections with a [RequiredHostAttribute] must include a &lt;hostApp&gt; element with a 'name' attribute with the same value as the [RequiredHostAttribute]. For example [RequiredHost("Excel")] mandates &lt;hostApp name="Excel" /&gt;.</value>
  </data>
  <data name="MissingInspectionHostAppElementMessageFormat" xml:space="preserve">
    <value>XML documentation for type '{0}' is missing a 'hostApp' element.</value>
  </data>
  <data name="MissingAnnotationSummaryElementDescription" xml:space="preserve">
    <value>All annotations must have a short &lt;summary&gt; xml-doc comment describing what the annotation is used for, that reads comfortably in IntelliSense.</value>
  </data>
</root>